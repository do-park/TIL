# 10. 잭이 개발한 코드

> 소스 코드를 실행 가능한 코드로 바꾸는 메커니즘



### 10.1 언어 장벽

#### 1. 인터프리터 언어

- 특정 빌드 단계를 거치지 않아도 된다.
- 코드 작성 후 인터프리터에 코드가 어디 있는지만 알리면 인터프리터가 실시간으로 파싱하고 명령에 따라 행동한다.
- 펄, 파이썬, 자바스크립트
- 장점
  - 개발 속도: 중간 **컴파일** 단계가 없어 매 변경을 아주 빠르게 테스트할 수 있다.
  - 플랫폼 독립적: 여러 플랫폼에서 다양하게 실행된다.
- 단점
  - 똑같이 컴파일된 프로그램보다 느리게 실행된다.

#### 2. 컴파일 언어

- 빌드 툴체인을 이용해 소스 코드 파일을 타깃 플랫폼에서 실행될 기계 명령으로 변환한다.
- C, C++
- 장점
  - 인터프리팅된 애플리케이션보다 빠르게 실행된다.
- 단점
  - 빌드 절차가 복잡해 실패할 지점이 더 많다. 애플리케이션을 실행할 타깃 플랫폼이 바뀔 때마다 애플리케이션을 다시 컴파일해야 한다.

#### 3. 바이트 컴파일 언어

- 컴파일 언어와 인터프리터 중간쯤에 위치
- 컴파일 단계가 있지만, 실행 가능한 네이티브 프로그램은 생성하지 않는다.
- **가상 머신**(virtual machine)에서 실행할 수 있는 의사 기계어(pseudo machine language)인 **바이트 코드**로 된 파일을 만든다.
- 자바, C#
- 동등한 컴파일 바이너리보다 항상 느리지는 않다.
- 가상 머신이 이식된 어떤 플랫폼에서든 실행될 수 있는 이식성을 지닌다.



### 10.2 자세히 들여다보기



### 10.3 빌드 만들기

- 용어와 조건
  - 소스 코드
    - 소스 코드는 물리적으로 작성한 파일에 저장되고 대개 고수준 언어로 만든다. 언어 구조체는 적절한 도구를 사용해 동작하는 프로그램으로 변환할 수 있다.
  - 컴파일(compile)
    - 소스 코드는 두 가지 방식 중 하나로 실행 파일로 변환된다. 하나는 소스 코드를 실행 가능한 프로그램으로 **컴파일**하는 것이다. 또한, 다른 방법은 소스 코드를 실시간으로 **인터프리팅**하는 것이다. 프로그램을 실행하며 언어 런타임이 소스 코드를 파싱하고 명령에 따라 행동한다.
  - 빌드
    - **컴파일**과 자주 동의어로 쓰이는 모호한 용어다. 컴파일은 구성 단계 중 하나지만 빌드는 전체 구성 과정을 뜻한다. make라는 용어가 유사하게 모호한 방식으로 쓰이는데 더 큰 문제는 유명한 소프트웨어 빌드 도구의 이름이기도 하다는 점이다.
  - 목적 코드(object code)
    - 목적 코드는 **목적 파일**에 들어 있다. 소스 코드 파일을 컴파일한 버전을 말한다. 객체 코드가 바로 실행 파일은 아니며 이 코드는 다른 코드 파일에 의존한다. (대부분의 프로그램이 둘 이상의 소스 파일로 만들어진다) 실행 파일(executable)을 만들려면 목적 파일을 다른 목적 파일과 **링킹**해야 한다.
  - 라이브러리
    - 코드 라이브러리는 목적 파일과 비슷하다. 컴파일된 코드 모음일 뿐 그 자체로 전체 프로그램은 아니다. 라이브러리는 어떤 프로그램에든 통합될 수 있는 유용한 기능을 응집해 놓은 모음이다. 라이브러리는 **정적** 또는 **동적**일 수 있다. 정적 라이브러리는 목적 파일처럼 링킹되는 반면 동적 라이브러리는 애플리케이션이 실행될 때 그 애플리케이션에 의해 동적으로 로딩된다.
  - 기계 코드(machine code)
    - 어떤 컴파일 단계는 목적 파일이 아닌 **기계 코드**를 만든다. 기계 코드는 프로그램을 위한 CPU 명령을 정확히 표현한 소스 코드 형태다. 기계 코드는 **어셈블러**에 의해 진짜 CPU 명령어로 변환되는데 그래서 **어셈블리 코드**라고도 불린다.
  - 링킹(linking)
    - **링커**는 둘 이상의 **목적 파일**을 합쳐 최종 실행 파일 또는 부분적으로 링킹된 코드 **라이브러리**를 만든다.
  - 실행 파일(executable)
    - 컴파일이나 링킹 단계의 결과물이다. 컴퓨터에서 바로 실행할 수 있는 독립적인 프로그램이다.
- 빌드 시스템을 소스 트리의 한 부분으로 여기고 함께 유지보수하자.



### 10.4 훌륭한 빌드 시스템이란 무엇일까?

#### 1. 단순성

- 빌드 전문가뿐 아니라 **모든** 프로그래머가 이해하기 쉬워야 한다.

1. 배우기 쉽다
2. 준비하기 쉽다
3. 당연하다

#### 2. 획일성

- 프로젝트에 참여한 모든 프로그래머가 같은 빌드 환경을 사용해야 한다.

#### 3. 반복성과 안정성

- 훌륭한 빌드 시스템은 물리적으로 동일한 바이너리 파일을 반복적으로 생성하게 해준다.
- 빌드는 언제나 완벽하게 동작해야 한다. 즉 **안정적**이어야 한다.
- 빌드는 대부분 눈에 보이지 않아야 한다. 유일하게 신경 쓸 부분은 동작시키는 방법이며 최종적으로 제대로 된 결과물이 나오리라는 자신이 있어야 한다.

#### 4. 원자성

- 훌륭한 빌드는 한 단계로 표현된다.

#### 5. 오류 대처

- 빌드 시스템은 오류가 나면 동작을 멈춰야 한다.
- 빌드 시스템은 하나의 빌드 단계가 실패하면 불완전한 객체를 전부 제거해야 한다.
- 빌드는 **시끄러워서는** 안 된다. 수많은 어리석은 경고가 **반드시** 읽어야 하는 은밀한 메시지를 가릴 수도 있다.



### 10.5 빌드 기법

#### 1. 타깃 선택

- 타깃 규칙끼리 무엇이 다를까?
  - 빌드될 파일
  - 컴파일러에 전달할 매크로 정의
  - 사용되는 컴파일러 옵션
  - 빌드 시 선택하는 도구 세트나 환경

#### 2. 정리(housekeeping)

- 빌드 규칙마다 동작을 되돌리는 정리 규칙을 두자.

#### 3. 종속성

#### 4. 자동화된 빌드

- 자동 빌드를 사용해 코드 기반을 일관된 상태로 유지하자.
- **지속적인 통합**(continuous integration): 언제든지 코드가 일관되고 빌드 가능한지 확인할 수 있는 강력한 방법

#### 5. 빌드 구성

#### 6. 재귀 메이크

- **재귀 메이크**(recursive make): 각 하위 디렉터리를 재귀적으로 방문하는 빌드 시스템은 거기서 컴포넌트를 빌드한 후 상위 디렉터리 내 컴포넌트 빌드로 돌아온다.
- 가능하면 비재귀적인 빌드 시스템을 만들자.



### 10.6 이제 출시해 주세요

- **릴리스 빌드**(release build)
  - 빌드 시스템뿐만 아니라 그 절차에 의해서도 크게 좌우된다.



### 10.7 다재다능 빌드마스터?

- **빌드마스터**(buildmaster), **빌드기술자**(build engineer): 빌드 시스템 유지 보수