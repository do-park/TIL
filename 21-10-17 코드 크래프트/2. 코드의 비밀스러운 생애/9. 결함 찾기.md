# 9. 결함 찾기

> 디버깅: 뭔가 잘못됐을 때 하는 것



### 9.1 삶의 진실

- 소프트웨어 오류가 전적으로 피할 수 없는 것은 **아님**을 인정해야 한다.



### 9.2 야수의 본성

#### 1. 천 미터 상공에서 내려다보기

- 세 가지 범주의 버그
  - 컴파일 실패
  - 런타임 충돌
  - 예상치 못한 동작

- 실패는 결함이 있는 코드 한 줄로 인해 스스로 모습을 드러낼 수도 있고 가정이 크게 어긋나는 상호 연결 모듈 몇 개를 서로 연결했을 때만 드러날 수도 있다.

#### 2. 땅에서 바라보기

- 결함 부류
  - 구문 오류
  - 빌드 오류
  - 기본적인 의미(semantic) 버그
  - 의미 버그

#### 3. 입체적으로 바라보기

- 일반적인 의미 결함 유형
  - 세그멘테이션 결함
  - 메모리 오버런(overrun)
  - 메모리 누수(leak)
  - 메모리 고갈
  - 수학 오류
  - 프로그램 정지



### 9.3 해충 박멸

- 디버깅에서 단 하나의 가장 중요한 규칙: **두뇌를 사용하자**

#### 1. 저차원적 방법

- "체계적이지 않은" 디버깅에는 제한 시간을 적절히 설정하고 성공하지 못하면 보다 체계적인 방법을 따르자.

#### 2. 고차원적 방법

- 버그 제거의 두 가지 측면
  - 버그를 일으킨 결함을 **찾는** 것
  - 그 결함을 **고치는** 것
- 결함을 얼마나 쉽게 찾을지는 그 결함이 숨겨진 코드를 얼마나 잘 아느냐에 달렸다. 새로운 코드를 디버깅해야 한다면 먼저 그 코드를 **익히는** 시간을 가지자.
- 디버깅 용이성은 실행 중인 프로그램에 얼마나 많이 관여하고 상태를 조사할 수 있는지 등 실행 환경에 대한 제어권을 얼마나 갖고 있느냐에 달렸다.
- 디버깅 무기고에서 가장 강력한 무기 중 하나가 다른 이의 코드를 향한 올곧은 비평이 뒤섞인 불신이다. 잘못된 동작의 원인은 무엇이든 될 수 있으니 진단 시 가장 아닐 것 같은 후보부터 제거하기 시작해야 한다.
- 결함을 찾을 때는 전부 의심하자. 관련이 전혀 없을 것이라 지레 짐작하지 말고 가장 일어날 가능성이 작은 원인부터 먼저 제거하자. 무엇도 가정하지 말자.



### 9.4 버그 사냥

#### 1. 컴파일 타임 오류

#### 2. 런타임 오류

1. 실패를 찾자
2. 실패를 재현하자
3. 결함의 위치를 찾자
   - 버그 사냥 전략
     - 최악은 실패 여부를 보기 위해 무작위로 변경하는 것이다.
     - 훨씬 나은 전략은 **분할 정복**(devide and conquer)이다.
     - **드라이 런**(dry run, 예행 연습, 모의 실습, 시운전) 기법도 있다. 직감에 의존해 오류를 찾기보다 스스로 컴퓨터 역할을 수행해 시운전으로 프로그램 실행을 따라가고 모든 중간값을 계산해 최종 결과를 얻는 방법이다.
4. 문제를 이해하자
   - 역추적해서 문제의 원인이 무엇인지, 다른 코드 조각에 같은 실수가 없었는지 정확히 파악하자.
5. 테스트를 만들자
6. 결함을 고치자
7. 고친 코드를 증명하자
8. 모든 방법이 통하지 않으면
   - **페어 프로그래밍**(pair programming)



### 9.5 결함을 고치는 방법

- 문제는 결함을 **찾는** 일이다. 어디 있는지만 알아내면 수정은 쉽다.
- 최대한 주의를 기울여 버그를 수정하자. 고치는 중에 다른 것을 고장 내는 위험을 무릅쓰지 말자.
- 버그를 고칠 때 같은 실수가 연관된 코드 영역에 도사리고 있지 않은지 확인하자. 결함이 발생하는 곳을 전부 수정해 마지막으로 한번 더 버그를 몰살시키자.
- 각 결함을 수정할 때마다 교훈을 얻자.



### 9.6 예방

- 문제를 올바르게 풀어야 할뿐 아니라 시작하기 전에 전체 문제를 **완전히** 이해해야 한다.
- **두뇌를 사용하자.**



### 9.4 말벌 스프레이, 민달팽이 퇴치제, 파리잡이 끈끈이

#### 1. 디버거

#### 2. 메모리 접근 검증자

#### 3. 시스템 호출 누적

#### 4. 코어 덤프

#### 5. 로깅

