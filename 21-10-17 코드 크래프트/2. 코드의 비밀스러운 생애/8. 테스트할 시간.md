# 8. 테스트할 시간

> 코드 테스트 마술



- 테스트를 통해 숨어 있는 모든 문제를 찾고, 코드를 수정하며 코드 품질에 대한 신뢰를 이어간다.
- 용어 정의
  - 오류
    - **개발자**가 잘못한 것
  - 결함
    - 소프트웨어에 내재된 오류의 결과.
    - 개발자가 오류를 만들면 이것이 코드 내에 결함을 야기한다.
    - 코드 리뷰에서는 결함을 찾을 수도 있으나 실행 중인 프로그램에서는 결함을 식별해 낼 수 없다.
  - 실패
    - 결함이 발생하면 **실패**가 일어나기도 한다.
    - 진짜 신경써야 할 부분이자 유일하게 알아차릴 수 있는 현상
  - 버그
    - 결함과 동의어로 쓰이는 구어적 표현



### 8.1 현실성 검증

- 테스트에 있어 단 하나의 가장 중요한 원칙은 테스트를 하는 것이다. [커니핸 파이크 99]
- 테스트 소프트웨어 내 결함의 존재 혹은 부재를 밝히는 체계적인 과정이다.
- 테스트는 디버깅을, 디버깅은 수정을, 수정은 또 다른 테스트를 야기한다.



### 8.2 누가, 언제, 무엇을, 왜?

#### 1. 왜 테스트하는가?

- 테스트 절차란 결함을 찾고 수정할 수 있도록, 같은 결함이 이후 버전에서 다시 나오지 않도록 존재한다.
- 테스트로는 결함이 없다고 증명할 수 없으며 결함의 존재만 드러낼 뿐이다.
- 출시가 가능한지 증명하려면 소프트웨어 컴포넌트가 올바르고 결함을 포함하지 않는다고 **입증**(verifying)해야 할 뿐 아니라 애초에 수립된 요구사항을 확실히 충족하는지 **검증**(validate) 해야 할 수도 있다.

#### 2. 누가 테스트하는가?

- 소스 코드를 작성한 **프로그래머**에게 테스트할 책임이 있다.

#### 3. 테스트에 무엇이 수반되는가?

- 주된 테스트 전략은 **테스트 코드**라는 코드를 추가로 작성해 이러한 코드를 전부 돌려 보며 동작을 검증하는 것이다.
- 테스트마다 다음과 같은 사항을 확인하자.
  - 정확히 어떤 코드 조각을 테스트하고 있는지
  - 테스트에 사용 중인 메서드
  - 언제 끝날지

#### 4. 언제 테스트하는가?

- 코드를 **작성하며** 테스트함으로써 되도록 빨리 코딩 오류를 잡자.
- 찾아낸 결함마다 테스트를 작성하자.



### 8.3 테스트는 어렵지 않다...?

- 테스트는 **정말** 어렵다.
- 테스트 하네스(test harness): 테스트를 위해 생성된 코드와 데이터
  - 모든 유효한 입력에 대해 올바른 출력을 생성한다.
  - 모든 유효하지 않은 입력에 대해 적절한 실패 동작을 생성한다.
- 작성한 코드는 실제 작성한 대로가 아니라 작성하려고 의도했던 대로 읽힌다. 모든 코드를 비판적으로 읽자.

- 테스트 복잡도를 높이는 요인
  - 코드 크기
  - 종속성
    - **테스트할 수 없는 디자인**(untestable design)
  - 외부 입력
  - 외부 자극
  - 스레드
  - 진화
  - 하드웨어 결함
  - 끔찍한 실패 방식
- 테스트는 단지 소프트웨어가 **충분하다**(adequate)고만 증명할 뿐 소프트웨어가 무적이라고는 증명하지 못한다. 

### 8.4 테스트 유형

- 단위 테스트

- 컴포넌트 테스트

- 통합 테스트

- 회귀 테스트

- 부하(load) 테스트

- 스트레스(stress) 테스트

- 유지(soak) 테스트

- 유용성(usability) 테스트

- 블랙박스 테스트: **기능 테스트**(functional testing)

- 화이트 박스 테스트: **구조 테스트**(structural testing)

- 알파, 베타, 감마...

  - 알파 소프트웨어: 첫 '코드 완성' 단계. 아직 버그가 아주 많이 있을 수 있고 완벽히 신뢰하기 어려울 수 있다. 뻔한 결함을 잠시 제쳐두면 알파 소프트웨어는 최종 제품이 어떤 모습일지 잘 보여준다.

  - 베타 소프트웨어: 알파 단계를 잘 거친 베타 소프트웨어에는 버그가 **거의** 없고 아주 소수의 문제만 남는다. 최종 제품과 크게 다르지 않다. **베타** 테스트는 최종 배포 후보에 남아 있는 이슈를 해결하는 데 쓰인다. 대부분 현실 세계에서의 현장 실험을 포함한다.
  - 배포 후보: 정식 소프트웨어 배포 전 마지막 단계다. 후보 빌드들은 제품 배포에 앞서 확인(verificatino)과 **보증 테스트**(assurance testing, validation)를 거친다. 배포 후보는 내부 빌드로서 일반적으로 테스트 부서에게만 전달된다.

  - 알파와 베타 배포가 위험을 무릅쓰고 외부에 공개될 때는 제약이 많은 형태(가령 시간이 제한된 연산)일 수 있다. 배포 후보는 이러한 제한이 전혀 없는 "순수" 빌드다.
  - :rabbit: 우리 프로그램이 당장 다음주에 릴리즈된다면, 이것은 알파 소프트웨어가 배포되는 꼴이지 않을까. 내가 생각했던 것 보다 더 두려운 일이 나를 기다리고 있는 것 같아 겁이 난다.



### 8.5 단위 테스트 케이스 고르기

- 코드의 다양한 측면을 실험하는 포괄적인 테스트 묶음을 작성하자. 똑같은 결함을 반복해서 보여주는 테스트 15개보다 서로 다른 결함 15개를 드러내는 테스트15개가 더 유용하다.

- 블랙박스 테스트의 테스트 케이스
  - 올바른 입력
  - 잘못된 입력
  - 경곗값
  - 무작위 데이터
  - 0(Zero)



### 8.6 테스트 디자인

- 테스트하기 쉽도록 코드를 디자인하자.
- 테스트 용이성을 염두해 코드를 구성하면 합리적이면서 이해하기 쉽고 유지 보수가 가능한 방식으로 구성된다. 컴포넌트 간 커플링이 줄고 응집력이 높아진다. 더 유연하고 사용하기 쉬우며 다양하게 설정하기도 쉽다.
- 또한, 테스트가 잘 됐으니 코드가 올바를 가능성도 훨씬 크다.
- 몇 가지 간단한 디자인 규칙
  - 각 코드 영역에 문서화를 달고 불확실한 외부 의존성을 없애 독립적으로 만들자.
  - 전역 변수(또는 전역을 감싸는 **싱글턴** 객체)에 의존하지 말자.
  - 코드를 개별적으로 테스트할 수 있는 작고 이해하기 쉬운 바이트 크기의 덩어리로 쪼갬으로써 복잡도를 제한하자.
  - 코드를 감시할 수 있게 만들어서 코드가 무엇을 하는지 보고 내부 상태를 질의하고 원하는 대로 연산하는지 확인하자.



### 8.7 직접 하지 않아도 돼!

- 코드 테스트를 최대한 자동화하자. 테스트를 직접 돌리는 것보다 빠르고 쉬우며 훨씬 안전하다. 테스트는 대부분 정기적으로 수행된다.
- 단위 테스트를 빌드 과정에 포함시켜 실행하자.



### 8.8 실패의 단면

- 테스트 중에 프로그램이 실패했을 때는 아래 단계를 따라가며 실패의 본질을 정확하게 밝힘으로써 스스로 혹은 다른 개발자가 나중에 다시 돌아와 문제를 해결할 수 있게 하자.
  1. 그 당시 무엇을 하려던 중이었는지, 어떤 동작이 실패를 유발했는지에 주목하자.
  2. 다시 시도해보자. 문제가 반복되는지, 얼마나 자주 불쑥 발생하는지, 동시 실행되던 다른 동작과 동시에 발생하는지 알아내자.
  3. 결함을 묘사하자. 충분히. 그리고 아주 구체적으로. 다음을 설명에 포함시키자.
     - 문제의 맥락
     - 문제를 재현할 수 있는 가장 간단한 단계
     - 반복성과 발생 주기에 관한 정보
     - 소프트웨어 버전, 정확한 빌드 번호, 사용한 하드웨어
     - 관련 있을 법한 그 밖의 모든 것
  4. 기록하자. 잃어버리지 말자! 혼자 고쳐보려던 간단한 코딩 오류까지도 결함 추적 시스템에 정보를 저장하자.
  5. 실패를 드러낼 수 있는 가장 간단한 테스트 하네스를 작성하고 자동 테스트 묶음에 추가하자. 결함을 잃어버리거나 무시하지 않게, 일단 수정되고 나면 개발 중에 다시 발생하지 않게 해준다.



### 8.9 이겨낼 수 있는가?

- 결함을 **찾아내려면** 체계적이고 조직적이어야 한다. 또한, 결함을 관리하고 처리하는 일도 체계적이고 조직적이어야 한다.
- 프로그래머는 코드페이스, 즉 자신이나 다른 사람의 코드에서 문제를 찾는다.
- 코드 통합자는 하나로 합친 컴포넌트로서의 오류를 찾는다.
- QA 부서는 테스트하며 제품 결함을 찾는다.

#### 1. 결함 추적 시스템

- **결함 추적 시스템**(fault-tracking system)
- 테스트 절차에 참여한 모두가 볼 수 있는 인터페이스가 딸린 특수한 데이터베이스
- 실패 보고
- 책임 할당
- 보고 우선순위 지정
- 수정 완료 표시
- 보고 종료
- 데이터베이스 질의
- 항목 수정

#### 2. 버그 리뷰





​	