# 15. 소프트웨어 진화 혹은 소프트웨어 혁명?

> 코드는 어떻게 발전하는가?



### 15.1 소프트웨어 부패

- 소프트웨어 개발 단계 중 **유지 보수** 단계가 항상 제일 길다.
- 출시 후에는 제약이 생긴다.
  - 세심히 테스트한 코드 기반에 영향을 덜 주려면 변경을 최소화해야 한다.
  - 공개 API는 이미 고객이 사용 중이라 수정하기 더 어렵다.
  - 사용자는 UI에 익숙하니 타당한 근거 없이 바꿀 수 없다.
  - 코드는 항상 **이렇게** 동작해 왔으니 **저렇게** 바꿀 수 없다.
  - 뒤늦게 아키텍처를 조정하기 너무 힘들다.
  - 제품이 그렇게 오래 가지 않을 테니 이제 와서 올바르게 수정하기에는 시간이나 비용이 아깝다.
- 코드 수정이 품질을 자주 저하시킨다는 사실을 명심하자. 시스템을 악화시키는 변경을 그대로 지나치지 말자.



### 15.2 경고 신호

- 긴 클래스와 복잡한 함수로 뒤덮여 코드가 어수선하다.
- 함수명이 난해하거나 오해를 불러일으킨다. 함수명으로 알 수 없는 뜻밖의 부수 효과가 함수에 들어 있다.
- 구조가 없어서 어떤 기능을 어디서 찾아야 할지 분명하지 않다.
- 중복이 있다. 여기저기 흩어진 별개 코드 조각이 똑같은 기능을 수행한다.
- 커플링이 강하다. 모듈 간 상호 연결 및 종속성이 복잡하면 작은 변경마저 전체 코드로 파급되고 심지어 겉보기에는 연관 없어 보이는 모듈까지 영향을 받는다.
- 데이터가 시스템을 통과하며 반복적으로 여러 표현으로 변환된다.
- 새 기능이 무분별하게 추가되면서 간결했던 인터페이스의 범위가 지나치게 광범위해지면 API가 모호해진다.
- 코드 리비전이 일어날 때 API가 급격히 바뀐다.
- 다른 코드를 간편하게 개발하기 위해 프라이빗 구현을 공개 API로 뺀다.
- 원인이 아닌 증상을 고치는 수정본으로 코드를 어지럽힌다. 이러한 해결책은 실제 문제를 감춘다. 시스템 핵심부에 결함을 숨겨둔 채 가장자리를 이러한 코드로 채운다.
- 함수 인자가 지나치게 길다. 대부분은 이러한 인자를 쓰지 않고 종속 함수 호출로 넘긴다.
- 너무 두려워 개선할 생각조차 들지 않는 코드가 있다. 개선이 될지 알아채기 힘들게 고장이 날지 심지어 더 안 좋아질지 알 수가 없다.
- 문서화 지원도 없이 새 기능이 추가된다. 기존 문서가 쓸모없어진다.
- 경고를 무수히 늘어놓으며 시끄럽게 컴파일된다.
- **손대지 마시오**같은 주석이 들어 있다.
- 코드가 엉망이 되는 이유는 **복잡도**(complexity) 때문이다.



### 15.3 코드는 어떻게 성장할까?

- 코드 개발은 계속해서 바뀌는 목표를 쫓는 점진적인 개발 주기이다.
- 코드의 성장 메커니즘 (나쁜 방법부터)
  - 운(luck)
  - 부착(accretion)
  - 재작성(rewrite)
  - 리팩터링(refactoring)
  - 성장을 위한 디자인



### 15.4 불가능을 믿다



### 15.5 무엇을 할 수 있을까?

- 양심적으로 코딩하자. 뛰어난 프로그래머는 지금 작성하는 데 얼마나 노력을 쏟아야 하느냐보다 몇 년 후 코드가 어떻게 보일지에 더 신경 쓴다.

#### 1. 새 코드 작성

- 모듈 간 상호 연결을 고려하고 커플링을 최대한 줄인다. 모든 모듈이 의존하는 하나의 중앙 모듈을 두지 않는다. 중앙 모듈을 두면 어떤 변경이 시스템 내 모듈에 전부 영향을 준다.
- 모듈성과 정보 은닉은 현대 소프트웨어 공학의 토대이다. 시스템의 한 부분에서 일어날 것 같은 변화는 분리시키고 시스템을 더 끈끈하게 만들어 변화에 유연해지자.
- 확장성과 유연성을 디자인하되 복잡도를 희생하지 않아야 한다. 근래의 컴포넌트/객체 기반 패러다임은 더 높은 재사용성과 확장성을 보장한다. 코드 모듈 간 명확한 인터페이스 지점도 제공한다. 하지만 인터페이스가 향후 확장을 지원하지 않으면 코드는 성장할 수 없다. 고심해서 시스템 인터페이스를 만들자.
- 훌륭한 문서화와 명확하고 알기 쉽게 명명한 API가 딸린, 이해하고 다루기 쉬운 간결하고 명쾌한 코드를 작성하자. 인터페이스를 문서화할 때 문학적 프로그래밍 도구를 고려하자.
- 키스(KISS)하자. 즉 **제발 단순하게 하자**(Keep It Simple, Stupid). 너무 복잡하게, 그리고 지나치게 기술적으로 만들지 말자. 코드를 더 빠르게 실행할 수 있는 좋은 방법일 것 같을 때 말고 성능 이슈가 있을 때만 알고리즘을 최적화하자. 단순성이 성능보다 대부분 더 중요하고 향후 유지 보수도 당연히 더 수월하다.

#### 2. 기존 코드 유지 보수

- **좋은** 코드를 유지 보수할 때는 디자인 무결성을 세심하게 보호해야 하고 부적절한 요소를 넣지 말아야 한다.

- **나쁜** 코드를 유지 보수할 때는 문제를 더 악화시키지 말아야 하고 가능한 유지 보수 중에 향상시켜야 한다.

- 코드를 변경하기 전 다음과 같은 관리상의 문제를 고려하자.

  - 필요한 변경에 **우선순위를 매기자**. 각 변경의 중요도를 각각의 복잡도와 조율하고 무엇을 먼저 해야 하는지 결정하자. 먼저 바꿨을 때 향후 작업에 영향을 주는 변경이 있는가?
  - 꼭 필요한 변경만 하자. **고장 나지 않았으면 고치지 말자.** 코드 여기저기를 명확한 근거 없이 필요할 것 같다는 이유로 "개선하지" 말자. 정말 필요한 변경만 하자. 앞으로 작업할 잘못된 코드를 리팩터링하자. 나머지는 그대로 두자.
  - 한 번에 몇 가지를 변경하는지 관찰하자. 여러 가지 변경을 **직접** 병행하는 것은 아주 기발하거나 혹은 어리석은 일인데 대부분 후자다. 한 번에 하나씩 하자. 신중하게.
  - 여럿이 동시에 같은 코드를 작업 중일 때는 주변에 무엇이 바뀌고 있는지 알아야 한다. 별개 수정본이 너무 많아 뜻밖의 방식으로 충돌할 위험이 있다. 개발자 한 명이 체계적으로 변경해야 코드가 어디로 뻗어 나가고 어디에 가장 주의해야 하는지 가장 명확하게 알 수 있다. 몇 명이 동시에 변경하면 누구도 이해하거나 알아차리지 못하게 코드에 너무 많은 일을 하는 셈이다.
  - 개발하면서 초기 코드를 리뷰해야 하듯이 뒤 이은 변경도 리뷰해야 한다. 공식 리뷰를 구성하고 코드의 원래 저자를 비롯해 여러 리뷰어를 참여시키자. 조금만 코드를 확장해도 미묘한 버그가 새로 생기기 쉽다. 리뷰는 이러한 오류 대부분을 잡아낸다.

- 코드페이스로 나온 이후 코드를 다루는 법

  - 잘 변경하려면 어떤 코드를 다루고 있는지 알아야 한다.
    - 전체 시스템 내 어디에 위치하는지?
    - 어떤 상호 종속성이 있는지(가령 변경 시 어떤 컴포넌트가 영향을 받는지)
    - 코드를 만들 때 어떤 가정을 세웠었는지
    - 기존 변경 히스토리
  - 올바른 사고방식을 갖자. **딱 코드 하나만 더**같은 사고방식은 지양하자. 나중에 버려지거나 다시 작성할 것이라 생각해서 코드를 밀어 놓지 말자. 그럴 리 없다.
  - 새로 추가하는 코드에 종속성을 늘리지 말자.
  - 어떤 코드를 유지 보수하든 선호하는 스타일이나 하우스 스타일이 아니더라도 그 소스 코드의 프로그래밍 스타일을 따르자.
  - 코드의 테스트 묶음을 실행해 무언가 고장 나지 않았는지 확인하자.
  - 진짜 원인을 파악해서 결함을 고치고 있는가? 결함을 일으킬 테스트 하네스를 작성하자. 제대로 수정했으면 비슷한 결함이 또 있는지 코드 기반을 살피자.
  - 잘못 변경했으면 재빨리 되돌리자.

  