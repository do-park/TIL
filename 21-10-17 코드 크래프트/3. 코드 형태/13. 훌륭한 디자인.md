# 13. 훌륭한 디자인

> 훌륭한 소프트웨어 디자인 만들기



- 소프트웨어 디자인을 구성하는 방식은 두 가지다. 하나는 **당연히** 어떤 결점도 없도록 아주 단순하게 구성하는 것이고, 나머지는 **당연한** 결점이 없도록 아주 복잡하게 구성하는 것이다. 첫 번째 방법이 훨씬 어렵다. [호어 81]



### 13.1 프로그래밍이 곧 디자인이다

- 어떤 프로그래머는 프로그래밍하며 디자인을 한다고 생각하지 않는데 코드를 작성할 때는 항상 명시적으로든 암묵적으로든 디자인을 하고 있는 것이다. [페이지 존스 96]
- **테스트 주도 디자인**(test-driven design) 방식은 코드 테스트를 코드보다 먼저 작성해 디자인 입증 도구로 활용한다.



### 13.2 무엇을 디자인할까?

- 소프트웨어 디자인 단계
  - 시스템 아키텍처
  - 모듈/컴포넌트
  - 클래스와 데이터 타입
  - 함수



### 13.3 왜 이렇게 야단법석일까?

- "제대로 할 시간은 없으면서 꼭 두 번 할 시간은 있더라."
- 견고하게 디자인한 코드
  - 작성하기 쉽다(전략이 명확하고 상호 작용이 분명하다).
  - 이해하기 쉽다.
  - 고치기 쉽다(문제 발생 지점을 찾을 수 있다)버그가 덜 생긴다(프로그램 오류가 아리송한 디자인 문제로 덮이지 않는다).
  - 버그에 탄력적이다(확장하고 수정하기 쉽게 디자인된다).



### 13.4 좋은 소프트웨어 디자인

- 최선의 디자인 방식
  - 반복한다
    - 조금씩 디자인하고 구현한 후 영향을 평가해 다음 디자인에 반영함으로써 예상치 못한 사고를 상당수 피한다.
    - 증분 구성(incremental construction)
  - 조심스럽다
    - 광범위하고 어설픈 조치보다는 작고 확실한 조치
  - 현실적이다
    - 가능한 방법론 중 최선을 취해 프로그래머의 직감에 맞긴다.
  - 정보에 밝다
    - 해결할 문제와 그 해결책이 만족시켜야 할 품질에 대해 명확히 알려면 모든 요구사항과 동기부여 원칙을 완벽히 이해해야 한다.
- 궁극적으로 **옳거나 그른** 디자인은 없다. 그저 **훌륭한** 디자인과 **형편없는** 디자인이 있을 뿐.

#### 1. 단순성

- 단순한 코드란 더 이상 작아질 수 없을 만큼 작은 코드
- 트레이드 오프
  - 확장성 대 단순성
  - 효율성 대 안전성
  - 기능 대 개발 수고
- 적은 양으로 많은 일을 하는 단순한 코드를 추구하자.
- 단순하게 만드는 일은 복잡하다. 코드 구조가 당연해 보인다고 디자인하기 쉬웠을 것이라 지레 짐작하지 말자.

#### 2. 간결성

- 간결성(elegance)은 디자인의 미적 측면을 나타내며 주로 단순성과 함께 설명된다. 코드가 장식적이거나 혼동을 줄 만큼 기발하거나 과도하게 복잡하지 않다는 뜻이다.
- 디자인이 훌륭한 코드
  - 제어 흐름이 적절하게 시스템을 통과한다.
  - 각 요소마다 특유의 가치 있는 무모가를 보태며 서로 보완한다.
  - 온갖 특수한 경우로 디자인이 벌집이 되지 않는다.
  - 비슷한 것끼리 연관시킨다.
  - 예상치 못한 사고가 도사리지 않는다.
  - 변경 지역성이 적다, 즉 코드 한 군데를 간단히 변경하는데 코드 여기 저기를 수정하지 않아도 된다.

#### 3. 모듈성

- 모듈성의 특징은 **응집력**(cohesion)과 **커플링**(coupling)으로 요약된다.
  - 강한 응집력
    - **응집력**(cohesion)은 기능이 서로 얼마나 관련되는지, 모듈 **내** 각 요소가 일률적으로 얼마나 잘 동작하는지를 나타내는 척도다.
    - 모듈마다 명확하게 정의된 역할이 있어야 하고 관련 없는 여러 기능이 섞이면 안 된다.
  - 약한 커플링
    - 커플링(coupling)은 모듈 간에 서로 얼마나 얽혀있느냐를 측정하는 상호 의존성 척도다.
    - 모든 모듈을 완벽하게 디커플링할 수는 없다. 그러면 절대 함께 어우러져 동작하지 않는다!
  - 커플링을 최소화한 내부적으로 응집된 모듈을 디자인하자. 문제 범위를 유효하게 나누도록 분할해야 한다.

#### 4. 훌륭한 인터페이스

- 모듈은 관심사를 분리하고 문제를 분할한다. 모듈마다 내부 구현을 가려주는 공개 퍼사드(facade)인 **인터페이스**(interface)가 정의된다. 이러한 연산 집합을 보통 **애플리케이션 프로그래밍 인터페이스**(Application Programming Interface, API)라 부른다.모듈 기능에 접근하는 유일한 경로이며 인터페이스의 품질이 적어도 외부에서 보기에는 그 모듈의 품질을 결정한다.
- 훌륭한 인터페이스를 만드는 단계
  1. 고객과 고객이 **원하는** 것을 찾아낸다.
  2. 제공자와 제공자가 **할 수 있는** 것을 찾아낸다.
  3. 필요한 인터페이스 유형을 추론한다.
  4. 연산의 특징을 결정한다.
- 인터페이스의 본질과 특징을 떠올려 볼 수 있는 핵심 원리
  - 분할
    - 디자인이 훌륭한 코드는 **역할**(role)과 **책임**(responsibility)을 명확하게 정의한다.
  - 추상화
    - 보는 이가 세부 사항은 선택적으로 무시하며 주요 결정에 집중할 수 있게 해준다.
  - 압축
    - 대규모 연산을 보다 간단한 연산으로 표현하는 인터페이스 기능
  - 대체성
    - 인터페이스 구현을 같은 조건에 부합하는 다른 구현으로 대체할 수 있다.

#### 5. 확장성

- 확장성을 고려해 디자인하되 너무 일반화 시키지 말자.

#### 6. 중복 피하기

#### 7. 이식성

- 코드 디자인에서 코드 이식성을 고려하자.

#### 8. 관용적

- 훌륭한 디자인은 디자인 방법론과 구현 언어의 관용구(idiom)에 맞는 최선의 모범 사례를 활용한다.

#### 9. 문서화



### 13.5 코드 디자인 방법

#### 1. 디자인 방법과 절차

- **직감적인**(seat of your pants) 디자인보다는 체계적인 방식이 낫다.
- **한 가지** 절차에 너무 얽매이면 그 절차의 아주 작은 세부 사항까지 만족시키느라 창조성이 억눌리기 쉬우니 항상 경계하자.
- 핵심 디자인 철학
  - 구조화 디자인
    - **기능 분할**(functional decomposition) 바탕
    - **하향식**(top-down)과 **상향식**(bottom-up) 방식
  - 객체 지향 디자인
    - 시스템 내 데이터에 초점

#### 2. 다지안 도구

- 표기법
  - **통합 모델링 언어**(Unified Modeling Language, UML)가 가장 유명하고 잘 규정된 표기법이다.
  - 사용 목적
    - 디자인을 재빨리 휘갈기고 화이트보드에 생각을 공유
    - 정해진 형식으로 디자인을 설명
- 디자인 패턴
- 순서도(flowchart)
- 의사 코드(pseudocode)
- 코드 내 디자인
- CASE 도구
  - **컴퓨터 지원 소프트웨어 공학**(Computer-Aided Software Engineering, CASE) 도구는 반복적인 일을 자동화하고 작업 흐름을 관리하며 디자인 절차 전체 혹은 일부를 지원한다.
  - **급속도 애플리케이션 개발**(Rapid Application Development, RAD) 도구

