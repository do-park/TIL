# 14. 소프트웨어 아키텍처

> 소프트웨어 디자인 기반 다지기



### 14.1 소프트웨어 아키텍처란?

- **고차원 디자인**(high-level design)

#### 1. 소프트웨어 청사진

- 거시적인 관점에서는 상세 구현을 감추고 소프트웨어의 핵심 내부 구조와 기본 동작 특성만 드러낸다.
  - 필수적인 소프트웨어 모듈을 찾는다.
  - 어떤 컴포넌트끼리 커뮤니케이션하는지 알아낸다.
  - 시스템 속 주요 인터페이스의 특징을 찾아 파악하고 다양한 하위 시스템의 올바른 **역할과 책임**을 명확히 한다.
- 아키텍처는 디자인과 향후 소프트웨어 시스템 성장에 가장 크게 영향을 미친다. 따라서 반드시 개발 초기에 올바르게 이해해야 한다.
- 코딩에 앞서미리 수행하는 아키텍처 디자인은 **문제 영역**(problem domain, 풀어야 할 현실 세계 문제)와 **해법 영역**(solution domain)을 매핑시킬 첫 기회다. 두 영역 사이에 목표와 행위 간 늘 단순한 1대 1 관계가 성립하지 않으므로 아키텍처를 통해 한 측면에서 나머지 측면을 생각해 볼 수 있다.
- 유념해야 할 사항
  - 어떤 프로젝트에서는, 특히 임베디드 디자인에서는 특정 하드웨어 컴포넌트를 명시해야 할 수 있다.
  - 분산 시스템에서는 장비와 프로세서 개수, 프로세서 간 작업 분할이 아키텍처적 이슈일 수 있다. 최소 및 평균 시스템 설정을 고려해야 한다.
  - 특정 알고리즘이나 데이터 구조가 전체 디자인의 기반이면(가능성은 희박하지만) 아키텍처에서 설명해야 할 수 있다.
- 아키텍처 단계에서 정해지는 정보가 많을수록 향후 디자인이나 구현 단계에서 기동력이 떨어진다.

#### 2. 관점

- 개념적 관점(conceptual view)
- 구현 관점(implementation view)
- 프로세스 관점(process view)
- 배치 관점(deployment view)
- 이 중 아키텍처 초기 단계에서 주 결과물은 **개념적 관점**이다.

#### 3. 언제 어디에서 할까?

- **아키텍처 명세**(architecture specification)
  - 시스템 구조를 설명하고 시스템이 어떻게 요구사항을 충족하는지 보이며 성능 요구사항에 도달하기 위한 전략과 고장 허용(fault tolerance)을 충분히 달성하는 방법 같은 주요 이슈를 포함한다.
  - 시스템 아키텍처는 프로그래머와 관리자, 설치 프로그램, 운영자 등 (심지어 고객까지) 참여한 누구든 볼 수 있는 문서로 공개적으로 보관하자.
- 아키텍처는 요구사항 수립 후 **첫 번째** 개발 단계
- 이후 상세 디자인 과정에서 시스템 아키텍처가 바뀌기도 한다. 이는 자연스럽고 정상적이다.

#### 4. 어디에 쓰일까?

- 검증
- 커뮤니케이션
- 선택

#### 5. 컴포넌트와 연결로 만들자

- 아키텍처는 **컴포넌트**(component)와 **연결**(connection)을 묘사한다.

1. 컴포넌트
   - 아키텍처 단에서는 컴포넌트 구현 이슈는 깊이 고려하지 않고 노출된 기능과 외부로 보여질 주요 인터페이스만 설명한다. 컴포넌트의 **가시성**(visibility), 즉 컴포넌트에서 무엇을 볼 수 있고 없는지, 무엇이 그 컴포넌트를 볼 수 있고 없는지를 정의한다.
   - 아키텍처 스타일에 따라 가시성 규칙이 다르다.
2. 연결
   - 아키텍처는 컴포넌트 간 연결(connection)을 찾고 그 특징을 설명한다.
   - 연결이란 간단한 함수 호출이나 파이프를 통한 데이터 흐름이다.
   - **동기식**(요청을 모두 처리할 때까지 호출자를 블록함) 또는 **비동기식**(제어를 즉시 호출자에 넘기고 회신할 응답을 준비함) 연결이 있다. 연결에 따라 시스템을 둘러싼 제어 흐름이 달라지므로 매우 중요하다.



### 14.2 훌륭한 아키텍처란?

- **단순성**(simplicity)
- 소수의 정선된 모듈과 합리적인 커뮤니케이션 통로를 지향
- 약한 커플링과 강한 응집력을 목표로 한다.
- 아키텍처는 주요 시스템 컴포넌트와 컴포넌트 간 상호 작용 방법을 보여준다. 컴포넌트의 동작 방식은 정의하지 않는다.
- 훌륭한 아키텍처는 조직성과 확장성이 높고 수정할 수 있다. 그렇다고 지나치게 일반적이지 않다.



### 14.3 아키텍처 스타일

- 주요 아키텍처 스타일을 알아두고 장단점을 파악하자. 기존 소프트웨어를 거부감없이 다루고 적절한 시스템 디자인을 수행하기 좋다.

#### 1. 아키텍처 생략

#### 2. 계층형 아키텍처

- 개념적으로 가장 흔히 쓰이는 아키텍처 스타일
- 한눈에 이해할 수 있는 아주 단순한 모델이라 요지를 금세 파악할 수 있다.

#### 3. 파이프와 필터 아키텍처

- 시스템을 통과하는 데이터의 논리적 흐름을 모델링하는 아키텍처
- 체인은 데이터 생성기(사용자 인터페이스 혹은 하드웨어에서 입력을 가져오는 로직)로 시작한다. 마지막은 데이터 수신기(컴퓨터 화면이나 로그 파일)다.

#### 4. 클라이언트/서버 아키텍처

- 전형적인 네트워크 기반 아키텍처
- 기능을 **클라이언트**와 **서버**라는 두 핵심 요소로 분리한다.
- **2계층**(two-tier) 아키텍처
  - 계층(**중간 계층**(middle tier))을 하나 더 넣어 2계층 디자인을 확장하기도 한다. 이를 **3계층**(three-tier) 아키텍처라 부른다.

#### 5. 컴포넌트 기반 아키텍처

- 단일 구조 형식에서 벗어나 제어를 분산시켜 별도의 여러 협업 **컴포넌트**로 분리한다. 객체 지향 방식을 따르지만 꼭 객체 지향 언어로 구현하지 않아도 된다.
- 플러그 앤 플레이 방식

#### 6. 프레임워크

- 프레임워크는 확장 가능한 코드 라이브러리(주로 협력 클래스 집합)로서 특정 문제 도메인에 적합한 재사용 가능한 디자인을 만들어 낸다.
- 프레임워크 작업의 대부분은 사용자 대신 알아서 처리되고 나머지는 **공백 기입**(fill-in-the-blanks) 방식을 따른다. 프레임워크가 다르면 아키텍처 모델도 달라서 어떤 프레임워크를 사용하면 그 프레임워크에 특화된 스타일을 따르게 된다.

