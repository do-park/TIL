# 12. 다형성

- polymorphism

- 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법

- 분류

  - 다형성(polymorphism)

    - 유니버셜(universal)

      - 매개변수(parametic): 제네릭 프로그래밍, 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식
      - 포함(inclusion): 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력, 서버타입(subtype) 다형성
        - 포함 다형성을 구현하는 가장 일반적인 방법은 상속: 클래스들을 계층으로 쌓아 올린 후 상황에 따라 적절한 메서드를 선택할 수 있는 메커니즘을 제공하기 때문

    - 임시(ad hoc)

      - 오버로딩(overloading): 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
      - 강제(coercion): 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식

      - 일반적으로 오버로딩 다형성과 강제 다형성을 함께 사용하면 모호해질 수 있는데 실제로 어떤 메서드가 호출될지를 판단하기가 어려워지기 때문



### 상속

- 상속의 목적: 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축
- 상속의 개념
  - **업캐스팅**: 부모 클래스타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다. 이를 업캐스팅이라고 부른다.
  - **동적 바인딩**: 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다. 이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문에 가능하다. 이를 동적바인딩이라고 부른다.
  - **동적 메서드 탐색**
  - **self 참조**
    - 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 개겣를 가리키도록 설정한다. 동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이뤄지며 메서드의 탐색이 종료되는 순간 self 참조는 자동으로 소멸된다.
    - 동적 메서드 탐색의 두 가지 원리
      1. 자동적인 메시지 위임
      2. 메서드를 탐색하기 위해 동적인 문맥 사용
  - **super 참조**: 지금 이 클래스의 부모 클래스에서부터 메서드 탐색을 시작해 부모 클래스에서 원하는 메서드를 찾지 못한다면 더 상위의 부모 클래스로 이동하면서 메서드가 존재하는지 검사한다.
- 프로토타입 기반의 객체지향 언어는 객체 사이의 자동적인 메시지 위임을 통해 상속을 구현한다.
- 클래스 기반의 객체지향 언어를 사용하더라도 클래스라는 제약을 벗어나기 위해 위임 메커니즘을 사용할 수 있다.
