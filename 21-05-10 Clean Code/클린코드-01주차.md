# 1. 깨끗한 코드

- 깨끗한 코드란?

  - 비야네 스트롭스트룹: 나는 **우아하고 효율적인** 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 오류는 명백한 전략에 의해 철저히 처리한다. 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. **깨끗한 코드는 한 가지를 제대로 한다.**
  - 그래디 부치: 깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 **잘 쓴 문장처럼 읽힌다. **깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다. 오히려 **명쾌한 추상화와 단순한 제어문**으로 가득하다.  
  - 데이브 토마스: 깨끗한 코드는 **작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.** 단위 테스트 케이스와 인수 테스트 케이스가 존재한다. 깨끗한 코드에는 **의미 있는 이름**이 붙는다. 특정 목적을 달성하는 방법은 (여러 가지가 아니라) 하나만 제공한다. 의존성은 최소이며 각 의존성을 명확히 정의한다. API는 명확하며 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.
  - 마이클 페더스: 깨끗한 코드의 특징은 많지만 그 중에서도 모두를 아우르는 특징이 하나 있다. 깨끗한 코드는 언제나 누군가 **주의깊게 짰다**는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했으므로 고칠 궁리를 하다보면 언제나 제자리로 돌아온다. 그리고는 누군가가 남겨준 코드, 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다.
  - 론 제프리스
    - 모든 테스트를 통과한다.
    - 중복이 없다.
    - 시스템 내 모든 설계 아이디어를 표현한다.
    - 클래스, 메서드, 함수 등을 최대한 줄인다.
  - 워드 커닝햄: 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. **코드가 그 문제를 풀기 위한 언어처럼 보인다면** 아름다운 코드라 불러도 되겠다.

  

- 보이스카우트 규칙: 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라



# 2. 의미 있는 이름

1. 의도를 분명히 밝혀라
   - 변수(혹은 함수나 클래스)의 존재 이유는? 수행 기능은? 사용 방법은?
   - 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 뜻
2. 그릇된 정보를 피해라
   - 그릇된 단어는 코드 의미를 흐린다.
   - 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안 된다.
3. 의미 있게 구분하라
   - 불용어(분석에 큰 도움이 되지 않는 단어)는 제거하라.
4. 발음하기 쉬운 이름을 사용하라
   - 긴 이름이 짧은 이름보다 좋다.
   - 검색하기 좋은 이름이 상수보다 좋다.
     - 간단한 메서드에서 로컬 변수만 한 문자를 사용
   - **이름 길이는 범위 크기에 비례해야 한다.**
5. 인코딩을 피하라
   - 인터페이스 클래스 이름과 구현 클래스 이름 중 하나를 인코딩해야 한다면 구현 클래스 이름
6. 자신의 기억력을 자랑하지 마라
   - 명료함이 최고
7. 클래스 이름
   - 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.
   - Manager, Processor, Data, Info 등과 같은 단어는 피하고, 동사는 사용하지 않는다.
8. 메서드 이름
   - 동사나 동사구가 적합하다.
   - 접근자: get, 변경자: set, 조건자: is
   - 생성자를 중복정의(overload)할 때는 정적 팩토리 메서드를 사용한다.
   - 생성자 사용을 제한하려면 해당 생성자를 private로 선언한다.
9. 기발한 이름은 피하라
10. 한 개념에 한 단어를 사용하라
11. 말장난을 하지 마라
    - 한 단어를 두 가지 목적으로 사용하지 마라
    - 의도를 밝힐 책임이 저자에게 있다.
12. 해법 영역에서 가져온 이름을 사용하라
    - 기술 개념에는 기술 이름이 가장 적합한 선택이다.
13. 문제 영역에서 가져온 이름을 사용하라
    - 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야 한다.
14. 의미 있는 맥락을 추가하라
15. 불필요한 맥락을 없애라
    - 일반적으로는 짧은 이름이 긴 이름보다 좋다. 단, 의미가 분명한 경우에 한해서다. 이름에 불필요한 맥락을 추가하지 않도록 주의한다.



# 3. 함수

> 의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까? 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?



1. 작게 만들어라

   - 가로 150줄을 넘어서는 안 된다.
   - 100줄을 넘어서는 안 된다. 20줄도 길다.

   1. 블록과 들여쓰기
      - if / else / while 문 등에 들어가는 블록은 한 줄이어야 한다. → 중첩 구조가 생길만큼 함수가 커져서는 안 된다.
      - 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

2. 한 가지만 해라

   - **함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.**
   - 우리가 함수를 만드는 이유는 큰 개념을 (함수 이름을) 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서
   - 함수가 한 가지를 하는지 판단하는 방법
     - 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
     - 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있따면 그 함수는 여러 작업을 하는 셈이다.

3. 함수 당 추상화 수준은 하나로

   - 함수 내 모든 문장의 추상화 수준이 동일해야 한다.

4. 내려가기 규칙: 위에서 아래로 코드 읽기

   - 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

5. Switch문

   - 다형성(polymorphism)을 이용해 각 switch문을 저차원 클래스에 숨기고 절대로 반복하지 않을 수 있다.

6. 서술적인 이름을 사용하라

   - 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
   - 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
   - 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.
   - 이름을 붙일 때는 일관성이 있어야 한다.

7. 함수 인수

   - 함수에서 이상적인 인수 개수는 0개
   - 3개는 가능한 피하는 편이 좋고, 4개 이상은 특별한 이유가 있어도 사용하면 안 된다.
   - 인수 객체: 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 수 있다.

8. 부수 효과를 일으키지 마라

   - 시간적인 결합이나 순서 종속성을 초래한다.

9. 오류 코드보다 예외를 사용하라

   - 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.
   - try/catch 블록은 별도 함수로 뽑아내는 편이 좋다.
   - 오류 처리도 한 가지 작업이다.

10. 반복하지 마라

11. 구조적 프로그래밍

    - 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다. 즉, 함수는 return 문이 하나여야 한다.
    - 함수가 작다면 이 규칙은 별 이익을 제공하지 못한다.



> 진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다. 작성하는 함수가 분명하고 정확한 언어로 깔끔하게 같이 맞아떨어져야 이야기를 풀어가기가 쉬워진다.