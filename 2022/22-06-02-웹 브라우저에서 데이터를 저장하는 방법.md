# 웹 브라우저에서 데이터를 저장하는 방법

- 웹스토리지 (로컬스토리지, 세션스토리지)

- 쿠키 또는 세션을 사용하는 이유
  - HTTP 프로토콜의 약점 보완
    - connectionless
      - 비연결성, 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어 버리는 성질
      - HTTP 1.1 버전에서 연결을 유지하고, 재활용하는 기능이 추가 (keep-alive)
    - stateless
      - 무상태, 통신이 끝나면 상태를 유지하지 않는 특성

### 쿠키
> 브라우저에 저장되는 정보
- 클라이언트 측(브라우저)에서 관리하는 작은 텍스트 조각
- 브라우저는 사용자의 컴퓨터에 설치된 소프트웨어이므로 쿠키는 사용자가 갖고 있는 정보
- 사용자는 브라우저의 설정 화면이나 개발자 도구에서 쿠키를 확인하고 수정, 삭제할 수 있다.
- 쿠키는 당사자뿐 아니라 제3자도 조회할 수 있기 때문에 개인 정보를 담은 내용이나 보안상 민감한 정보의 저장에는 부적합.
  - 남에게 탈취되거나 사용자에 의해 조작되어도 크게 문제되지 않을 정보를 브라우저에 저장해 웹사이트 이용을 편리하게 함.
    - e.g. 검색 내역, 장바구니, 팝업 설정(7일 동안 다시 보지 않기), 다크 모드 설정 여부
- 구성 요소
  - 이름: 각각의 쿠키를 구별하는 데 사용되는 이름
  - 값: 쿠키가 갖고 있는 값
  - 유효 시간: 쿠키의 유지 시간
  - 도메인: 쿠키를 전송할 도메인
  - 경로: 쿠키를 전송할 요청 경로
- 동작 방식
  1. 클라이언트가 페이지를 요청
  2. 서버에서 쿠키를 생성
  3. HTTP 헤더에 쿠키를 포함시켜 응답
  4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관
  5. 동일 사이트 재방문 시 클라이언트의 PC에 해당 쿠키가 존재하면 요청 시 HTTP 헤더에 쿠키를 함께 보내서 요청
  6. 서버에서 쿠키를 읽어 이전 상태 정보 변경이 필요한 경우, 쿠키를 업데이트 해 변경된 쿠키를 HTTP 헤더에 포함해 응답
- 특징
  - 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.
  - 클라이언트에 총 300개의 쿠키를 저장할 수 있다.
  - 하나의 도메인 당 20개의 쿠키를 가질 수 있다.
  - 하나의 쿠키는 4KB까지 저장 가능하다.
=== === ===
- HTTP 쿠키(웹 쿠키, 브라우저 쿠키)는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다.
- 브라우저는 그 데이터 조각들을 저장해 놓았다가, 동일한 서버에 재 요청 시 저장된 데이터를 함께 전송한다.
- 쿠키는 주로 세 가지 목적을 위해 사용된다.
  1. 세션 관리(Session management)
    : 서버에 저장해야 할 로그인, 장바구니, 게임 스코어 등의 정보 관리
  2. 개인화(Personalization)
    : 사용자 선호, 테마 등의 세팅
  3. 트래킹(Tracking)
    : 사용자 행동을 기록하고 분석하는 용도
- 모든 요청마다 쿠키가 함께 전송되기 때문에, 쿠키에 많은 데이터를 저장하게 되면 성능이 떨어지는 원인이 될 수 있다.
  - 정보를 클라이언트 측에 저장하기 위해서 Web Storage API (localStorage, sessionStorage)와 IndexedDB를 사용할 수 있다.
- 라이프타임
  - 세션 쿠키: 현재 세션이 끝날 때 삭제
  - 영속적인 쿠키: Expires 속성에 명시된 날짜 또는 Max-Age 속성에 명시된 기간 이후에 삭제
  

### 세션
> 서버가 나를 알아보는 방법
- 서버에서 관리
- 일정 시간동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술
  - 일정 시간: 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점
  - 즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 이를 세션이라 한다.
- 서버에게 보내는 요청은 이전 행동들과 연결되어 있지 않다.
  - 서버는 아이디와 비밀번호를 입력해 로그인에 성공한 사용자와 로그인한 다음 마이페이지 버튼을 누른 사용자가 동일 인물임을 알 수 없다.
  - 사용자가 사이트에 로그인한 상태라는 점을 서버에 인증하지 못하면 클릭할 때마다 반복해서 아이디와 비밀번호를 서버에 제공해야 한다.
  - 이러한 번거로움을 해결하기 위해 사용하는 것이 세션
- 사용자가 사이트에 로그인하면 유효기간이 끝날 때까지 더 이상 아이디와 비밀번호를 입력하지 않아도 되도록 사용자가 이미 서버로부터 인증받았음을 증명해주는 증서
- 사용자가 로그인에 성공하면 서버는 세션 아이디라는 데이터를 만들어 사용자에게 전달하고, 메모리에 아이디 사본을 어떤 사용자의 것인지 기록
- 사용자는 서버로부터 받은 세션 아이디를 쿠키로 저장한 다음 앞으로의 모든 요청에 함께 전달하고, 서버는 사용자가 누구인지 확인한 뒤 요청을 처리
- 로그인 여부 등 사용자와 서버의 관계가 기억되어 보존되고 있는 상태를 뜻한다.
- 윈도우나 브라우저 탭을 닫을 때 제거된다. 따라서 창이 닫기기 전 세션이 만료되기 전까지만 유지할 정보를 저장하는데 활용할 수 있다.
- 동작 방식
  1. 클라이언트가 서버 접속 시 세션 ID를 발급
  2. 클라이언트는 쿠키를 사용해 세션 ID 저장
  3. 클라이언트가 서버에 다시 접속 시 이 쿠키를 이용해 세션 ID값을 서버에 전달
- 세션의 특징
  - 각 클라이언트에게 고유 ID를 부여
  - 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
  - 보안 면에서 쿠키보다 우수
  - 사용자가 많아질수록 서버 메모리를 많이 차지
  - 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장

- 쿠키와 세션의 차이
  - 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷합니다. 그 이유는 세션도 결국 쿠키를 사용하기 때문입니다. 
  - 가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다.
  - 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다.
  - 보안, 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋습니다. 라이프 사이클, 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있습니다.
  - 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됩니다. 예를 들어, 크롬에서 다른 탭을 사용해도 세션을 공유됩니다. 다른 브라우저를 사용하게 되면 다른 세션을 사용할 수 있습니다.
  - 속도, 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 가집니다.
  - 쿠키는 text 형식으로 데이터를 저장하고, 세션은 Object 형식으로 데이터를 저장한다.

### 토큰
> 세션과는 또 다른 로그인 유지 방식
- HTTP의 stateless, connectionless 특징 때문에 사용자 인증을 유지할 수 있는 기능이 필요
  - 쿠키는 브라우저에 사용자 정보가 기록되기 때문에 위변조의 가능성이 높아 보안에 취약
  - 세션은 서버의 메모리를 차지하기 때문에 동시접속자가 많아질 경우 서버 과부하의 원인이 되고, 세션 정보가 중간에 탈취당할 수 있다.
- 세션의 단점
  - 서버에 동시 접속하는 사용자가 많아지면 메모리 공간이 부족해져 서버에 부하가 걸려 문제가 발생할 수 있다.
    - 메모리는 데이터를 빠르게 확인할 수 있는 대신 공간이 한정적이다.
- 보호할 데이터를 토큰으로 치환해 원본 데이터 대신 토큰을 사용한다.
- 로그인한 유저에게 세션 아이디 대신 토큰을 발급해 상태를 저장하지 않고도 사용자의 로그인 여부를 파악할 수 있도록 한다.
- 토큰을 받아간 사용자가 이를 쿠키로 저장해두고 필요할 때마다 제시하면 서버는 자기가 발급한 토큰임을 알아보고 사용자의 요청을 허가한다.
  - 로그인한 사용자의 세션 아이디를 메모리에 저장할 필요가 없어 서버 부하가 줄어든다.
  
### 캐시
> 전송량은 줄이고 속도는 높이고
- 서버 부하를 방지하기 위해 웹 문서, 이미지 등의 자원을 임시 사용자 웹 브라우저에 저장하는 기술로, 불필요한 데이터 요청 및 전송을 줄여 페이지 로딩 속도를 개선할 수 있다.
- 한 번 전송받은 데이터를 저장했다가 다시 사용할 때 꺼내 쓴다면 반복적으로 사용하는 콘텐츠를 빠르게 이용할 수 있고 데이터 사용량도 줄일 수 있다.
- 사용자가 인터넷에서 받아온 데이터는 브라우저에 캐시 형태로 저장된다.
- 쿠키와 같이 캐시도 각 브라우저의 설정 화면에서 비울 수 있다.
- 쿠키와 캐시의 차이
  - 쿠키와 캐시 모두 정보를 저장해 재활용하는 기술
  - 쿠키는 사용자의 수고를 덜어주는 것이 목적
  - 캐시는 데이터의 전송량을 줄이고 서비스 이용 속도를 높이는 것이 목적
- 쿠키/세션은 캐시와 엄연히 다르다
  - 캐시는 이미지나 css, js파일 등을 브라우저나 서버 앞 단에 저장해놓고 사용하는 것입니다.
  - 한번 캐시에 저장되면 브라우저를 참고하기 때문에 서버에서 변경이 되어도 사용자는 변경되지 않게 보일 수 있는데 이런 부분을 캐시를 지워주거나 서버에서 클라이언트로 응답을 보낼 때 header에 캐시 만료시간을 명시하는 방법등을 이용할 수 있습니다.
  - 보통 쿠키와 세션의 차이를 물어볼 때 저장위치와 보안에 대해서는 잘 말하는데 사실 중요한 것은 라이프사이클을 얘기하는 것입니다.
#### CDN
- Content Delivery Network, 콘텐츠 전송 네트워크
- 여러 지역에 설치된 캐시 서버들을 사용해 본 서버로 들어오는 요청들을 분산 처리하는 서비스
- 캐시를 사용하지 않고 매번 정보가 전송되는 것은 사용자뿐 아니라 서버에도 부담
- 지리적으로 분산된 여러 개의 서버를 이용해 웹 콘텐츠를 사용자와 가까운 서버에서 전송함으로써 전송 속도를 높인다.
- 서버가 데이터를 전 세계 각지에 세워진 캐시 저장 및 전달용 컴퓨터(cdn 업체 소유)로 보내면 사용자는 본인에게서 가장 가까운 캐시 서버로 요청을 보내고 데이터를 받아 온다.


  
### 웹 스토리지
- 최신 스펙: https://html.spec.whatwg.org/multipage/
- 브라우저의 저장소
- 클라이언트의 데이터를 저장할 수 있도록 HTML5부터 새롭게 지원하는 저장소로, key, value 형태로 데이터를 저장한다.
- 서버에 전송되지 않아 서버에 부담이 가지 않는다. (명시적으로만 전송 가능)
- 도메인 단위로 접근이 제한되는 특성이 있어 다른 도메인에서 요청해도 값을 꺼내 쓸 수 없다. (CSRF 안전)
- 종류: 로컬 스토리지와 세션 스토리지
  - window객체의 프로퍼티로서 존재하며, 같은 스토리지 객체를 상속하기 때문에 동일한 메서드를 가진다.
  - 영구저장소(LocalStorage)와 임시저장소(SessionStorage)를 따로 두어 데이터의 지속성을 구분할 수 있어 응용 환경에 맞는 선택이 가능하다.
    - LocalStorage는 브라우저를 닫았다 열어도 계속 유지된다.
    - SessionStorage는 브라우저를 닫으면 삭제된다.
- 웹 스토리지는 클라이언트 사이드이므로 쉽게 해킹당할 수 있다.
- 쿠키의 단점 극복
  - 4KB의 데이터 저장 제한
  - HTTP Request에 암호화 되지 않은 상태로 사용하기 때문에 보안에 취약
  - 쿠키는 모든 HTTP Request에 포함되어 있어 웹서비스 성능에 영향을 줄 수 있다.
- 쿠키와 비교
  - 쿠키는 매번 서버로 전송된다.
    - 웹 사이트에서 쿠키를 설정하면 이후 모든 웹 요청은 쿠키 정보를 포함해 서버로 전송된다. Web Storage는 저장된 데이터가 클라이언트에 존재할 뿐 서버로 전송되지는 않는다. 이는 네트워크 트래픽 비용을 줄여준다.
  - Web Storage는 단순 문자열을 넘어(스크립트) 객체정보를 저장할 수 있다.
    - 문자열 기반 데이터 외에 체계적으로 구조화된 객체를 저장할 수 있다. 이는 개발 편의성을 제공해주는 장점이다. (단, 브라우저의 지원 여부를 확인해봐야 한다.)
  - Web Storage는 용량의 제한이 없다.
    - 쿠키는 개수와 용량에 제한이 있다. 클라이언트에 최대 300개의 쿠키를 저장할 수 있으며, 하나의 사이트(도메인)에서는 최대 20개를 저장할 수 있다. 또한, 하나의 쿠키값은 최대 4KB로 제한되어 있다.
    - Web Storage에는 제한이 없다. 쿠키도 하위키를 이용하면 이러한 제한을 이룹 해소할 수는 있으나, 대용량으로 쿠키를 저장할 일은 없다.
  - Web Storage는 영구 데이터 저장이 가능하다.
    - 쿠키는 만료일자를 지정하게 되어있어 언젠가 제거된다. 만약 만료일자를 지정하지 않으면 세션 쿠키가 된다. 영구 쿠키를 원한다면 만료일자를 굉장히 멀게 설정해 해결할 수 있다.
        - 세션 쿠키(session cookie): 활성 웹 브라우저 세션이 있는 기간 동안 저장된다. 일반적으로 웹 브라우저를 닫을 때 삭제된다.
        - 영구 쿠키(persistent cookie): 각 쿠키에 지정된 기간동안 또는 장치에서 쿠키를 수동으로 삭제할 때까지 장치에 남아있는다.
    - Web Storage는 만료기간의 설정이 없다. 즉, 한 번 저장된 데이터는 영구적으로 존재하게 된다.
=== === ===
- Web Storage API는 브라우저에서 키/값 쌍을 쿠키보다 훨씬 직관적으로 저장할 수 있는 방법을 제공한다.
- 개념과 사용법
  - sessionStorage는 각각의 origin에 대해 독립적인 저장 공간을 페이지 세션이 유지되는 동안(브라우저가 열려있는 동안) 제공
    - 세션에 한정해, 즉 브라우저 또는 탭이 닫힐 때까지만 데이터를 저장
    - 데이터를 절대 서버로 전송하지 않는다
    - 저장 공간이 쿠키보다 크다 (최대 5MB)
  - localStorage는 브라우저를 닫았다 열어도 데이터가 남아있다.
    - 유효기간 없이 데이터를 저장하고, JavaScript를 사용하거나 브라우저 캐시 또는 로컬 저장 데이터를 지워야만 사라진다.
- 사생활 보호 모드 / 시크릿 모드
  - 대부분의 브라우저가 Web Storage api에 접근 가능하지만, 브라우저를 닫으면 저장한 데이터를 제거한다.
  - Safari의 경우 Web Storage api는 존재하지만 최대 용량을 0바이트로 할당해 어떠한 데이터도 입력할 수 없도록 한다.

### LocalStorage
- window.localStorage 객체
- 세션과 비슷한 역할을 하지만 라이프사이클이 다르다. 세션은 브라우저를 종료하거나, 브라우저가 서로 다르거나, 도메인마다 별도의 세션을 가져서 데이터의 유효성이 있지만 로컬 스토리지는 직접 지우지 않는다면 별도의 만료기간이 없다는 큰 차이가 있다. 때문에 보안이 필요한 데이터는 로컬스토리지를 사용하지 않아야 한다.
- 쿠키와 달리 모든 http 요청에서 데이터를 주고받을 필요가 없다.
  - 클라이언트-서버 간 전체 트래픽과 낭비되는 대역폭의 양을 줄일 수 있다.
- 최대 5MB의 정보를 저장할 수 있다. (쿠키: 4KB)
- 만료 조건
  - Javascript 코드를 통해 삭제하지 않으면 데이터는 자동으로 삭제되지 않는다.
  - 오랜 시간동안 저장해야 하는 큰 데이터에 유리
- 문자열 뿐 아니라 javascript의 primitives object도 저장할 수 있다.
  - javascript primitive data type
    - 원시 값, 원시 자료형
    - 객체가 아니면서 메서드도 가지지 않는 데이터
      - string, number, bigint, boolean, undefined, symbol, null
- 로컬스토리지에 저장된 데이터의 위협 수준이 매우 낮아야 한다.
- 로컬 스토리지의 데이터는 사용자가 지우지 않는 이상 계속 브라우저에 남아 있기 때문에 데이터의 영구성이 보장된다. 따라서 지속적으로 필요한 데이터를 저장할 때 활용할 수 있다.
- 브라우저를 종료해도 유지되는 데이터로, 명시적으로 지우지 않는 한 영구적으로 저장된다.
- 도메인별로 생성되며, 다른 도메인의 로컬 스토리지에는 접근이 불가능하다.
- 서로 다른 브라우저 탭이라도 동일한 도메인이라면 동일한 로컬 스토리지를 사용한다.
- 지속적으로 필요한 정보를 저장하기에 좋다. (자동 로그인)
- 저장한 데이터를 명시적으로 지우지 않는 이상 영구적으로 보관이 가능하다.
- 도메인마다 별도로 LocalStorage가 생성되므로, 도메인만 같으면 전역적으로 공유가 가능하다.

### SessionStorage
- window.SessionStorage 객체
- 세션 쿠키와 달리, 탭/윈도우 단위로 세션 스토리지가 생성된다.
- 즉 window 객체와 동일한 유효 범위 및 생존 기간을 가지며, 탭/윈도우를 닫을 시 데이터가 삭제된다.
- 또한 동일한 탭/윈도우라도 다른 도메인이라면 또 다른 세션 스토리지가 생성된다.
- 서로 다른 세션 스토리지는 서로 영향을 주지 않으며 독립적으로 동작한다.
- 윈도우 복제로 생성된 경우, 혹은 스크립트로 새 창을 연 경우 세션 스토리지가 복제되어 생성된다.
- 잠시 동안 필요한 정보를 저장하기에 좋다. (입력 폼 저장, 일회성 로그인)
- 데이터의 지속성과 액세스 범위에 특수한 제한이 존재한다. 
  - web storage의 기본 보안처럼 도메인별로 별도로 생성된다. 같은 사이트의 도메인이라도 브라우저가 다르면 서로 다른 영역이 된다. (브라우저 컨텍스트가 다르기 때문)
  - 브라우저 컨텍스트
    - Document를 표시하는 환경, 즉 브라우저가 불러온 웹 페이지
  
### IndextedDB
- 색인이 포함된 JSON 객체가 모여 있는 트랜잭셔널 로컬 데이터베이스를 위해 W3C가 권고한 웹 브라우저 표준 인터페이스의 하나
- 웹 사이트는 데이터베이스에서 영속적인 데이터를 모아서 저장할 수 있다.
- 브라우저에서 제공하는 데이터베이스
- 웹 스토리지에 저장하기에는 많은 양의 데이터를 저장할 때 사용
- 특징
  - IndextedDB는 Transaction Database를 사용해 key-value로 데이터를 관리하며, B-tree 데이터 구조를 가진다.
  - Transaction model을 따르며, 모든 변경은 Transaction 안에서 일어난다.
  - 만약 Transaction 내에서 문제가 생긴다면, 모든 변경사항을 폐기하고 이전 상태로 돌아간다.
  - same-origin policy를 따른다. (https://developer.mozilla.org/ko/docs/Web/Security/Same-origin_policy)
  - 데이터는 영속적으로 유지되지만, 특정 상황에 따라 삭제될 수 있다.
- 구성 요소
  - Database
    - Version 과 N개의 Object Store 를 가진다.
    - 브라우저는 여러 Database 를 가질 수 있다.
    - indexedDB.open 로 열수 있다.
  - Object Store
    - 데이터를 담는 공간이다.
    - N개의 레코드(Key-Value) 를 가질 수 있다.
    - Value 의 형태는 다른 Value 들과 일치하지 않아도 된다.
    - 레코드는 Key 에 따라 오름차순으로 정렬된다.
    - Object Store 이름은 고유 해야한다.
    - IDBRequest.createObjectStore 로 만들 수 있다.
    - Object store 에 key path 를 설정하면, in-line keys (내부 key) 를 사용하며, 그 외에는 out-of-line keys (외부 key) 를 사용한다.
  - Transaction
    - IndexedDB API 작업은 transaction contect 내에서 발생한다.
    - transaction contect 내에서 작업이 실패하면, 해당 작업 상태는 적용되지 않고, 이전 상태로 돌아간다.
    - 만약 transaction 외부에서 IndexedDB API 를 호출하면, 에러가 발행한다.
    - IDBRequest.transaction 로 만들수 있다.
    - transaction 은 readwrite, readonly, versionchange 상태를 가질 수 있다.
  - Curser
    - Curser 는 Database 의 여러 레코드 (Object Store) 를 순회하거나 반복 할 수 있다.
    - ObjectStore.openCursor 에 key 혹은 key range (IDBKeyRange) 쿼리를 전달하고, IDBCursorWithValue 를 전달받아 continue 로 반복 조회 한다.
  - Index
    - Index 는 Object Store 를 참조하는 Object Store 이다.
    - IDBObjectStore.createIndex 로 만들 수 있다.
    - Object Store 에 Index 와 관련된 레코드가 업데이트 되면 자동으로 업데이트 된다.
- IndextedDB vs. Storage
  - IndextedDB가 더 많은 데이터를 저장하고, index를 활용해 빠르게 검색할 수 있다.
  - Storage 인 Local Storage 와 Session Storage 는 최대 10MB 만 저장이 가능하며, 오직 String 형태만 저장이 가능하다. IndexedDB 는 javascript 가 이해하는 어떠한 값이라도 모두 저장할 수 있다.
  - IndexedDB 는 용량 제한은 특별히 없으나, HDD 저장소 상태 나 브라우저의 상태에 따라서 달라질 수 있다.
  - 시크릿 모드에서 IndexedDB, Storage 를 사용하면, 값은 저장되지 않고 브라우저 종료시 사라진다.
  - 작은 규모의 데이터는 Storage 를 사용하는것이 좋지만, 큰 데이터는 IndexedDB 를 사용하는 것이 여러모로 유리하다.
=== === ===
- IndexedDB는 파일이나 블롭 등 많은 양의 구조화된 데이터를 클라이언트에 저장하기 위한 로우 레벨 API
- 인덱스를 사용해 데이터를 고성능으로 탐색할 수 있다.
- Web Storage는 적은 양의 데이터를 저장하는데 유용하지만 많은 양의 구조화된 데이터에는 적합하지 않은데, 이런 상황에서 IndexedDB를 사용할 수 있다.
- 핵심 개념과 사용
  - 트랜잭션을 사용하는 JavaScript 기반의 객체지향 데이터베이스
  - 인덱스 키를 이용해 저장하고 검색할 수 있으며, 구조화된 복사 알고리즘(https://developer.mozilla.org/ko/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)을 지원하는 객체라면 모두 저장할 수 있다.
  - 사용하려면 데이터베이스 스키마를 지정하고, 데이터베이스와 통신을 연 후에, 일련의 트랜잭션을 통해 데이터를 가져오거나 업데이트해야 한다.
- IndexedDB 작업은 모두 비동기로 이루어진다.
- IndexedDB 용량 제한은 특별히 없으나, 브라우저에 따라 저장 용량 한도와 용량이 한계에 도달했을 때 어떤 데이터를 제거할 것인지 프로세스는 다를 수 있다. (https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria)
- 보다 단순한 api를 선호한다면 라이브러리를 활용할 수 있다. (https://developer.mozilla.org/ko/docs/Web/API/IndexedDB_API, See also)


- 세션에서 탭이 닫힌건 어떻게 알고...? 데이터를 날리는 건지

[ 요약 ]
브라우저 저장소로 Cookie와 Web Storage가 있다. Cookie와 Web Storage 모두 해당 도메인과 관련된 데이터를 클라이언트 웹브라우저에 저장할 수 있도록 해준다. 둘 다 사이트의 도메인 단위로 접근이 제한된다. 예를 들면, A 도메인에서 저장한 데이터는 B 도메인에서 접근할 수 없는 것이다.

Cookie는 매번 서버로 전송되고, 문자열만 저장이 가능하며, 용량에 제한이 있고, 만료 일자가 존재한다. 이러한 부분들을 Web Storage를 사용함으로써 극복할 수 있다.

Web Storage는 데이터를 클라이언트에 저장만 할 뿐 서버로 전송되지는 않는다. 그리고 문자열 외에도 구조화된 객체를 저장할 수 있어 개발 편의성을 제공해주고, 하나의 사이트에서 저장할 수 있는 용량이 제한되어있지 않다. 또한, Web Storage에 한 번 저장한 데이터는 영구적으로 존재하게 된다.

WebStorage는 지속성에 따라 LocalStorage와 SessionStorage로 구분할 수 있다.

LocalStorage는 저장한 데이터를 명시적으로 지우지 않는한 영구적으로 보관이 가능하다. 도메인마다 별도로 LocalStorage가 생성되며, 도메인만 같다면 전역적으로 공유가 가능하다.

SessioniStorage는 데이터의 지속성과 액세스 범위에 특수한 제한이 존재한다. 도메인마다 별도로 생성되는 점은 LocalStorage와 같지만, 같은 사이트의 도메인이라도 브라우저가 다르면 서로 다른 영역이 된다. 이는 브라우저 컨텍스트가 다르기 때문이다.

이처럼 Web Storage는 영구저장소(LocalStorage)와 임시저장소(SessionStorage)가 구분되기 때문에, 데이터의 지속성에 따라 선택이 가능하다.



참고
https://bit.ly/3angfoC
https://victorydntmd.tistory.com/115
https://interconnection.tistory.com/74
https://velog.io/@gygy/%EB%A1%9C%EC%BB%AC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%84%B8%EC%85%98%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%BF%A0%ED%82%A4
https://velog.io/@dorazi/%EC%BF%A0%ED%82%A4-%EC%9B%B9-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EB%A1%9C%EC%BB%AC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%84%B8%EC%85%98-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80
https://velog.io/@design0728/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A0%80%EC%9E%A5%EC%86%8C-LocalStorage-SessionStorage-Cookie
https://pks2974.medium.com/indexeddb-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-ca9be4add614

https://developer.mozilla.org/ko/docs/Web/API/Web_Storage_API
https://developer.mozilla.org/ko/docs/Web/API/IndexedDB_API
