# 2. 실용주의 접근법

### 8. 좋은 설계의 핵심

> 좋은 설계는 나쁜 설계보다 바꾸기 쉽다.

- 잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰져야 한다. 
- **바꾸기 더 쉽게**(Easier to Change, ETC)

#### ETC는 규칙이 아니라 가치

- 가치는 결정을 내리게 도움을 주는 것이다.
- 가치를 내면화하기 위해 초기에는 의식적으로 노력해야 한다. 
- 실마리가 없을 경우
  1. 앞으로 어떤 모습으로 바뀔지 잘 모르겠을 때 언제든 궁극의 '바꾸기 쉽게'라는 길을 선택한다.
  2. 이런 경우를 여러분의 직관을 발전시키는 기회로 삼으라



### 9. DRY: 중복의 해악

- 유지 보수는 별개의 활동이 아니며, 전체 개발 과정의 일상적인 부분이다.
- 유지 보수를 하려면 사물의 표현 양식, 즉 애플리케이션에 표현되어 있는 지식을 찾아내고 또 바꿔야 한다. 문제는 명세와 프로세스, 개발하는 프로그램 안에 지식을 중복해서 넣기 쉽다는 것이다. 그렇게 된다면 애플리케이션이 출시되기 한참 전부터 유지 보수의 악몽이 시작될 것이다.
- DRY 원칙
  - **모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현 되어야 한다.**

> DRY: 반복하지 말라(Dont' Repeat Yourself)

- DRY는 코드 밖에서도
  - 코드의 어떤 측면 하나를 바꿔야 할 때 여러 곳을 바꾸고 있다면 그 코드는 DRY하지 않다.
- 모든 코드 중복이 지식의 중복은 아니다.
- 문서화 중복
- 데이터의 DRY 위반
- 표현상의 중복
  - 내부 API에서 생기는 중복
  - 외부 API에서 생기는 중복
  - 데이터 저장소와의 중복
- 개발자 간의 중복

> 재사용하기 쉽게 만들어라.



### 10. 직교성

- 직교성(othogonality)는 설계와 빌드, 테스트, 확장이 쉬운 시스템을 만드는 데에 있어 매우 중요한 개념

#### 직교성이란

- 컴퓨터 과학에서는 일종의 독립성이나, 결합도 줄이기(decoupling)를 의미한다. 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다.

#### 직교성의 장점

> 관련 없는 것들 간에 서로 영향이 없도록 하라.

**생산성 향상**

- 변화를 국소화해 개발 시간과 테스트 시간이 줄어든다.
- 재사용을 촉진한다.
- 미묘한 생산성 향상
  - 직교적인 컴포넌트들을 결합함으로써 단위 노력당 더 많은 기능을 얻을 수 있다.

**리스크 감소**

- 감염된 코드가 격리되어 있다.
- 시스템이 잘 깨지지 않는다.
- 직교적인 시스템은 그 안의 컴포넌트들에 대해 테스트를 설계하고 실행하기가 쉽기 때문에 테스트를 더 많이 하게 된다.
- 특정 업체나 제품, 플랫폼에 덜 종속적이다.

#### 설계

- 시스템은 서로 협력하는 모듈의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다. 때로는 이런 컴포넌트들이 계층으로 묶여서 계층 단위의 추상화를 제공하기도 한다.
- 계층 구조는 직교적 시스템을 설계하는 강력한 방법이다. 각 계층은 자기 바로 밑에 있는 계층이 제공하는 추상화만을 사용하기 때문에, 다른 코드에 영향을 끼치지 않으면서 기반 구현들을 변경할 수 있게 되어 유연성이 높아진다.
- 특정 기능에 대한 요구 사항을 대폭 변경하는 경우 몇 개의 모듈이 영향을 받는가? → 하나

#### 툴킷과 라이브러리

- 외부에서 만든 툴킷과 라이브러리를 도입할 때 시스템의 직교성을 해치지 않는지 주의 깊게 살펴보고, 기술을 현명하게 선택하라.

#### 코딩

- 직교성을 유지하기 위해 사용할 수 있는 몇 가지 기법
  1. 코드의 결합도를 줄여라
  2. 전역 데이터를 피하라
  3. 유사한 함수를 피하라

#### 테스트

- 테스트를 정규 빌드 과정의 일부로 수행하라.

#### 문서화

#### 직교적으로 살아가기



### 11. 가역성

#### 가역성

- 중요하면서 되돌릴 수 없는 결정을 줄여야 하는 까닭은 우리가 프로젝트 초기에 늘 최선의 결정을 내리지는 못하기 때문이다.
- 결정이 바뀌지 않을 것이라 가정하고서 발생할지도 모를 우연한 사건에 대비하지 않는 데에서 실수가 나온다. 결정이 바닷가의 모래 위에 쓰인 글씨라 생각하라. 언제든지 큰 파도가 글씨를 지워버릴 수 있다.

> 최종 결정이란 없다.

#### 유연한 아키텍처

- 바꾸기 쉽게 만들라.
  - 외부의 API를 추상화 계층 뒤로 숨겨라.
  - 코드를 여러 컴포넌트로 쪼개라

> 유행을 좇지 말라



### 12. 예광탄

#### 어둠 속에서 빛을 내는 코드

- 예광탄이 효과적인 까닭은 일반 탄환과 동일한 환경 및 제약 조건에서 발사되기 때문
- 코딩에서 동일한 효과를 얻으려면 우리를 요구 사항으로부터 최종 시스템의 일부 측면까지 빨리, 눈에 보이게, 반복적으로 도달하게 해 줄 무언가를 찾아야 한다.
- 시스템을 정의하는 중요한 요구 사항을 찾아라. 의문이 드는 부분이나 가장 위험이 커 보이는 곳을 찾아라. 이런 부분의 코드를 가장 먼저 작성하도록 개발 우선순위를 정하라.

> 목표물을 찾기 위해 예광탄을 써라

- 예광탄 코드 접근 방법의 장점
  - 사용자가 뭔가 작동하는 것을 일찍부터 보게 된다.
  - 개발자가 들어가서 일할 수 있는 구조를 얻는다.
  - 통합integration 작업을 수행할 기반이 생긴다.
  - 보여줄 것이 생긴다.
  - 진행 상황에 대해 더 정확하게 감을 잡을 수 있다.

#### 예광탄이 언제나 목표물을 맞히는 것은 아니다

- 지금 있는 것을 목표물에 더 가까워지도록 바꿔라.

#### 예광탄 코드 대 프로토타이핑

- 프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다. 진짜 프로토타입 방식을 따른다면 프로토타입은 어떤 개념을 실험해 보느라 대충 끼워 맞추어 구현한 것이므로 모두 버려야 한다. 그리고 실험 과정에서 얻은 교훈을 바탕으로 코드를 새로 작성한다.
- 프로토타입은 나중에 버리는 코드를 만든다. 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격 중 일부가 된다. 프로토타입은 예광탄을 발사하기 전에 먼저 수행하는 정찰이나 정보 수집과 같은 것이다.



### 13. 프로토타입과 포스트잇

- 프로토타입: 위험 요소를 분석하고 노출시킨 후, 이를 매우 저렴한 비용으로 바로잡을 기회를 얻는다.
- 포스트잇을 사용해 작업 흐름이나 애플리케이션 로직과 같이 동적인 것을 프로토타이핑 할 수 있다.

#### 프로토타이핑 대상

- 아키텍처
- 기존 시스템에 추가할 새로운 기능
- 외부 데이터의 구조 혹은 내용
- 외부에서 가져온 도구나 컴포넌트
- 성능 문제
- 사용자 인터페이스 설계

> 프로토타이핑으로 학습하라

#### 프로토타입을 어떻게 사용할 것인가?

- 프로토타입을 만들 때 무시해도 좋은 세부사항
  - 정확성
  - 완전성
  - 안정성
  - 스타일

#### 아키텍처 프로토타이핑

- 아키텍처 프로토타이핑에서 규명할 만한 사항
  - 주요 영역의 책임이 잘 정의되었고 적절한가?
  - 주요 컴포넌트 간의 협력 관계가 잘 정의되었는가?
  - 결합도는 최소화했는가?
  - 중복이 발생할 만한 곳이 있는가?
  - 정의된 인터페이스와 제약 사항은 수용할 만한가?
  - 각 모듈이 실행 중에 필요한 데이터에 접근할 수 있는 경로를 갖고 있는가? 모듈에 데이터가 필요한 시점에 데이터 접근이 가능한가?

#### 프로토타입 코드를 사용하지 않도록 하려면

- 모든 사람에게 폐기 처분할 코드를 작성하고 있다는 사실을 이해시켜야 한다.
- 프로토타입 코드의 목적이 잘못 해석될 가능성이 크다고 느낀다면 예광탄 접근 방식을 취하는 편이 나을 것이다.



### 14. 도메인 언어
