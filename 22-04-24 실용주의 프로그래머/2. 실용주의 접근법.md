# 2. 실용주의 접근법

### 8. 좋은 설계의 핵심

> 좋은 설계는 나쁜 설계보다 바꾸기 쉽다.

- 잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰져야 한다. 
- **바꾸기 더 쉽게**(Easier to Change, ETC)

#### ETC는 규칙이 아니라 가치

- 가치는 결정을 내리게 도움을 주는 것이다.
- 가치를 내면화하기 위해 초기에는 의식적으로 노력해야 한다. 
- 실마리가 없을 경우
  1. 앞으로 어떤 모습으로 바뀔지 잘 모르겠을 때 언제든 궁극의 '바꾸기 쉽게'라는 길을 선택한다.
  2. 이런 경우를 여러분의 직관을 발전시키는 기회로 삼으라



### 9. DRY: 중복의 해악

- 유지 보수는 별개의 활동이 아니며, 전체 개발 과정의 일상적인 부분이다.
- 유지 보수를 하려면 사물의 표현 양식, 즉 애플리케이션에 표현되어 있는 지식을 찾아내고 또 바꿔야 한다. 문제는 명세와 프로세스, 개발하는 프로그램 안에 지식을 중복해서 넣기 쉽다는 것이다. 그렇게 된다면 애플리케이션이 출시되기 한참 전부터 유지 보수의 악몽이 시작될 것이다.
- DRY 원칙
  - **모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현 되어야 한다.**

> DRY: 반복하지 말라(Dont' Repeat Yourself)

- DRY는 코드 밖에서도
  - 코드의 어떤 측면 하나를 바꿔야 할 때 여러 곳을 바꾸고 있다면 그 코드는 DRY하지 않다.
- 모든 코드 중복이 지식의 중복은 아니다.
- 문서화 중복
- 데이터의 DRY 위반
- 표현상의 중복
  - 내부 API에서 생기는 중복
  - 외부 API에서 생기는 중복
  - 데이터 저장소와의 중복
- 개발자 간의 중복

> 재사용하기 쉽게 만들어라.



### 10. 직교성

- 직교성(othogonality)는 설계와 빌드, 테스트, 확장이 쉬운 시스템을 만드는 데에 있어 매우 중요한 개념

#### 직교성이란

- 컴퓨터 과학에서는 일종의 독립성이나, 결합도 줄이기(decoupling)를 의미한다. 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다.

#### 직교성의 장점

> 관련 없는 것들 간에 서로 영향이 없도록 하라.

**생산성 향상**

- 변화를 국소화해 개발 시간과 테스트 시간이 줄어든다.
- 재사용을 촉진한다.
- 미묘한 생산성 향상
  - 직교적인 컴포넌트들을 결합함으로써 단위 노력당 더 많은 기능을 얻을 수 있다.

**리스크 감소**

- 감염된 코드가 격리되어 있다.
- 시스템이 잘 깨지지 않는다.
- 직교적인 시스템은 그 안의 컴포넌트들에 대해 테스트를 설계하고 실행하기가 쉽기 때문에 테스트를 더 많이 하게 된다.
- 특정 업체나 제품, 플랫폼에 덜 종속적이다.

#### 설계

- 시스템은 서로 협력하는 모듈의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다. 때로는 이런 컴포넌트들이 계층으로 묶여서 계층 단위의 추상화를 제공하기도 한다.
- 계층 구조는 직교적 시스템을 설계하는 강력한 방법이다. 각 계층은 자기 바로 밑에 있는 계층이 제공하는 추상화만을 사용하기 때문에, 다른 코드에 영향을 끼치지 않으면서 기반 구현들을 변경할 수 있게 되어 유연성이 높아진다.
- 특정 기능에 대한 요구 사항을 대폭 변경하는 경우 몇 개의 모듈이 영향을 받는가? → 하나

#### 툴킷과 라이브러리

- 외부에서 만든 툴킷과 라이브러리를 도입할 때 시스템의 직교성을 해치지 않는지 주의 깊게 살펴보고, 기술을 현명하게 선택하라.

#### 코딩

- 직교성을 유지하기 위해 사용할 수 있는 몇 가지 기법
  1. 코드의 결합도를 줄여라
  2. 전역 데이터를 피하라
  3. 유사한 함수를 피하라

#### 테스트

- 테스트를 정규 빌드 과정의 일부로 수행하라.

#### 문서화

#### 직교적으로 살아가기



### 11. 가역성
