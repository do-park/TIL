# 4. 실용주의 편집증

> 여러분은 완벽한 소프트웨어를 만들 수 없다.

- **실용주의 프로그래머는 자기 자신 역시 믿지 않는다.**
- 그러므로 실용주의 프로그래머는 자신의 실수에 대비한 방어책을 마련한다.



### 23. 계약에 의한 설계

- 계약contract
  - 계약은 자신과 상대편의 권리 및 책임을 정의한다. 그뿐만 아니라 한쪽이 계약을 어겼을 경우의 대응도 계약 사항에 포함된다.

#### DBC

- 계약에 의한 설계Design By Contract, DBC
- 프로그램의 정확성을 보장하기 위해 소프트웨어 모듈의 권리와 책임을 문서화하고 합의하는 데에 초점을 맞춘다.
- 정확한 프로그램이란 자신이 하는 일이라고 주장하는 것보다 많지도 적지도 않게 딱 그만큼만 하는 프로그램이다.
- 소프트웨어 시스템의 모든 함수와 메서드는 **뭔가를 한다.** 그 **뭔**가를 시작하기 전에 해당 함수는 세상의 상태에 대해 어떤 전제 조건을 갖고 있을 테고, 루틴이 끝난 후에는 세상의 상태가 어떠할 것이라고 선언할 수 있을 것이다.
- 전제와 선언
  - 선행 조건precondition
    - 루틴이 호출되기 위해 참이어야 하는 것. 즉, 루틴의 요구 사항.
    - 루틴의 선행 조건이 위반된 경우에는 루틴이 호출되어서는 안 된다. 제대로 된 데이터를 전달하는 것은 호출하는 쪽의 책임이다.
  - 후행 조건postcondition
    - 루틴이 자기가 할 것이라고 보장하는 것. 즉, 루틴이 완료되었을 때 세사으이 상태.
    - 루틴에 후행 조건이 있다는 것은 곧 루틴이 **종국에는** 종료될 것이라는 걸 의미한다. 무한 반복은 허용되지 않는다.
  - 클래스 불변식class invariant
    - 호출자의 입장에서 볼 때는 이 조건이 언제나 참인 것을 클래스가 보장한다. 루틴의 내부 처리 도중에는 불변식이 참이 아닐 수도 있지만, 루틴이 끝나고 호출자로 제어권이 반환되는 시점에는 불변식이 참이 되어야 한다. (따라서 클래스는 불변식에 관여하는 데이터 멤버의 제한 없는 쓰기를 허용할 수 없다.)
- 루틴과 그 루틴을 호출하려는 코드 간의 계약
  - 만약 호출자가 루틴의 모든 선행 조건을 충족한다면 해당 루틴은 종료 시 모든 후행 조건과 불변식이 참이 되는 것을 보장한다.

> 계약으로 설계하라.

- 게으름뱅이lazy 코드
  - 시작하기 전에 자신이 수용할 것은 엄격하게 확인하고, 내어 줄 것에 대해서는 최소한도를 약속하라.

#### DBC 구현

- DBC는 설계 기법이다. 자동 검사가 없더라도 계약을 코드에 주석이나 단위 테스트로 넣어둘 수 있고, 여전히 실질적인 소득이 있다.
- **단정문**
  - 컴파일러가 대신 계약을 검사하도록 조건문을 실행 시점에 확인하는 '단정문'을 사용할 수 있다.
  - 단정문으로 DBC로 가능한 모든 것을 할 수는 없다.

#### DBC와 일찍 멈추기

- 단정문이나 DBC 방식을 사용해 선행 조건과 후행 조건, 불변식을 검증하면 더 일찍 멈추고, 문제에 대한 보다 정확한 정보를 알려줄 수 있을 것이다.
- 문제를 찾고 원인을 밝히기 위해서는 사고가 난 지점에서 일찍 멈추는 것이 유리하다.

#### 의미론적 불변식

- semantic invarient
- 의미론적 불변식은 무언가가 품은 진짜 의미의 중심이 되어야 하며, 훨씬 역동적으로 변하는 비즈니스 규칙처럼 일시적인 정책에 영향을 받으면 안 된다.
- 불변식의 자격이 있는 요구 사항을 찾았다면 여러분이 작성하는 모든 문서에 잘 드러나도록 만들어라. 
- 이것은 시스템의 여러 다른 부분에 적용할 수 있는 분명하고 간략하며 명확한 선언이다. 이는 모든 시스템 사용자와 맺는 계약이며 동작에 대한 우리의 보증이다.

#### 동적 계약과 에이전트

- 목표를 달성하기 위해 자기네끼리 계약 협상을 할 수 있는 컴포넌트와 에이전트가 충분하다면 소프트웨어가 우리 대신 문제를 해결하도록 해서 소프트웨어 생산성 위기를 간단히 해결할 수 있을지도 모른다. 하지만 수동으로 계약을 만들 수 없다면 자동화하는 것은 꿈도 꿀 수 없다. 그러니 나중에 소프트웨어를 설계하게 되면 계약 역시 설계하도록 하라.



### 24. 죽은 프로그램은 거짓말을 하지 않는다

- 모든 오류는 정보를 준다. 여러분은 오류가 발생할 리 없다고 자신을 설득하고선 그걸 무시하기로 할 수도 있다. 반면에 실용ㅈ의 프로그래머는 만약 오류가 발생했다면 정말로 뭔가 나쁜 일이 생긴 것이라고 자신에게 이야기한다. 일단 그놈의damn 오류 메시지 좀 읽어라.

#### 잡은 후 그냥 놓아주는 것은 물고기뿐

- 애플리케이션 코드가 오류 처리 코드 사이에 묻히지 않게 하라
- catch, rescue 등으로 코드의 결합도를 높이지 말라

> 일찍 작동을 멈춰라

#### 망치지 말고 멈춰라

- "방어적 프로그래밍은 시간 낭비다. 그냥 멈추는 게 낫다!"
- 방금 있을 수 없는 일이 발생했다는 것을 코드가 발견했다면 프로그램은 더는 유효하지 않다고 할 수 있다. 이 시점 이후로 하는 일은 모두 수상쩍은 게 된다. 되도록 빨리 종료할 일이다.



### 25. 단정적 프로그래밍

> 단정문으로 불가능한 상황을 예방하라

- '물론 그런 일은 절대 일어나지 않을 거야'라는 생각이 든다면 그런 일을 확인하는 코드를 추가하라.
- assert

#### 단정과 부작용

- 단정문을 쓸 때 조건을 평가하는 코드에 부작용side effect이 있다면 문제를 발견하려고 넣은 코드가 오히려 새로운 문제를 만들 수 있다.

#### 단정 기능을 켜 둬라



### 26. 리소스 사용의 균형

> 자신이 시작한 것은 자신이 끝내라.

- 리소스를 할당하는 함수나 객체가 리소스를 해제하는 책임 역시 져야 한다.

- 잘 모르겠을 땐 언제나 스코프를 줄이는 편이 낫다.

> 지역적으로 행동하라.

#### 중첩 할당

- 리소스를 할당한 순서의 역순으로 해제하라. 이렇게 해야 한 리소스가 다른 리소스를 참조하는 경우에도 참조를 망가트리지 않는다.
- 코드의 여러 곳에서 동일한 구성의 리소스들을 할당하는 경우에는 언제나 같은 순서로 할당해야 교착deadlock 가능성을 줄일 수 있다.

#### 객체와 예외

- 객체 지향 언어로 프로그래밍을 한다면 리소스를 클래스 안에 캡슐화하는 것이 유용할 수 있다. 특정 유형의 리소스가 필요할 때마다 그 클래스의 객체를 생성하면 된다. 그 객체가 스코프를 벗어나거나 가비지 컬렉터가 객체를 수거해 가면 객체의 소멸자가 클래스 안에 들어 있는 리소스를 해제한다.
- 예외 때문에 리소스 해제가 제대로 되지 않을 수 있는 언어로 작업할 때에 특히 쓸모 있다.

#### 균형 잡기와 예외

- 예외가 던져진 경우 예외 발생 이전에 할당된 모든 것이 깨끗이 청소된다고 어떻게 보장할 수 있을까?
  1. 변수 스코프를 사용한다. 예를 들어 c++나 러스트Rust의 스택 변수가 있다.
  2. try-catch 블록에서 finally 절을 사용한다.

#### 리소스 사용의 균형을 잡을 수 없는 경우

- 동적인 자료 구조를 사용하는 프로그램에서 리소스 할당 기본 패턴이 아예 맞지 않는 경우가 있다.
  - 한 루틴에서 메모리의 일정 영역을 할당한 다음 어떤 더 큰 구조에 그것을 연결한 후, 한동안 그대로 쓰는 식
- 메모리 할당에 대한 의미론적 불변식 정하기
  - 한군데 모은 자료 구조 안의 자료를 누가 책임지는지
  - 자료 구조에서 최상위 구조의 메모리 할당을 해제할 경우 어떻게 처리해야 할까?
    - 최상위 구조가 자기 안에 들어 있는 하위 구조들을 해제할 책임을 진다. 하위 구조들은 또다시 재귀적으로 자기 안에 들어 있는 자료들을 해제할 책임을 지고, 이런 식으로 반복된다.
    - 최상위 구조가 그냥 할당 해제된다. 최상위 구조가 참조하던 하위 구조들은 연결이 끊어져서 다른 곳에서 참조하지 않는다면 외톨이가 된다.
    - 최상위 구조가 하나라도 하위 구조를 가지고 있으면 자신의 할당 해제를 거부한다.
  - 선택은 각 자료 구조의 상황에 따라 달라진다. 하지만 어떤 것을 선택할지 확실하게 정하고 그에 따라 일관성 있게 구현해야 한다.

#### 균형을 점검하기

- 래퍼를 사용해서 상태가 올바른지 점검하라.



### 27. 헤드라이트를 앞서가지 말라

> 작은 단계들을 밟아라. 언제나.

- 언제나 신중하게 작은 단계들을 밟아라. 더 진행하기 전에 피드백을 확인하고 조정하라. 피드백의 빈도를 여러분의 제한 속도라고 생각하라. '너무 큰' 단계나 작업은 하지 않게 될 것이다.
- 불확실한 미래에 대비한 설계를 하느라 진을 빼는 대신 언제나 교체 가능한 코드를 작성하여 대비하면 된다.
  - 코드를 교체할 수 있도록 하면 응집도나 결합도, DRY에도 도움이 되고, 전반적으로 더 나은 설계가 탄생할 것이다.

#### 블랙 스완

> 예언하지 말라.

