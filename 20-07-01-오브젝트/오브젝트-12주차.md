# 13. 서브클래싱과 서브타이핑

### 상속의 용도

1. **타입 계층**의 구현
   - 타입 계층의 관점에서 부모 클래스는 자식 클래스의 **일반화(generalization)**이고 자식 클래스는 부모 클래스의 **특수화(specialization)**이다.
2. **코드 재사용**



### 타입

[프로그래밍 언어에서의 타입의 목적]

- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.

[객체지향 패러다임 관점의 타입]

- 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류다.
- 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다.
- 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다.
  - **퍼블릭 인터페이스**: 객체가 수신할 수 있는 메시지의 집합



### 타입의 계층

- 일반화: 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과
- 특수화: 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과



- 슈퍼타입: 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
  - 집합이 다른 집합의 모든 멤버를 포함한다.
  - 타입 정의가 다른 타입보다 좀 더 일반적이다.
- 서브타입: 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것
  - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
  - 타입 정의가 다른 타입보다 좀 더 구체적이다.



### 서브클래싱과 서브타이핑

- 언제 상속을 사용해야 하는가? (모든 질문에 '예'라고 답할 수 있을 때)
  - 상속 관계가 is-a 관계를 모델링하는가?
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가? (**행동 호환성**)

- **인터페이스 분리 원칙(Interface Segregation Principle, ISP)**: 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙

> - **서브클래싱(subclassing)**: 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우. 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다. 서브클래싱을 **구현 상속(implementation inheritance)** 또는 **클래스 상속(class inheritance)**이라고 부르기도 한다.
>
> 
>
> - **서브타이핑(subtyping)**: 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다. 서브타이핑에서는 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. 이때 부모 클래스는 자식 클래스의 수퍼타입이 되고 자식 클래스는 부모 클래스의 서브타입이 된다. 서브타이핑을 **인터페이스 상속(Interface inheritance)**이라고 부르기도 한다.

- 서브타이핑 관계가 유지되기 위해서는 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다. 즉, 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 **행동 호환성(begavioral substitution)**을 만족시켜야 한다.
- 자식 클래스가 부모 클래스를 대신할 수 있기 위해서는 자식 클래스가 부모 클래스가 사용되는 모든 문맥에서 자식 클래스와 동일하게 행동할 수 있어야 한다. 그리고 행동 호환성을 만족하는 상속 관계는 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것이라는 것을 보장해야 한다. 다시 말해 자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 **대체 가능성(substitutability)**을 포함한다.



### 리스코프 치환 원칙

> 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.

- 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다.
- 리스코프 치환 원칙은 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공한다.



### 계약에 의한 설계와 서브타이핑

- **계약에 의한 설계(Design By Contract, DBC)**: 클라이언트와 서버 사이의 협력을 의무(obligation)와 이익(benefit)으로 구성된 계약의 관점에서 표현하는 것
- 계약에 의한 설계는 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 **사전 조건(precondition)**과 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 **사후 조건(postcondition)**, 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 **클래스 불변식(class invariant)**의 세 가지 요소로 구성된다.
- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 '계약'을 준수해야 한다.

> 서브타입에 더 강력한 사전조건을 정의할 수 없다.
>
> 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
>
> 서브타입에 더 악한 사후조건을 정의할 수 없다.