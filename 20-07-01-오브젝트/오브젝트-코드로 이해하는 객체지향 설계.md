## 코드를 바라보는 관점

1. 시스템을 독립적인 기능을 담당하는, 재사용 가능한 프로시저의 구성으로 보는 방법
2. **객체지향 프로그래밍(OOP)**
   - 시스템을 객체의 구성으로 보는 방법
   - 객체에게 명령 대신 요청을 담은 메시지를 전달하면 객체는 이를 어떻게 처리할 지 자율적으로 판단하고, 내부에 가지고 있는 데이터를 이용해 필요한 작업을 수행하는 방식. 책임과 권한을 가진 객체들이 서로 메시지를 주고받으며 협력해서 필요한 기능을 수행하도록 시스템을 개발
   - 객체지향 설계의 핵심: **역할, 책임, 협력**



# 1. 객체, 설계

> 우리는 객체의 자율성을 높여, 이해하기 쉽고 유연한 설계를 얻을 수 있다.
>
> 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.



- 소프트웨어 모듈이 가져야 하는 세 가지 기능
  1. 실행 중에 제대로 동작해야 한다.
  2. 변경이 용이해야 한다.
  3. 이해하기 쉬워야 한다.
     - 로버트 마틴(Robert C. Martin), <클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법>

- 객체 사이의 **의존성(dependency)**
  - 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다.
  - 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다. 따라서 우리는 애플리케이션을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성은 제거해야 한다.
- 객체 사이의 **결합도(coupling)**
  - 객체 사이의 의존성이 과한 경우 결합도가 높다고 한다.
  - 두 객체 사이의 결합도가 높을수록 변경이 힘들어진다.
  - 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이다.
- **캡슐화(encapsulation)**
  - 개념적으로나 물리적으로 객체 내부의 세부적인 사항을 감추는 것
  - 목적: 변경하기 쉬운 객체를 만드는 것
  - 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다.

- 객체를 인터페이스(interface)와 구현(implementation)으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.

- **응집도(cohesion)**

  - 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 응집도가 높다고 한다.
  - 객체의 응집도를 높이기 위해 객체는 스스로 자신의 데이터를 책임져야 한다.

- **객체지향 프로그래밍(Object-Oriented Programming)**

  - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식

  - 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮춘다.

  - 각 객체에 책임이 적절하게 분배되어, 각 객체는 스스로를 책임진다.

  - #### 불필요한 세부사항을 캡슐화해 자율적인 객체들이 낮은 결합도와 높은 응집도를 가지고 협력하도록 최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계다.

  - 훌륭한 객체지향 설계는 소프트웨어의 구성하는 모든 객체들이 자율적으로 행동하는 설계

- **의인화(Anthropomorphism)**

  - 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙



# 2. 객체지향 프로그래밍

> 프로그래밍을 하는 동안
>
> 1. 어떤 클래스가 필요한지를 고민하기 전에 **어떤 객체들이 필요한지 고민하라**
> 2. 객체를 독립적인 존재가 아니라 **기능을 구현하기 위해 협력하는 공동체의 일원**으로 바라보라



- **도메인(domain)**
  - 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
  - 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다.
  - 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.

- 클래스(class)
  - 클래스에서 가장 중요한 것은 **클래스의 경계를 구분 짓는 것**
    - 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.
    - **인스턴스 변수의 가시성은 private, 메서드의 가시성은 public**
      - 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고, 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게
  - 왜?
    - 경계의 명확성이 객체의 자율성을 보장
    - 프로그래머에게 구현의 자유를 제공
- 객체
  - 객체는 **상태(state)**와 **행동(behavior)**을 함께 가지는 복합적인 존재
  - 객체는 스스로 판단하고 행동하는 **자율적인 존재**

- **접근 제어(access control)**

  	- 상태와 행동을 캡슐화하는 것에서 나아가 외부에서의 접근을 통제할 수 있는 메커니즘
  	- public, protected, private과 같은 **접근 수정자(access modifier)**를 제공하기도 한다.
   - 객체 내부에 대한 접근을 통제하는 이유: 객체를 자율적인 존재로 만들기 위해
   - 캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.
      - **퍼블릭 인터페이스(public interface)**: 외부에서 접근 가능한 부분
      - **구현(implementation)**: 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분
      - **인터페이스와 구현의 분리(separation of interface and implementation)** 원칙
  - 프로그래밍 언어 차원에서 클래스의 내부와 외부를 명확하게 경계 지을 수 있게 하는 동시에 클래스 작성자가 내부 구현을 은닉할 수 있게 해준다.
  - 클라이언트 프로그래머가 실수로 숨겨진 부분에 접근하는 것을 막아준다.

- **구현 은닉(implementation hiding)**

  - 프로그래머의 역할을 클래스 작성자(class creator)와 클라이언트 프로그래머(client programmer)로 나누었을 때
    1. 클래스 작성자
       - 새로운 데이터 타입을 프로그램에 추가
       - 구현 은닉
         - 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨야 한다.
         - 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.
    2. 클라이언트 프로그래머
       - 클래스 작성자가 추가한 데이터 타입을 사용
       - 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축
  - 장점
    - 클라이언트 프로그래머는 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다.
    - 클래스 작성자는 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

  