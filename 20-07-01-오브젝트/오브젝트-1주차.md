## 코드를 바라보는 관점

1. 시스템을 독립적인 기능을 담당하는, 재사용 가능한 프로시저의 구성으로 보는 방법
2. **객체지향 프로그래밍(OOP)**
   - 시스템을 객체의 구성으로 보는 방법
   - 객체에게 명령 대신 요청을 담은 메시지를 전달하면 객체는 이를 어떻게 처리할 지 자율적으로 판단하고, 내부에 가지고 있는 데이터를 이용해 필요한 작업을 수행하는 방식. 책임과 권한을 가진 객체들이 서로 메시지를 주고받으며 협력해서 필요한 기능을 수행하도록 시스템을 개발
   - 객체지향 설계의 핵심: **역할, 책임, 협력**



# 1. 객체, 설계

> 우리는 객체의 자율성을 높여, 이해하기 쉽고 유연한 설계를 얻을 수 있다.
>
> 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.



- 소프트웨어 모듈이 가져야 하는 세 가지 기능
  1. 실행 중에 제대로 동작해야 한다.
  2. 변경이 용이해야 한다.
  3. 이해하기 쉬워야 한다.
     - 로버트 마틴(Robert C. Martin), <클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법>

- 객체 사이의 **의존성(dependency)**
  - 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다.
  - 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다. 따라서 우리는 애플리케이션을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성은 제거해야 한다.
- 객체 사이의 **결합도(coupling)**
  - 객체 사이의 의존성이 과한 경우 결합도가 높다고 한다.
  - 두 객체 사이의 결합도가 높을수록 변경이 힘들어진다.
  - 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이다.
- **캡슐화(encapsulation)**
  - 개념적으로나 물리적으로 객체 내부의 세부적인 사항을 감추는 것
  - 목적: 변경하기 쉬운 객체를 만드는 것
  - 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다.

- 객체를 인터페이스(interface)와 구현(implementation)으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.

- **응집도(cohesion)**

  - 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 응집도가 높다고 한다.
  - 객체의 응집도를 높이기 위해 객체는 스스로 자신의 데이터를 책임져야 한다.

- **객체지향 프로그래밍(Object-Oriented Programming)**

  - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식

  - 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮춘다.

  - 각 객체에 책임이 적절하게 분배되어, 각 객체는 스스로를 책임진다.

  - #### 불필요한 세부사항을 캡슐화해 자율적인 객체들이 낮은 결합도와 높은 응집도를 가지고 협력하도록 최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계다.

  - 훌륭한 객체지향 설계는 소프트웨어의 구성하는 모든 객체들이 자율적으로 행동하는 설계

- **의인화(Anthropomorphism)**

  - 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙



# 2. 객체지향 프로그래밍

> 프로그래밍을 하는 동안
>
> 1. 어떤 클래스가 필요한지를 고민하기 전에 **어떤 객체들이 필요한지 고민하라**
> 2. 객체를 독립적인 존재가 아니라 **기능을 구현하기 위해 협력하는 공동체의 일원**으로 바라보라



- **도메인(domain)**
  - 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
  - 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다.
  - 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.
  
- 클래스(class)
  - 클래스에서 가장 중요한 것은 **클래스의 경계를 구분 짓는 것**
    - 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.
    - **인스턴스 변수의 가시성은 private, 메서드의 가시성은 public**
      - 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고, 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게
  - 왜?
    - 경계의 명확성이 객체의 자율성을 보장
    - 프로그래머에게 구현의 자유를 제공
  
- 객체
  - 객체는 **상태(state)**와 **행동(behavior)**을 함께 가지는 복합적인 존재
  - 객체는 스스로 판단하고 행동하는 **자율적인 존재**
  
- **접근 제어(access control)**

  	- 상태와 행동을 캡슐화하는 것에서 나아가 외부에서의 접근을 통제할 수 있는 메커니즘
    
   - public, protected, private과 같은 **접근 수정자(access modifier)**를 제공하기도 한다.

   - 객체 내부에 대한 접근을 통제하는 이유: 객체를 자율적인 존재로 만들기 위해

   - 캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.
      - **퍼블릭 인터페이스(public interface)**: 외부에서 접근 가능한 부분
      - **구현(implementation)**: 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분
      - **인터페이스와 구현의 분리(separation of interface and implementation)** 원칙
      
  - 프로그래밍 언어 차원에서 클래스의 내부와 외부를 명확하게 경계 지을 수 있게 하는 동시에 클래스 작성자가 내부 구현을 은닉할 수 있게 해준다.

  - 클라이언트 프로그래머가 실수로 숨겨진 부분에 접근하는 것을 막아준다.

- **구현 은닉(implementation hiding)**

  - 프로그래머의 역할을 클래스 작성자(class creator)와 클라이언트 프로그래머(client programmer)로 나누었을 때
    1. 클래스 작성자
       - 새로운 데이터 타입을 프로그램에 추가
       - 구현 은닉
         - 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨야 한다.
         - 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.
    2. 클라이언트 프로그래머
       - 클래스 작성자가 추가한 데이터 타입을 사용
       - 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축
  - 장점
    - 클라이언트 프로그래머는 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다.
    - 클래스 작성자는 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

- 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현하는 것이 전체적인 설계의 명확성과 유연성을 높이는 첫걸음이다.

- 협력
     - 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 **요청(request)**할 수 있다.
     - 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 **응답(response)**한다.
     - 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 **메시지를 전송(send a message)**
     - 다른 객체에게 요청이 도착할 때 해당 객체가 **메시지를 수신(receive a message)**
     - **메서드(method)**: 메시지를 수신한 객체가 메시지를 처리하기 위한 자신만의 방법
     - **다형성(polymorphism)**: 메시지와 메서드의 구분
     
- #### 상속(inheritance)과 다형성(polymorphism)의 기반에는 추상화(abstraction)가 있다.

- **TEMPLATE METHOD 패턴**: 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

- 오버라이딩과 오버로딩

  - **오버라이딩(overriding)**
    - 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우
    - 자식 클래스의 메서드는 오버라이딩한 부모 클래스의 메서드를 가리기 때문에 외부에서는 부모 클래스의 메서드가 보이지 않는다.
  - **오버로딩(overloading)**
    - 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다르다.
    - 오버로딩한 메서드는 원래의 메서드를 가리지 않기 때문에 이 메서드들은 공존한다.

- 의존성

  - 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다.

  - **코드의 의존성과 실행 시점의 의존성은 서로 다를 수 있다.**

  - **클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.**

  - 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다. 그러나 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다.

  - ##### 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다. 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다.

- **상속(inheritance)**
  - 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법
  - 코드 중복을 제거하고 여러 클래스들 사이에서 동일한 코드를 공유할 수 있다.
  - 클래스 사이에 관계를 설정하는 것만으로도 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함할 수 있다.
  - **차이에 의한 프로그래밍(programming by difference)**: 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
  - `자식 클래스와 부모 클래스`
    - 부모 클래스(parent class)
      - 슈퍼클래스(superclass), 부모(parent), 직계 조상(immediate ancestor), 직접적인 조상(direct ancestor)
      - 코드를 제공하는 클래스
    - 자식 클래스(child class)
      - 서브클래스(subclass), 자식(child), 직계 자손(immediate descendant), 직접적인 자손(direct descendant)
      - 코드를 제공받는 클래스
    - 상속 계층에서 특정 클래스보다 상위에 위치한 모든 클래스를 조상(ancestors), 특정 클래스보다 하위에 위치한 모든 클래스를 자손(descendants)이라고 부른다.
    - 클래스 관계는 상대적이다.
  - 자식 클래스가 부모 클래스를 대신하는 것을 **업캐스팅(upcasting)**이라고 한다.

- **다형성(polymorphism)**
  - 객체지향 프로그래밍의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
  - 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
  - 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다. (동일한 인터페이스)
  - **지연 바인딩(lazy binding), 동적 바인딩(dynamic binding)**: 메시지와 메서드를 실행 시점에 바인딩한다.
    - c.f. 초기 바인딩(early binding), 정적 바인딩(static binding): 컴파일 시점에 하수나 프로시저를 결정한다.
  - `구현 상속과 인터페이스 상속`
    - 구현 상속(implementatino inheritance)
      - 서브클래싱(subclassing)
      - 코드를 재사용하기 위한 목적으로 상속을 사용하는 것
    - 인터페이스 상속(interface inheritance)
      - 서브타이핑(subtyping)
      - 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것
    - 상속은 **인터페이스 상속**을 위해 사용해야 한다.
  - C#, 자바의 **인터페이스**
    - 순수하게 인터페이스만 공유하고 싶은 경우
    - 자바의 인터페이스: 구현에 대한 고려 없이 다형적인 협력에 참여하는 클래스드이 공유 가능한 외부 인터페이스를 정의
    - C++의 경우 추상 기반 클래스(Abstract Base Class, ABC)를 통해 자바의 인터페이스 개념을 구현할 수 있다.

- 추상화
  - 재사용 가능한 설계의 기본을 이루는 **디자인 패턴(design pattern)**이나 **프레임워크(framework)** 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용하고 있다.
  - 추상화를 이용하면 설계를 유연하게 만들 수 있다.
    - 설계가 구체적인 상황에 결합되는 것을 방지하기 때문
    - **컨텍스트 독립성(context independency)**
  - 코드 재사용: 상속과 합성
    - 상속
      - 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법
      - 문제점
        1. 캡슐화를 위반한다.
           - 부모 클래스의 구현이 자식 클래스에 노출되기 때문에 캡슐화가 약화된다.
        2. 설계를 유연하지 못하게 만든다.
           - 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.
    - **합성(composition)**
      - 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해 재사용하는 방법
      - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법
      - 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
      - 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.
      - 상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합된다.

#### 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것이다.



















