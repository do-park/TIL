# 9. 유연한 설계

### 개방-폐쇄 원칙(Open-Closed Principle, OCP)

- 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
  - 확장에 대해 열려 있다: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
  - 수정에 대해 닫혀 있다: 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.
- 컴파일 의존성을 고정시키고 런타임 의존성을 변경하라
  - 런타임 의존성: 실행시에 협력에 참여하는 객체들 사이의 관계
  - 컴파일 의존성: 코드에서 드러나는 클래스들 사이의 관계
- 추상화에 의존하라
  
  - 추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다. 추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다. 추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.
  
    

### 생성과 사용을 분리(Separating use from creation)

- 소프트웨어 시스템은 응용 프로그램 객체를 제작하고 의존성을 서로 "연결"하는 시작 단계와 시작 단계 이후 이어지는 실행 단계를 분리해야 한다.

- Factory 추가
  - Factory
    - 객체 생성과 관련된 책임만 전담하는 별도의 객체
    - 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체
  
- 시스템을 객체로 분해하는 방식
  1. **표현적 분해(representational decomposition**
     - 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것
     - 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목표로 한다.
     - 객체지향 설계를 위한 가장 기본적인 접근법
  2. **행위적 분해(behavioral decomposition)**
     - 모든 책임을 도메인 객체에게 할당할 경우 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제점에 봉착할 가능성이 높아진다. 이 경우 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결해야 한다. → **순수한 가공물(Pure Fabrication)**

- **순수한 가공물(Pure Fabrication)**

  - 도메인 객체에 책임을 할당할 경우 HIGH COHESION, LOW COUPLING, 재사용성 등의 목적을 위반한다면 문제 도메인 개념을 표현하지 않는, 인위적으로 또는 편의상 만든 클래스에 매우 응집된 책임을 할당하라.
  - INFORMATION EXPERT 패턴에 따라 책임을 할당한 겨로가가 바람직하지 않을 경우 대안으로 사용된다.

- **의존성 주입**

  - 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
  - 의존성 주입에서 의존성을 해결하는 세 가지 방법
    1. **생성자 주입(constructor injection)**: 객체를 생성하는 시점에 생성자를 통한 의존성 해결
    2. **setter 주입(setter injection)**: 객체 생성 후 setter 메서드를 통한 의존성 해결
    3. **메서드 주입(method injection)**: 메서드 실행 시 인자를 이용한 의존성 해결

- **SERVICE LOCATOR**

  - 의존성을 해결할 객체들을 보관하는 일종의 저장소
  - 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을 요청
  - 단점: 의존성을 감춘다
    - 의존성을 내부로 감출 경우
      1. 의존성과 관련된 문제가 컴파일타임이 아닌 런타임에 가서야 발견된다
      2. 단위 테스트 작성이 어렵다
      3. 의존성을 이해하기 위해 코드의 내부 구현을 이해할 것을 강요한다
    - 의존성 주입을 통한 문제 해결
      1. 필요한 의존성은 클래스의 퍼블릭 인터페이스에 명시적으로 드러난다
      2. 의존성을 이해하기 위해 코드 내부를 읽을 필요가 없으므로 의존성 주입은 객체의 캡슐을 단단하게 보호한다
      3. 의존성과 관련된 문제도 최대한 컴파일타임에 잡을 수 있다
      4. 단위 테스트를 작성할 때 필요한 인자를 전달해 필요한 객체를 생성하면 된다
    - 의존성 주입을 지원하는 프레임워크를 사용하지 못하는 경우나 깊은 호출 계층에 걸쳐 동일한 객체를 계속해서 전달해야 하는 고통을 견디기 어려운 경우에 SERVICE LOCATOR 패턴의 사용을 고려하라

- 의존성 역전 원칙(Dependency Inversion Principle, DIP)

  1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
  2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

  - 역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권에서도 적용된다



> 설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력에 초점을 맞춰야 한다. 다양한 컨텍스트에서 협력을 재사용할 필요가 없다면 설계를 유연하게 만들 당위성도 함께 사라진다. 객체들이 메시지 전송자의 관점에서 동일한 책임을 수행하는지 여부를 판단할 수 없다면 공통의 추상화를 도출할 수 없다. 동일한 역할을 통해 객체들을 대체 가능하게 만들지 않았다면 협력에 참여하는 객체들을 교체할 필요가 없다.