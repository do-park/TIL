# 8. 의존성 관리하기

> 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는 데 있다. 이런 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이라고 할 수 있다.

- 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다. 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
  - 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
  - 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
- **의존성 전이(transitive dependency)** 
  - 직접 의존성(direct dependency): 한 요소가 다른 요소에 직접 의존하는 경우
  - 간접 의존성(indirect dependency): 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우
  - 런타임 의존성(run-time dependency): 애플리케이션이 실행되는 시점
  - 컴파일타임 의존성(compile-time dependency): 컴파일하는 시점 또는 코드 그 자체(코드를 작성하는 시점)
    - 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체되어야 한다.
  - **컨텍스트 독립성**: 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.
  - **의존성 해결**: 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
    - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
    - 객체 생성 후 setter 매서드를 통해 의존성 해결
    - 메서드 실행 시 인자를 이용해 의존성 해결
- 바람직한 의존성이란 컨텍스트에 독립적인 의존성을 의미하며 다양한 환경에서 재사용될 수 있는 가능성을 열어놓는 의존성을 의미한다.
- **결합도**
  - 어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 **느슨한 결합도(loose coupling)** 또는 **약한 결합도(weak coupling)**를 가진다고 말한다.
  - 두 요소 사이의 의존성이 바람직하지 못할 때 **단단한 결합도(tight coupling)** 또는 **강한 결합도(strong coupling)**를 가진다고 말한다.
  - 결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.
- **명시적인 의존성(explicit dependency)**: 의존성은 명시적으로 표현돼야 한다. 
- new는 해롭다
  - new 연산자: 클래스의 인스턴스를 생성할 수 있는 연산자
  - new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. 따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클레스에 의존할 수밖에 없기 때문에 결합도가 높아진다.
  - new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. 따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.