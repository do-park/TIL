# 9. 유연한 설계

### 개방-폐쇄 원칙(Open-Closed Principle, OCP)

- 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
  - 확장에 대해 열려 있다: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
  - 수정에 대해 닫혀 있다: 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.
- 컴파일 의존성을 고정시키고 런타임 의존성을 변경하라
  - 런타임 의존성: 실행시에 협력에 참여하는 객체들 사이의 관계
  - 컴파일 의존성: 코드에서 드러나는 클래스들 사이의 관계
- 추상화에 의존하라
  
  - 추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다. 추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다. 추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.
  
    

### 생성과 사용을 분리(Separating use from creation)

- 소프트웨어 시스템은 응용 프로그램 객체를 제작하고 의존성을 서로 "연결"하는 시작 단계와 시작 단계 이후 이어지는 실행 단계를 분리해야 한다.
- Factory 추가
  - Factory
    - 객체 생성과 관련된 책임만 전담하는 별도의 객체
    - 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체
- 시스템을 객체로 분해하는 방식
  1. **표현적 분해(representational decomposition**
     - 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것
     - 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목표로 한다.
     - 객체지향 설꼐를 위한 가장 기본적인 접근법
  2. **행위적 분해(behavioral decomposition)**
     - 모든 책임을 도메인 객체에게 할당할 경우 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제점에 봉착할 가능성이 높아진다. 이 경우 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결해야 한다. → **순수한 가공물(Pure Fabrication)**

- **순수한 가공물(Pure Fabrication)**