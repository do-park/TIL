# 20. 리다이렉션과 부하 균형

### 1. 왜 리다이렉트인가?
- 리다이렉션이 필요한 이유
  - HTTP 애플리케이션은 언제나 [ 신뢰할 수 있는 트랜잭션의 수행 / 지연 최소화 / 네트워크 대역폭 절약 ] 을 원한다.
  - 이러한 이유들 때문에, 웹 콘텐츠는 여러 장소에 배포된다.
    - 한 곳에서 실패한 경우 다른 곳을 이용할 수 있으므로 신뢰성 개선
    - 클라이언트가 보다 가까운 리소스에 접근할 수 있게 되어 응답시간 감소
    - 목적지 서버가 분산되므로 네트워크 혼잡 감소
  - 리다이렉션이란 **최적의 분산된 콘텐츠를 찾는 것을 도와주는 기법의 집합**
- 대부분의 리다이렉션 장치들은 몇 가지 방식의 부하 균형을 포함한다.
  - 들어오는 메시지의 부하를 서버들의 집합에게 분산할 수 있다.

### 2. 리다이렉트 할 곳
- 서버, 프락시, 캐시, 게이트웨이에 공통적으로 적용되는 일반적인 기법
- 특정 종류의 종단에 특화된 기법

### 3. 리다이렉션 프로토콜의 개요
- 리다이렉션의 목표는 HTTP 메시지를 가용한 웹 서버로 가급적 빨리 보내는 것
- HTTP가 인터넷을 통해 나아가는 방향은 그 메시지가 오고, 거쳐가고, 향하는 HTTP 애플리케이션과 라우팅 장치에 영향을 받는다.
  - 브라우저 설정, DNS, TCP/IP 라우팅, 그리고 HTTP는 모두 메시지를 리다이렉트하는 메커니즘을 제공한다.
- p. 524) 메시지를 서버로 리다이렉트하기 위해 사용되는 리다이렉션 방법들
- p. 525) 메시지를 프락시 서버로 리다이렉트하기 위해 사용되는 리다이렉션 방법들

### 4. 일반적인 리다이렉션 방법
- 서버와 프락시 양쪽에서 공통으로 쓰이는 여러 가지 리다이렉션 방법
- 트래픽을 다른(아마 더 최적인 곳으로) 서버나 프락시를 통해 벡터 트래픽으로 리다이렉트하기 위해 사용될 수 있다.
#### 4.1. HTTP 리다이렉션
- 요청을 처리하는 서버(리다이렉팅 서버)는 가용한 것들 중 부하가 가장 적은 콘텐츠 서버를 찾아서 브라우저의 요청을 그 서버로 리다이렉트한다.
- 장점
  - 리다이렉트를 하는 서버가 클라이언트의 아이피 주소를 알기 때문에 좀 더 정보에 근거해 선택할 수 있다.
- 단점
  - 어떤 서버로 리다이렉트할지 결정하려면 원 서버는 상당히 많은 처리를 해야 한다.
  - 페이지에 접근할 때마다 두 번의 왕복이 필요하기 때문에, 사용자가 더 오래 기다리게 된다.
  - 리다이렉트 서버가 고장 나면, 사이트도 고장 난다.
- 이러한 약점 때문에, HTTP 리다이렉션은 보통 다른 리다이렉션 기법과 조합해 사용된다.
#### 4.2 DNS 리다이렉션
- DNS는 하나의 도메인에 여러 아이피 주소가 결부되는 것을 허용하며, DNS 분석자는 여러 아이피 주소를 반환하도록 설정되거나 프로그래밍 될 수 있다.
  - Domain Name System(DNS)는 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행 
- DNS 라운드 로빈
  - 가장 흔하고 단순한 리다이렉션 기법
  - 웹 서버 팜 전체에 대한 부하의 균형을 유지하기 위해 DNS 호스트 명 분석 기능을 사용한다.
    - 순수한 부하 균형 전략, 서버에 대한 클라이언트의 상대적인 위치나 서버의 현재 스트레스를 고려하지 않는다.
    - 대부분의 DNS 클라이언트는 다중 주소 집합의 첫 번째 주소를 사용한다. 부하 균형을 위해, 대부분의 DNS 서버는 룩업이 끝났을 때마다 주소를 순환시킨다.
- DNS 캐싱의 효과
  - DNS 주소 순환은 부하를 순환시키지만, 이 부하 균형은 완벽하지 않다.
    - DNS 룩업의 결과는 애플리케이션, 운영체제, 몇몇 기초적인 자식 DNS 서버에 의해 기억되어 재사용될 수 있기 때문
  - 비슷한 요청을 하는 클라이언트의 수가 어느 정도 이상만 된다면, 부하는 모든 서버에 걸쳐 상대적으로 잘 분산될 것이다.
- 다른 DNS 기반 리다이렉션 알고리즘
  - 부하 균형 알고리즘
    - 웹 서버의 로드를 추적하고 가장 로드가 적은 웹 서버를 목록의 가장 위에 놓는다.
  - 근접 라우팅 알고리즘
    - 웹 서버들의 팜이 지리적으로 분산되어 있는 경우, DNS 서버는 사용자를 근처의 웹 서버로 보내려는 시도를 할 수 있다.
  - 결함 마스킹 알고리즘
    - DNS 서버는 네트워크의 건강 상태를 모니터링하고 요청을 정전이나 기타 장애를 피해 라우팅할 수 있다.
  - 일반적으로, 복잡한 서버 추적 알고리즘을 실행하고 있는 DNS 서버는 콘텐츠 제공자의 통제하에 있는 권위 있는 서버(authoritative server)다.
    - 단점: 권위 있는 DNS 서버가 결정을 내리기 위해 사용하는 유일한 정보가 클라이언트의 IP 주소가 아닌 로컬 DNS 서버의 IP 주소
#### 4.3 임의 캐스트 어드레싱
- 임의 캐스트 어드레싱에서, 웹 서버들은 같은 아이피 주소를 갖고 클라이언트의 요청을 클라이언트에서 가장 가까운 서버로 보내주기 위해 백본 라우터의 '최단거리' 라우팅 능력에 의지한다.
- 웹 서버는 라우터 통신 프로토콜을 이용해 자신과 인접한 백본 라우터와 대화한다. 백본 라우터가 임의 캐스트 주소를 목적지로 하는 패킷을 받았을 때, 그것은 그 아이피 주소를 받아들일 수 있는 가장 가까운 '라우터'를 찾는다. 백본 라우터는 자신이 그 주소를 위한 라우터라고 광고한 서버에게 패킷을 보낸다.
- 여전히 실험적인 기법
  - 분산 임의 캐스트의 동작을 위해, 서버는 반드시 '라우터의 언어로 말해야 하고' 라우터는 일어날 수 있는 주소 충돌을 다룰 수 있어야 한다.
    - 적절하게 처리되지 않는다면, 이는 '라우팅 누수'(route leaks)를 유발할 수 있다.
#### 4.4 아이피 맥 포워딩
- 이더넷 네트워크에서, HTTP 메시지는 주소가 붙은 데이터 패킷의 형태로 보내진다.
  - 각 패킷은 레이어-4 주소(출발지와 목적지의 아이피 주소와 TCP 포트번호)와 레이어-2 주소(미디어 접근 컨트롤, Media Access Control, MAC)를 갖고 있다.
- 레이어-4를 이해하는 스위치는 레이어-4 주소를 검사해 이 정보에 근거해 라우팅을 할 수 있다.
- 레이어-2 장비는 들어오는 특정 맥(MAC) 주소의 패킷을 받아서 나가는 특정 맥 주소로 포워딩한다.
- 일반적으로 요청한 HTTP 콘텐츠가 캐시 안에 있고 신선하다면 프락시 캐시는 그것을 제공한다. 그렇지 않다면 프락시 캐시는 클라이언트를 대신해 그 콘텐츠를 가져오기 위한 HTTP 요청을 원 서버로 보낸다.
- 레이어-4 스위치는 요청을 여러 프락시 캐시로 보낼 수 있고 그들 사이의 부하 균형을 유지할 수 있다. 비슷하게 HTTP 트래픽은 대체 HTTP 서버로도 전달될 수 있다.
- MAC 주소 포워딩은 점 대 점으로만 가능하기 때문에, 서버나 프락시는 스위치와 한 홉 거리에 위치해야 한다.
#### 4.5 아이피 주소 포워딩
- 스위치나 다른 레이어-4 장비는 들어오는 패킷에 대해 TCP/IP 어드레싱을 검증하고 패킷을 목적지 맥 주소가 아니라 목적지 아이피 주소의 변경에 따라 라우팅한다.
  - 스위치에서 업스트림의 위치를 판별할 수만 있으면 일반적인 레이어-3 종단간(end-to-end) 인터넷 라우팅이 패킷을 올바른 위치로 보내준다.
  - 맥 포워딩과는 달리 목적지 서버가 한 홉 거리에 있을 필요가 없다.
  - 이러한 종류의 전달을 네트워크 주소 변환(Network Address Translation, NAT)이라고도 한다.
- 라우팅 대칭성 문제
  - 문제점: 클라이언트로부터 들어오는 TCP 커넥션을 받아주는 스위치는 그 커넥션을 관리하고 있다. 스위치는 반드시 그 커넥션을 통해 클라이언트에게 응답을 돌려줘야 한다. 그러므로 목적지 서버나 프락시로부터의 모든 응답은 반드시 그 스위치에 돌아가야 한다.
- 응답의 귀환 경로를 제어할 수 있는 방법
  - 패킷의 출발지 아이피 주소를 스위치의 아이피 주소로 바꾼다.
  - 만약 출발지의 아이피 주소가 그 클라이언트의 아이피 주소로 계속 남아있다면, 서버에서 클라이언트로 바로 가는 경로가 존재하지 않아야 한다.
#### 4.6 네트워크 구성요소 제어 프로토콜
- 네트워크 구성요소 제어 프로토콜(Network Element Control Protocol, NECP)
- NE-SE간 대화할 수 있게 해준다.
  - NE: 아이피 패킷을 전달하는 라우터나 스위치 같은 네트워크 구성요소
  - SE: 웹 서버나 프락시 캐시와 같이 애플리케이션 계층 요청을 처리하는 서버 구성요소
- 명시적으로 부하 균형을 지원하지는 않지만 SE가 NE에게 부하 균형 정보를 제공할 수 있는 방법을 제공해, SE가 적합하다고 판단한 대로 NE가 부하 균형을 유지할 수 있도록 한다.
- 예외에 대한 개념을 지원해 SE는 특정 출발지 아이피 주소가 서비스할 수 없다고 판단할 수 있으며, 그러한 경우 그 주소들을 NE로 보낼 수 있다. 그러면 NE는 그 아이피 주소로부터의 요청을 원 서버로 전달할 수 있다.
- 메시지 (p.537 - 538)

### 5. 프락시 리다이렉션 방법
- 웹 브라우저와 같은 클라이언트들은 어떻게 프락시로 가는 길을 아는가?
  - 명시적인 브라우저 설정
  - 동적인 자동 설정
  - 자연스러운 가로채기
#### 5.1 명시적 브라우저 설정
- 대부분의 브라우저에는 프락시 서버에 접촉하기 위해 프락시 이름, 아이피 주소, 포트번호를 설정할 수 있는 풀다운 메뉴가 존재한다. 사용자가 이를 설정하면 브라우저는 모든 요청에 대해 프락시와 접촉한다.
- 몇몇 서비스 제공자들은 미리 설정이 되어 있는 브라우저를 다운 받도록 한다. 이렇게 다운 받은 브라우저들은 접촉할 프락시의 주소를 알고 있다.
- 단점
  - 프락시들을 사용하도록 설정된 브라우저들은 프락시가 응답하지 않더라도 원 서버와 접촉하지 않는다. 만약 프락시가 다운되었거나 브라우저가 잘못 설정되었다면, 사용자는 접속 문제를 경험할 것이다.
  - 네트워크 아키텍처를 변경했을 때 그 변경사항을 모든 최종사용자에게 전파하는 것이 어렵다. 만약 서비스 제공자가 더 많은 프락시를 추가하길 원하거나 몇 개를 서비스에서 제거하길 원한다면, 브라우저 사용자들은 그들의 프락시 설정을 변경해야만 할 것이다.
#### 5.2 프락시 자동 설정
- 프락시 자동 설정(Proxy Auto-configuration, PAC) 프로토콜
- 기본 아이디어: 브라우저들이 URL별로 접촉해야 할 프락시를 지정한 PAC 파일이라 불리는 특별한 파일을 찾도록 하는 것
  - 브라우저는 반드시 PAC 파일을 얻기 위해 지정된 서버에 접촉하도록 설정되어야 한다. 그런 뒤에 브라우저는 재시작할 때마다 PAC 파일을 가져온다.
  - PAC 파일: `function FindProxyForUrl(url, host)` 함수를 반드시 정의해야 하는 자바스크립트 파일
    - 브라우저는 요청된 URL마다 이 함수를 호출한다.
    - 반환된 값은 브라우저가 어디서 이 URL을 요청해야 하는지 지정한 문자열이다. (접촉할 프락시들의 목록, "DIRECT"-브라우저가 어떤 프락시든 우회해서 원 서버로 바로 가야 함을 의미하는 문자열-)
#### 5.3 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol)
- 웹브라우저가 근처의 프락시를 찾아내 사용할 수 있게 해주는 방법을 제공
- PAC 파일 자동 발견



p. 561 ) 20.9.2
