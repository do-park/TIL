# 7. 캐시

- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치
- 혜택
  - 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다.
  - 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 된다.
  - 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.
  - 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리고 인한 지연을 줄여준다.

### 1. 불필요한 데이터 전송

### 2. 대역폭 병목

### 3. 갑작스런 요청 쇄도(Flash Crowds)

### 4. 거리로 인한 지연

### 5. 적중과 부적중

- 캐시에 요청이 도착했을 때, 만약 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리될 수 있다. 이것을 캐시 적중(cache hit)이라고 부른다. 만약 대응하는 사본이 없다면 그냥 원 서버로 전달되기만 할 뿐이다. 이를 캐시 부적중(cache miss)이라고 부른다.

#### 1. 재검사(Revalidation)

- 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다. 이러한 '신선도 검사'를 HTTP 재검사라 부른다.
- 대부분의 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 한다.
- 이를 재검사 적중 혹은 느린 적중이라고 부른다. 이것은 순수 캐시 적중보다 느린데, 원 서버와 검사를 할 필요가 있기 때문이다. 그러나 캐시 부적중보다는 빠른데, 서버로부터 객체 데이터를 받아 올 필요가 없기 때문이다.
- If-Modified-Since 헤더
  - 서버에 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미
  - **재검사 적중**
    - 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답을 보낸다.
  - **재검사 부적중**
    - 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보낸다.
  - **객체 삭제**
    - 만약 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 돌려보내며, 캐시는 사본을 삭제한다.

#### 2. 적중률

- 캐시가 요청을 처리하는 비율을 캐시 적중률(또는 캐시 적중비), 혹은 문서 적중률(혹은 문서 적중비)라고 부르기도 한다.
- 적중률은 0~1의 값으로 되어 있지만, 흔히 퍼센트로 표현되기도 한다.

#### 3. 바이트 적중률

- 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다. 이 측정값은 트래픽이 절감된 정도를 포착해낸다.
- 문서 적중률을 개선하면 전체 대기시간(지연)이 줄어든다. 바이트 단위 적중률은 얼마나 ㅁ낳은 바이트가 인터넷으로 나가지 않았는지 보여준다. 바이트 단위 적중률의 개선은 대역폭 절약을 최적화한다.

#### 4. 적중과 부적중의 구별

- HTTP 클라이언트에게 응답이 캐시 적중이었는지 아니면 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다.
- 클라이언트가 응답이 캐시에서 왔는지 알아내는 한 가지 방법은 Date 헤더를 이용하는 것이다. 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있다. 또 다른 방법은, 응답이 얼마나 오래되었는지 말해주는 Age 헤더를 이용하는 것이다.



### 6. 캐시 토폴로지

#### 1. 개인 전용 캐시

- 많은 에너지나 저장 공간을 필요로 하지 않으므로, 작고 저렴할 수 있다.
- 웹브라우저는 개인 전용 캐시를 내장하고 있다.

#### 2. 공용 프락시 캐시

- 캐시 프락시 서버 혹은 더 흔히 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버
- 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입장에서 서버에 접근한다.
- 공용 캐시에는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다.

#### 3. 프락시 캐시 계층들

- 작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 '걸러 남겨진' 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많다.
- 클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용하자는 것이다.

#### 4. 캐시망, 콘텐츠 라우팅, 피어링

- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은
  - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
  - URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.
  - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아본다.
  - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓(internet transit)은 허용하지 않는다.
- 한층 더 복잡한 캐시 사이의 관계는, 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 해준다. 선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불린다.
- HTTP는 형제 캐시를 지원하지 않기 때문에, 사람들은 인터넷 캐시 프로토콜(ICP)이나 하이퍼텍스트 캐시 프로토콜(HTCP) 같은 프로토콜을 이용해 HTTP를 확장했다.



### 7. 캐시 처리 단계

- 기본적인 캐시 처리 절차
  1. 요청 받기: 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.
  2. 파싱: 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.
  3. 검색: 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다. (그리고 로컬에 저장한다)
  4. 신선도 검사: 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.
  5. 응답 생성: 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
  6. 발송: 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
  7. 로깅: 선택적으로 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.



### 8. 사본을 신선하게 유지하기

#### 1. 문서 만료

- HTTP는 Cache-Control과 Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.
- 캐시 문서가 만료되기 전에, 캐시는 필요하다면 서버와의 접촉 없이 사본을 제공할 수 있다. 그러나 일단 캐시된 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야 하며, 만약 그렇다면 신선한 사본을 얻어 와야 한다. (유효기간과 함께)

#### 2. 유효기간과 나이

- 서버는 응답 본문과 함께 하는 응답 헤더를 이용해서 유효기간을 명시한다.
  - `Cache-control: max-age`: 문서의 최대 나이를 정의. 최대 나이는 문서가 처음 생성된 이후부터, 제공하기엔 더 이상 신선하지 않다고 간주할 때까지 경과한 시간의 합법적인 최댓값(초 단위)
  - `Expires`: 절대 유효기간을 명시. 유효기간이 경과했다면, 그 문서는 더 이상 신선하지 않다.

#### 3. 서버 재검사

- 캐시된 문서가 만료되었다는 것은, 그 문서가 원 서버에 현재 존재하는 것과 실제로 다르다는 것이 아니라, 검사할 시간이 되었음을 뜻한다. 이 검사를 '서버 재검사'라고 부른다.
- 재검사 결과 콘텐츠가 변경되었다면, 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다.
- 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.
- HTTP 프로토콜은 캐시가 다음 중 하나를 반환하는 적절한 행동을 할 것을 요구한다.
  - '충분히 신선한' 캐시된 사본
  - 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
  - 에러 메시지(재검사해야 하는 원 서버가 다운된 경우)
  - 경고 메시지가 부착된 캐시된 사본(부정확하다면)

#### 4. 조건부 메서드와의 재검사

- 조건부 GET은 GET 요청 메시지에 특별한 조건부 헤더를 추가함으로써 시작된다. 웹 서버는 조건이 참인 경우에만 객체를 반환한다.
- 조건부 헤더
  - `If-Modified-Since: <date>`: 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리
  - `If-None-Match: <tags>`: 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공. 캐시된 태그가 서버에 있는 문서의 태그와 다를 때만 요청을 처리한다.

#### 5. If-Modified-Since: 날짜 재검사

- IMS 요청, 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.

#### 6. If-None-Match: 엔터티 태그 재검사

- 최근 변경 일시 재검사가 어려운 상황에서 사용

#### 7. 약한 검사기와 강한 검사기

- HTTP/1.1은 비록 콘텐츠가 조금 변경되었더라도 '그 정도면 같은 것'이라고 서버가 주장할 수 있게 해주는 '약한 검사기(weak validator)'를 제공한다.
- 강한 검사기(strong validator)는 콘텐츠가 바뀔 때마다 바뀐다.

#### 8. 언제 엔터티 태그를 사용하고 언제 Last-Mondified 일시를 사용하는가

- HTTP/1.1 클라이언트는 만약 서버가 엔터티 태그를 반환했다면, 반드시 엔터티 태그 검사기를 사용해야 한다. 만약 서버가 Last-Modified 값만을 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있다. 만야 ㄱ엔터티 태그와 최근 변경 일시가 모두 사용 가능하다면, HTTP/1.0과 HTTP/1.1 캐시 모두 적절히 응답할 수 있도록 클라이언트는 각각을 위해 두 가지의 재검사 정책을 모두 사용해야 한다.
- HTTP/1.1 원 서버는 실현 불가능하지만 않다면 엔터티 태그 검사기를 보내야 하며, 이점이 있다면 강한 엔터티 태그 대신 약한 엔터티 태그를 보낼 수도 있다. 또한 lAST-mODIFIED 값을 같이 보내는 것도 선호한다.
- 만약 HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를 모두 받았다면, 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 304 Not Modified 응답을 반환해서는 안 된다.



### 9. 캐시 제어

- http는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 가지 방법들을 정의한다. 우선순위대로 나열해보면 서버는
  - Cache-Control: no-store 헤더를 응답에 첨부할 수 있다.
  - Cache-Control: no-cache 헤더를 응답에 첨부할 수 있다.
  - Cache-Control: must-revalidate 헤더를 응답에 첨부할 수 있다.
  - Cache-Control: max-age 헤더를 응답에 첨부할 수 있다.
  - Expires 날짜 헤더를 응답에 첨부할 수 있다.
  - 아무 만료 정보도 주지 않고, 캐시가 스스로 체험적인(휴리스틱) 방법으로 결정하게 할 수 있다.

#### 1. no-cache와 no-store 응답 헤더



