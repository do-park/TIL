### 3) HTTP 메시지

> HTTP가 인터넷의 배달원이라면, HTTP 메시지는 무언가를 담아 보내는 소포와 같다.

#### 3.1 메시지의 흐름

- HTTP  메시지: HTTP 애플리케이션 간에 주고받은 데이터의 블록들. 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다.

1. 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
   - HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다. 메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것이다.
2. 다운스트림으로 흐르는 메시지
   - 요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다. 메시지의 발송자는 수신자의 업스트림이다.

#### 3.2 메시지의 각 부분

- HTTP 메시지는 단순한, 데이터의 구조화된 블록이다.
- 각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함한다. 메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어진다. 시작줄은 이것이 어떤 메시지인지를 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있다. 본문은 아예 없을 수도 있다.
- 시작줄과 헤더
  - 줄 단위로 분리된 아스키 문자열
  - 각 줄은 캐리지 리턴과 개행 문자로 구성된 두 글자의 줄바꿈 문자열으로 끝난다. 이 줄바꿈 문자열을 CRLF라고 쓴다.
- 엔터티 본문이나 메시지 본문(본문)
  - 단순히 선택적인 데이터 덩어리
  - 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있다.

1. 메시지 문법

   - 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다. 요청 메시지는 웹 서버에 어떤 동작을 요구한다. 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다. 요청과 응답 모두 기본적으로 구조가 같다.

   - 요청 메시지의 형식

     ```
     <메서드> <요청 URL> <버전>
     <헤더>
     
     <엔터티 본문>
     ```

   - 응답 메시지의 형식

     ```
     <버전> <상태 코드> <사유 구절>
     <헤더>
     
     <엔터티 본문>
     ```

   - **메서드**: 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작. 'GET', 'HEAD', 'POST'와 같이 한 단어로 되어 있다.

   - **요청 URL**: 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소. 완전한 URL이 아닌 URL의 경로 구성요소라고 해도, 클라이언트가 서버와 직접 대화하고 있고 경로 구성요소가 리소스를 가리키는 절대 경로이기만 하면 대체로 문제가 없다. 서버는URL에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주할 것이다.
   
   - **버전**: `HTTP/<메이저>.<마이너>` 메이저와 마이너는 모두 정수다.
   
   - **상태 코드**: 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자. 첫 번째 자릿수는 상태의 일반적인 분류('성공', '에러' 등)
   
   - **사유 구절(reason-phrase)**: 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구. 상태 코드 이후부터 줄바꿈 문자열까지.
   
   - **헤더들**: 이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타내는 0개 이상의 헤더들. 이 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다. HTTP/1.1과 같은 몇몇 버전의 HTTP는 요청이나 응답에 어떤 특정 헤더가 포함되어야만 유효한 것으로 간주한다.
   
   - **엔터티 본문**: 임의의 데이터 블록을 포함. 모든 메시지가 엔터티 본문을 갖는 것은 아님. (CRLF로 끝나는 메시지도 존재) 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄(CRLF)로 끝나야 함.
   
2. 시작줄

   - 모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지의 시작줄은 무엇을 해야 하는지, 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

   - **요청줄**
     
     - 요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다. 요청 메시지의 시작줄, 혹은 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다. 또한 요청줄은 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에게 알려주는 HTTP 버전도 포함한다.
     - 이 모든 필드는 공백으로 구분된다.
     
   - **응답줄**

     - 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다. 응답 메시지의 시작줄 혹은 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어 있다.
     - 이 모든 필드는 공백으로 구분된다.

   - **메서드**

     - 요청의 시작줄은 메서드로 시작하며, 서버에서 무엇을 해야 하는지 말해준다.

     - HTTP 명세는 공통 요청 메서드의 집합을 정의한다.

     - 많이 쓰이는 HTTP 메서드

       | 메서드  | 설명                                                    | 메시지 본문 유무 |
       | ------- | ------------------------------------------------------- | ---------------- |
       | GET     | 서버에서 어떤 문서를 가져온다.                          | 없음             |
       | HEAD    | 서버에서 어떤 문서에 대해 헤더만 가져온다.              | 없음             |
       | POST    | 서버가 처리해야 할 데이터를 보낸다.                     | 있음             |
       | PUT     | 서버에 요청 메시지의 본문을 저장한다.                   | 있음             |
       | TRACE   | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. | 없음             |
       | OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다.         | 없음             |
       | DELETE  | 서버에서 문서를 제거한다.                               | 없음             |

       - HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에, 다른 서버는 그들만의 메서드를 추가로 구현했을 수도 있다. → 확장 메서드

   - **상태 코드**

     - 클라이언트에게 무엇이 일어났는지 말해준다. 상태 코드는 응답의 시작줄에 위치한다.

     - 각 응답 메시지의 시작줄에 담겨 반환된다.

     - 사유 구절은 사람에게 쉽게 읽히는 한편, 숫자로 된 코드는 프로그램이 에러를 처리하기 쉽다.

     - 상태 코드의 종류

       | 전체 범위 | 정의된 범위 | 분류            |
       | --------- | ----------- | --------------- |
       | 100-199   | 100-101     | 정보            |
       | 200-299   | 200-206     | 성공            |
       | 300-399   | 300-305     | 리다이렉션      |
       | 400-499   | 400-415     | 클라이언트 에러 |
       | 500-599   | 500-505     | 서버 에러       |

     - 많이 쓰는 상태 코드들

       | 상태 코드 | 사유 구절    | 의미                                               |
       | --------- | ------------ | -------------------------------------------------- |
       | 200       | OK           | 성공! 요청한 모든 데이터는 응답 본문에 들어있다.   |
       | 401       | Unauthorized | 사용자 이름과 비밀번호를 입력해야 한다.            |
       | 404       | Not Found    | 서버는 요청한 URL에 해당하는 리소스를 찾지 못했다. |

   - **사유 구절**

     - 응답 시작줄의 마지막 구성요소. 상태 코드에 대한 글로 된 설명을 제공
     - 상태 코드와 일대일로 대응. 애플리케이션 개발자들이 그들의 사용자에게 요청 중에 무슨 일이 일어났는지를 알려주기 위해 넘겨줄 수 있는, 상태 코드의 사람이 이해하기 쉬운 버전

   - **버전 번호**

     - HTTP/x.y 형식으로 요청과 응답 메시지 양쪽에 모두 기술
     - HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단
     - 버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킨다.
       - 버전 번호는 분수로 다루어지지 않는다. 버전의 각 숫자는 각각 분리된 숫자로 다루어진다. 따라서 어느 쪽이 큰지 HTTP 버전을 비교할 때 각 숫자는 반드시 따로따로 비교해야 한다.
         - HTTP/2.22 > HTTP/2.3: 22가 3보다 크기 때문

3. 헤더

   - 요청과 응답의 시작줄 다음에는 0, 1개 혹은 여러개의 HTTP 헤더가 온다.
   - HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 그들은 기본적으로 이름/값 쌍의 목록이다.

   - **헤더 분류**

     - HTTP 헤더 명세는 여러 헤더 필드를 정의한다. 애플리케이션은 또한 자유롭게 자신만의 헤더를 만들어낼 수 있다.
     - 분류
       - 일반 헤더: 요청과 응답 양쪽에 모두 나타날 수 있음
       - 요청 헤더: 요청에 대한 부가 정보를 제공
       - 응답 헤더: 응답에 대한 부가 정보를 제공
       - Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
       - 확장 헤더: 명세에 정의되지 않은 새로운 헤더

   - **헤더를 여러 줄로 나누기**

     - 긴 헤더 줄은 여러 줄로 쪼개서 더 읽기 좋게 만들 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 한다.

     - ```
       HTTP/1.0 200 OK
       Content-Type: image/gif
       Content-Length: 8572
       Server: Test Server
       	Version 1.0
       ```

       - Server헤더의 완전한 값은 `Test Server Version 1.0`

4. 엔터티 본문

   - HTTP 메시지의 세 번째 부분. 선택적인 엔터티 본문
   - HTTP 메시지의 화물

5. 버전 0.9 메시지

   - HTTP 버전 0.9는 HTTP 프로토콜의 초기 버전이다.  오늘날 HTTP가 갖고 있는 요청과 응답 메시지의 시초이지만, 훨씬 단순한 프로토콜로 되어 있다.
   - 요청과 응답으로 이루어져 있지만, 요청은 그저 메시지와 요청 URL을 갖고 있을 뿐이며, 응답은 오직 엔터티로만 되어 있다. 버전 정보도 없고, 상태 코드나 사유 구절도 없으며, 헤더도 포함되어 있지 않다.
   - 단순하기 때문에 다양한 상황에 대응할 수 없으며 HTTP의 기능들과 애플리케이션들도 대부분 구현할 수 없다.

#### 3.3 메서드

- 모든 서버가 모든 메서드를 구현하지는 않는다.

1. 안전한 메서드(Safe Method)
   - GET, HEAD: GET, HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음
     - 작용이 없다: HTTP 요청의 결과로 인해 서버에서 일어나는 일이 아무것도 없음
   - 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없다. 안전한 메서드의 목적은, 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다.
   
2. GET
   
   - 가장 흔히 쓰이는 메서드. 주로 서버에게 리소스를 달라고 요청하기 위해 사용
   
3. HEAD
   - GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다.
   - 리소스를 가져오지 않고도 그에 대해 무엇인가(타입 등)를 알아낼 수 있다.
   - 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
   - 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.
   - 서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.
   
4. PUT
   - 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체한다.
   - 콘텐츠를 변경할 수 있게 해주기 때문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구한다.
   
5. POST
   
   - 서버에 입력 데이터를 전송하기 위해 설계, HTML 폼을 지원하기 위해 흔히 사용
   
6. TRACE
   - 클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있다. 이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다.
   - TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
     - 목적지에서 루프백(loopback) 진단을 시작한다. 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다. 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.
   - TRACE 메서드는 주로 진단을 위해 사용된다. 
   - 중간 애플리케이션이 여러 다른 종류의 요청들을 일관되게 다룬다고 가정하는 문제가 있다.
   - 어떠한 엔터티 본문도 보낼 수 없다. TRACE 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어있다.
   
7. OPTIONS

   - 여러 리소스에 대해 실제로 접근하지 않고도 그것들을 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트 애플리케이션에게 제공한다.

8. DELETE

   - 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다. 그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.

9. 확장 메서드

   - HTTP에 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.

   - 확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드다.

   - 대표적인 예

     | 메서드 | 설명                                                         |
     | ------ | ------------------------------------------------------------ |
     | LOCK   | 사용자가 리소스를 잠글 수 있게 해준다. 예를 들어, 문서를 편집하는 동안 다른 사람이 동시에 같은 문서를 편집하지 못하도록 문서를 잠글 수 있다. |
     | MKCOL  | 사용자가 문서를 생성할 수 있게 해준다.                       |
     | COPY   | 서버에 있는 리소스를 복사한다.                               |
     | MOVE   | 서버에 있는 리소스를 옮긴다.                                 |

   - 확장 메서드(그리고 대부분의 HTTP 확장)를 다룰 때는 "엄격하게 보내고 관대하게 받아들여라"라는 오랜 규칙에 따르는 것이 좋다.

#### 4. 상태 코드

1. 100-199: 정보성 상태 코드

   - HTTP/1.1에서 도입

   - 비교적 새로운 것. 복잡함을 감수할 만한 가치가 있는지에 대해 논란

   - 정보성 상태 코드와 사유 구절

     | 상태 코드 | 사유 구절           | 의미                                                         |
     | --------- | ------------------- | ------------------------------------------------------------ |
     | 100       | Continue            | 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미한다. 이것을 보낸 후, 서버는 반드시 요청을 받아 응답해야 한다. |
     | 101       | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다. |

   - 클라이언트와 100 Continue

     - 100-continue는 최적화를 위한 것. 클라이언트 애플리케이션은 100-continue를 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야 한다.
     - 100-continue 값이 담긴 Expect 헤더를 보낸 클라이언트는 서버가 100 Continue 응답을 보내주기를 기다리다가, 약간의 타임아웃 후에 그냥 엔터티를 보내야 한다.
     - 클라이언트 개발자는 예상하지 못한 100 Continue 응답에도 대비해야 한다. 몇몇 잘못 만들어진 http 애플리케이션은 이 코드를 부적절하게 보낸다.

   - 서버와 100 Continue
   
     - 서버가 100-continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, 100 Continue 응답 혹은 에러 코드로 답해야 한다. 서버는 절대로 100-continue 응답을 받을 것을 의도하지 않은 클라이언트에게 100 continue 상태 코드를 보내서는 안 된다.
     - 서버가 100 Continue 응답을 보낼 기회를 갖기 전에 어떤 이유로 인해 엔터티의 일부(혹은 전체)를 수신하였다면, 서버는 이 상태 코드를 보낼 필요가 없다. 그러나 서버가 요청을 끝까지 다 읽은 후에는 그 요청에 대한 최종 응답을 보내야 한다.
     - 서버가 100 continue 응답을 받을 것을 의도한 요청을 받고 난 상태에서 엔터티 본문을 읽기 전에 요청을 끝내기로 결정했다면(에러 등의 이유로), 서버는 응답을 보내고 연결을 닫아서는 안 된다. 클라이언트가 응답을 받을 수 없게 되기 때문이다.
     
   - 프락시와 100 Continue
   
     - 클라이언트로부터 100-continue 응답을 의도한 요청을 받은 프락시가 해야 할 일
       - 다음 홉(next-hop) 서버가 HTTP/1.1을 따르거나 혹은 어떤 버전을 따르는지 모른다면, Expect 헤더를 포함시켜서 요청을 다음으로 전달. 이전 버전의 HTTP를 따른다는 것을 알고 있다면, 프락시는 417 Expected Failed 에러로 응답해야 함
       - HTTP/1.0이나 이전 버전을 따르는 클라이언트를 대신하여 Expect 헤더와 100-continue 값을 요청에 포함시키기로 결정했다면, 프락시는 100 Continue 응답을 클라이언트에 전달해서는 안 된다. 왜냐하면 클라이언트를 그것을 어떻게 해야 할지 모를 것이기 때문이다.
       - 프락시가 다음 홉 서버들에 대한 상태 몇 가지와 그들이 지원하는 HTTP 버전을 기억해둔다면, 100-continue 응답을 기대한 요청을 더 잘 다룰 수 있게 되므로 프락시에게 이득이 된다.
   
2. 200-299: 성공 상태 코드

   | 상태 코드 | 사유 구절                     | 의미                                                         |
   | --------- | ----------------------------- | ------------------------------------------------------------ |
   | 200       | OK                            | 요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다. |
   | 201       | Created                       | 서버 객체를 생성하라는 요청(ex. PUT)을 위한 것. 응답은, 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 그 리소스를 참조할 수 있는 여러 URL을 엔터티 본문에 포함해야 한다.<br />서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 한다. |
   | 202       | Accept                        | 요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. 서버가 요청의 처리를 완료할 것인지에 대한 어떤 보장도 없다. 이것은 단지 요청이 받아들이기에 적법해 보인다는 의미일 뿐이다.<br>서버는 엔터티 본문에 요청에 대한 상태와 가급적이면 요청의 처리가 언제 완료될 것인지에 대한 추정(혹은 그에 대한 정보를 어디서 얻을 수 있는지)도 포함해야 한다. |
   | 203       | Non-Authoritative Information | 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. 중개자가 리소스의 사본을 갖고 있었지만 리소스에 대한 메타 정보(헤더)를 검증하지 못한(혹은 안 한) 경우 이런 일이 발생할 수 있다.<br />이 응답 코드는 필수적으로 사용되어야 하는 것은 아니다. 이것은 엔터티 헤더가 원래 서버에서 온 것이었다면 응답이 200 상태였을 애플리케이션을 위한 선택사항이다. |
   | 204       | No Content                    | 응답 메시지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함하지 않는다. 주로 웹브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때 사용한다. |
   | 205       | Reset Content                 | 주로 브라우저를 위해 사용되는 또 하나의 코드. 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말한다. |
   | 206       | Partial Content               | 부분 혹은 범위 요청이 성공했다. 나중에 우리는 클라이언트가 특별한 헤더를 사용해서 문서의 부분 혹은 특정 범위를 요청할 수 있다는 것을 보게 될 것이다. 이 상태 코드는 범위 요청이 성공했음을 의미한다. <br />206 응답은 Content-Range와 Data 헤더를 반드시 포함해야 하며, Etag와 Content-Location 중 하나의 헤더도 반드시 포함해야 한다. |

   - c.f. p.70 오타
     - 상태코드 201: 서버 개체 > 서버 객체
     - 상태코드 206: Content-Rage > Content-Range

3. 300-399: 리다이렉션 상태 코드

   - 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다. 리소스가 옮겨졌으며 어디서 찾을 수 있는지 알려주기 위해 리다이렉션 상태 코드와 (선택적으로) Location  헤더를 보낼 수 있다. 이는 브라우저가 사용자를 귀찮게 하지 않고 알아서 새 위치로 이동할 수 있게 해준다.

   - 일반적으로, HEAD가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때, 리다이렉트될 URL에 대한 링크와 설명을 포함하는 것은 좋은 습관이다.

     | 상태 코드 | 사유 구절          | 의미                                                         |
     | --------- | ------------------ | ------------------------------------------------------------ |
     | 300       | Multiple Choices   | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환한다. 사용자는 목록에서 원하는 하나를 선택할 수 있다. 서버는 Location 헤더에 선호하는 URL을 포함할 수 있다. |
     | 301       | Moved Permanently  | 요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다. |
     | 302       | Found              | 301 상태 코드와 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요청에서는 원래 URL을 사용해야 한다. |
     | 303       | See Other          | 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때 쓰인다. 새 URL은 응답 메시지의 Location 헤더에 들어있다. 이 상태 코드의 주 목적은 POST 요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려주는 것이다. |
     | 304       | Not Modified       | 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다. 만약 클라이언트가 GET과 같은 조건부 요청을 보냈고 그 요청한 리소스가 최근에 수정된 일이 없다면, 이 코드는 리소스가 수정되지 않았음을 의미하게 된다. 이 상태 코드를 동반한 응답은 엔터티 본문을 가져서는 안 된다. |
     | 305       | Use Proxy          | 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용한다. 프락시의 위치는 Location 헤더를 통해 주어진다. 클라이언트는 이 응답을 특정 리소스에 대한 것이라고만 해석한다. 클라이언트는 모든 요청에 대해 이 프락시를 통해야 한다고 상정하지 않으며, 그 리소스를 갖고 있는 서버에 대한 요청이라 할지라도 마찬가지다. 프락시가 요청에 잘못 간섭한다면 오동작을 유발할 수 있고, 보안 문제를 일으킬 수 있다. |
     | 306       | -                  | 현재는 사용되지 않는다.                                      |
     | 307       | Temporary Redirect | 301 상태 코드와 비슷하다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요청에서는 원래 URL을 사용해야 한다. |

4. 400-499: 클라이언트 에러 상태 코드

   | 상태 코드 | 사유 구절                       | 의미                                                         |
   | --------- | ------------------------------- | ------------------------------------------------------------ |
   | 400       | Bad Request                     | 클라이언트가 잘못된 요청을 보냈다고 말해준다.                |
   | 401       | Unauthorized                    | 리소스를 얻기 전에 클라이언트에게 스스로를 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환한다. |
   | 402       | Payment Required                | 현재 이 상태 코드는 쓰이지 않지만, 미래에 사용될 가능성을 위해 준비해 두었다. |
   | 403       | Forbidden                       | 요청이 서버에 의해 거부되었음을 알려주기 위해 사용한다. 만약 서버가 왜 요청이 거부되었는지 알려주고자 한다면, 서버는 그 이유를 설명하는 엔터티 본문을 포함할 수 있다. 그러나 이 코드는 보통 서버가 거절의 이유를 숨기고 싶을 때 사용한다. |
   | 404       | Not Found                       | 서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용한다. 종종, 클라이언트 애플리케이션이 사용자에게 보여주기 위한 엔터티가 포함된다. |
   | 405       | Method Not Allowed              | 요청한 URL에 대해, 지원하지 않는 메서드로 요청받았을 때 사용한다. 요청한 리소스에 대해 어떤 메서드가 사용 가능한지 클라이언트에게 알려주기 위해, 요청에 Allow 헤더가 포함되어야 한다. |
   | 406       | Not Acceptable                  | 클라이언트는 자신이 어떤 종류의 엔터티를 받아들이고자 하는지에 대해 매개변수로 명시할 수 있다. 이 코드는 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용한다. 종종 서버는 클라이언트에게 왜 요청이 만족될 수 없었는지 알려주는 헤더를 포함시킨다. |
   | 407       | Proxy Authentication Required   | 401 상태 코드와 같으나, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용한다. |
   | 408       | Request Timeout                 | 클라이언트의 요청을 완수하기에 시간이 너무 많이 걸리는 경우, 서버는 이 상태 코드로 응답하고 연결을 끊을 수 있다. 이 타임아웃의 길이는 서버마다 다르지만 대개 어떠한 적법한 요청도 받아들일 수 있을 정도로 충분히 길다. |
   | 409       | Conflict                        | 요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용한다. 서버는 요청이 충돌을 일으킬 염려가 있다고 생각될 때 이 요청을 보낼 수 있다. 응답은 충돌에 대해 설명하는 본문을 포함해야 한다. |
   | 410       | Gone                            | 404와 비슷하나, 서버가 한때 그 리소스를 갖고 있었다는 점이 다른다. 주로 웹 사이트를 유지보수하면서, 서버 관리자가 클라이언트에게 리소스가 제거된 경우 이를 알려주기 위해 사용한다. |
   | 411       | Length Required                 | 서버가 요청 메시지에 Content-Length 헤더가 있을 것을 요구할 때 사용한다. |
   | 412       | Precondition Failed             | 클라이언트가 조건부 요청을 했는데 그중 하나가 실패했을 때 사용한다. 조건부 요청은 클라이언트가 Expect 헤더를 포함했을 때 발생한다. |
   | 413       | Request Entity Too Large        | 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 크기의 요청을 클라이언트가 보냈을 때 사용한다. |
   | 414       | Request URI Too Long            | 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 길이의 요청 URL이 포함된 요청을 클라이언트가 보냈을 때 사용한다. |
   | 415       | Unsupported Media Type          | 서버가 이해하거나 지원하지 못하는 내용 유형의 엔터티를 클라이언트가 보냈을 때 사용한다. |
   | 416       | Requested Range Not Satisfiable | 요청 메시지가 리소스의 특정 범위를 요청했는데 그 범위가 잘못되었거나 맞지 않을 때 사용한다. |
   | 417       | Expectation Failed              | 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨있는 경우 사용한다. 프락시나 다른 중개자 애플리케이션은, 원 서버가 요청의 기대를 만족시킬 수 없을 명확한 증거가 있다면 이 응답 코드를 전송할 수 있다. |

5. 500-599: 서버 에러 상태 코드

   | 상태코드 | 사유 구절                  | 의미                                                         |
   | -------- | -------------------------- | ------------------------------------------------------------ |
   | 500      | Internal Server Error      | 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용    |
   | 501      | Not Implemented            | 클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용          |
   | 502      | Bad Gateway                | 프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용 |
   | 503      | Service Unavable           | 현재는 서버가 요청을 처리해 줄 수 없지만 나중에는 가능함을 의미. Retry-After 헤더에 서버가 언제 그 리소스를 사용할 수 있게 될지를 포함할 수 있다. |
   | 504      | Gateway Timeout            | 상태 코드 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다르다. |
   | 505      | HTTP Version Not Supported | 서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프토토콜로 된 요청을 받았을 때 사용 |

   
