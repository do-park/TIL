# 45. 프로미스

- 자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다. 하지만 전통적인 콜백 패턴은 콜백 헬로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한 번에 처리하는 데도 한계가 있다.
- ES6에서는 비동기 처리를 위한 또 다른 패턴으로 프로미스를 도입했다. 프로미스는 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.



### 1. 비동기 처리를 위한 콜백 패턴의 단점

1. 콜백 헬
   - 비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없다. 따라서 비동기 함수의 처리 결과(서버의 응답 등)에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다. 이때 비동기 함수를 범용적으로 사용하기 위해 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 수행하는 콜백 함수를 전달하는 것이 알반적이다. 필요에 따라 비동기 처리가 성공하면 호출될 콜백 함수와 비동기 처리가 실패하면 호출될 콜백 함수를 전달할 수 있다.
   - 콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또다시 비동기 함수를 호출해야 한다면 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상이 발생하는데, 이를 **콜백 헬**이라 한다.
2. 에러 처리의 한계
   - 비동기 처리를 위한 콜백 패턴의 문제점 중 가장 심각한 것은 에러 처리가 곤란하다는 것
   - try ... catch ... finally 문
     - 에러 처리를 구현하는 방법
     - 우선 try 코드 블록이 실행되고, 이때 try 코드 블록에 포함된 문 중에서 에러가 발생하면 해당 에러는 catch 문의 err 변수에 전달되고 catch 코드 블록이 실행된다. finally 코드 블록은 에러 발생과 상관없이 반드시 한 번 실행된다.
     - 이렇게 에러를 처리하면 프로그램이 강제 종료되지 않는다.
   - **에러는 호출자 방향으로 전파된다.**



### 2. 프로미스의 생성

- Promise 생성자 함수를 new 연산자와 함께 호출하면 프로미스(Promise 객체)를 생성한다. Promise는 호스트 객체가 아닌 표준 빌트인 객체.
- Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수(ECMAScript 사양에서는 executor 함수라고 부른다)를 인수로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받는다.
- Promise의 상태(state) 정보
  - pending: 비동기 처리가 아직 수행되지 않은 상태, 프로미스 생성 직후 기본 상태
  - fulfilled: 비동기 처리가 수행된 상태(성공), resolve 함수가 호출된 상태
  - rejected: 비동기 처리가 수행된 상태(실패), rejected 함수가 호출된 상태
- **프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체**



### 3. 프로미스의 후속 처리 메서드

- 프로미스의 비동기 처리 상태가 변화하면 이에 따른 후속 처리를 해야 한다.
- 이를 위해 프로미스는 후속 메서드 then, catch, finally를 제공한다.
- **프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다.**

1. Promise.prototype.then