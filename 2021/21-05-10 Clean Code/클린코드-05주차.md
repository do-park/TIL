# 9. 단위 테스트

1. TDD 법칙 세 가지
   1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
   2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
   3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
   
2. 깨끗한 테스트 코드 유지하기
   
   - 테스트 코드는 실제 코드 못지 않게 중요하다.
   
3. 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
   
   - 테스트 커버리지가 높을수록 공포는 줄어든다.
   
4. 깨끗한 테스트 코드

   - 실제 코드보다 테스트 코드에서 가독성은 더 중요하다.
   - 명료성, 단순성, 풍부한 표현력
   - 최소의 표현으로 많은 것을 나타내야 한다.
   - 이중 표준
     - 실제 환경에서는 안 되지만 테스트 환경에서는 전혀 문제없는 방식이 있다. (메모리나 CPU 효율과 관련 있는 경우)

5. 테스트 당 assert 하나

   - 개념 당 assert 문 수를 최소로 줄여라

   - 테스트 함수마다 한 개념만 테스트하라

6. F.I.R.S.T

   - 깨끗한 테스트가 지켜야 할 규칙

   1. Fast: 테스트는 빨라아 한다. 테스트가 느리면 자주 돌릴 엄두를 못 낸다. 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다. 코드를 마음껏 정리하지도 못한다. 결국 코드 품질이 망가지기 시작한다.
   2. Independent: 각 테스트는 서로 의존하면 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다.
   3. Repeatable: 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 네트워크에 연결되지 않은 노트북 환경에서도 실행할 수 있어야 한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다. 게다가 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황에 직면한다.
   4. Self-Validating: 테스트는 부울bool값으로 결과를 내야 한다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다.
   5. Timely: 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 



# 10. 클래스

- 클래스 체계
  - 변수 목록
    - static public 상수
    - static private 변수
    - private 인스턴스 변수
  - 공개 함수
    - 비공개 함수는 자신을 호출하는 공개 함수 직후 → 추상화 단계가 순차적으로 내려간다
  - 캡슐화
    - 같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 그 함수나 변수를 protected로 선언하거나 패키지 전체로 공개한다. 하지만 그 전에 비공개 상태를 유지할 온갖 방법을 강구한다. 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

1. 클래스는 작아야 한다.
   - 클래스 이름은 해당 클래스 책임을 기술해야 한다. 간결한 이름이 떠오르지 않는다면 클래스 크기가 너무 커서 그렇다.
   - 클래스 설명은 만일(if), 그리고(and), -하며(or), 하지만(but)을 사용하지 않고 25단어 내외로 가능해야 한다.
   - 단일 책임 원칙Single Responsibility Principle, SRP
     - 클래스나 모듈을 변경할 이유는 하나뿐이어야 한다.
     - 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바랍직하다. 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.
   - 응집도Cohension
     - 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.
   - 응집도를 유지하면 작은 클래스 여럿이 나온다
     - 클래스가 응집력을 잃는다면 쪼개라
2. 변경하기 쉬운 클래스
   - 클래스 일부에서만 사용되는 비공개 메서드는 코드를 개선할 잠재적인 여지를 시사한다. 하지만 실제로 개선에 뛰어드는 계기는 시스템이 변해서라야 한다.
   - 변경으로부터 격리
     - 구체적인concrete 클래스와 추상abstract 클래스가 있고, 구체적인 클래스는 상세한 구현(코드)를 포함하며 추상 클래스는 개념만 포함한다. 상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다. 그래서 우리는 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.
     - 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다. 결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 의미다. 시스템 요소가 서로 잘 격리되어 있으면 각 요소를 이해하기도 쉬워진다.
     - 결합도를 최소로 줄이면 자연스럽게 또 다른 클래스 설계 원칙인 DIP(Depending Inversion Principle)를 따르는 클래스가 나온다. 본질적으로 DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.