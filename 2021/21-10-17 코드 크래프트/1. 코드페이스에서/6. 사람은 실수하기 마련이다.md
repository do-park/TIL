# 6. 사람은 실수하기 마련이다

> 불가피한 상호아에 대처하기 - 코드 속 오류 상황



### 6.1 오류가 시작되는 곳

- 오류는 발생 전에 미리 **알고** 있다는 점에서 불완전한 프로그램에서 비롯되는 버그와는 엄연히 다르다.
- 이러한 오류 상황을 처리하는 코드를 작성해 놓지 않으면 언젠가 반드시 **버그**가 발생하고 프로그램이 의도대로 동작하지 못하는 상황이 온다. 하지만 오류가 드물게 발생하면 버그를 감지하기 상당히 힘들다.
- 오류의 원인
  1. 사용자 오류
  2. 프로그래머 오류
  3. 이례적 상황
- 누군가는 오류가 발생했음을 알리고 행동해야 한다.
- 프로그램 실행을 제어하기 위한 방법
  - 무언가 잘못됐을 때 오류를 일으킨다.
  - 발생 가능한 오류 보고를 전부 감지한다.
  - 오류 보고를 적절히 처리한다.
  - 처리할 수 없는 오류는 전파한다.



### 6.2 오류 보고 메커니즘

- 메커니즘에 따라 **오류 지역성**(locality of error)이 달라진다.
  - 발생하자마자 발견되는 오류는 **시간**(time) 지역적 오류
  - 실제 오류가 발생한 위치와 아주 가까이에서(혹은 바로 거기서) 발견되는 오류는 **공간**(space) 지역적 오류다.

#### 1. 보고하지 않기

- 가장 간단한 오류 보고 메커니즘은 **신경 쓰지 않기**(don't botter)
- 오류 상황을 절대 무시하지 말자. 문제를 처리할 방법을 모르겠으면 호출한 코드에 다시 실패를 알리자. 오류를 숨기며 요행을 바라지 말자.

#### 2. 값 반환하기

- 함수에서 성공/실패 값을 반환하기
- 가능한 종료 상태를 모두 나열하고 대응하는 원인 코드(reason code) 반환하기

#### 3. 오류 상태 변수

- 최대한 사용하지 말 것

#### 4. 예외

- 예외 처리 후 연산 모델
  - 종료 모델(termination model): 예외를 잡았던 핸들러부터 실행을 계속한다.
  - 재개 모델(resumption model): 예외가 발생했던 지점부터 실행을 재개한다.
- **예외 안전**(exception-safe) 코드를 작성하기 위해 각별히 신경 써야 한다.

#### 5. 시그널

- 시그널(signal): 좀 더 극단적인 보고 메커니즘, 실행 환경이 실행 중인 프로그램에 오류를 알릴 때 주로 쓰인다.
- 시그널은 **시그널 핸들러**(signal handler) 함수로 들어가 프로그램의 정상적인 실행 흐름을 방해한다. 프로그램이 언제든 시그널을 받을 수 있으니 코드에서 시그널을 처리할 수 있어야 한다. 시그널 핸들러가 완료되면 프로그램은 방해받았던 그 지점부터 실행을 계속한다.
- 시그널은 하드웨어 인터럽트와 소프트웨어적으로 동등하다.



### 6.3 오류 감지

- 오류를 감지하는 방법은 오류를 보고하는 메커니즘에 의해 좌우된다.
- 어떤 오류가 보고되든 절대 무시하지 말자. 오류 보고 채널이 존재하는 데는 이유가 있다.



### 6.4 오류 처리

- 오류를 어떻게 할 것인가를 결정하기 위해서는 상황을 잘 알고 있어야 한다.
- 핵심 오류 정보
  - 어디서 비롯됐는지
  - 무엇을 하려던 중이었는지
  - 왜 잘못됐는지
  - 언제 발생했는지
  - 오류의 심각성
  - 어떻게 고치는지

#### 1. 언제 오류를 처리할까?

- 오류를 올바르게 처리할만한 충분한 정보를 얻으면 즉시 가장 적절한 맥락에서 오류를 처리하자.

#### 2. 가능한 조치

- 로깅
  - 로그는 주요 추적 정보를 수집하고 심각한 문제를 조사하는 진입점으로 쓰인다.
- 보고
  - 프로그램은 더 이상 할 수 있는 게 없을 때만 사용자에게 오류를 보고해야 한다.
- 회복
  - 코드에서 오류를 마주쳤고 어떻게 해야할 지 모르겠다면 오류를 위로 전달하자. 호출자에 회복 능력이 있을 가능성이 더 높다.
- 무시
  - 오류를 무시한다고 시간이 절약되지 않는다. 오류 핸들러 작성에 들이는 시간보다 프로그램이 형편없이 동작한 원인을 살피는 시간이 더 오래 걸린다.
- 전파
  - 받았던 오류 정보를 그대로 올려 보낸다. (같은 원인 코드를 반환하거나 예외를 전파한다.)
  - 정보를 재해석해 위 단계에 더 의미 있는 메시지를 전달한다. (다른 원인 코드를 반환하거나 예외를 잡아 감싼다.)

#### 3. 코드 암시

- 자원 정리 방법
  - 실패 가능성이 있는 연산이 종료될 때마다 소소하게 자원 정리를 수행하고 조기에 반환하자.
  - 자원 정리 코드를 함수 끝에 한 번만 작성하되 지저분한 것만 정리하는 식으로 작성하자.



### 6.5 난동 부리기

- 오류를 보고할 때 고려해야 할 것
  - 적절히 자원을 정리했는가? 안정적인 코드는 오류가 발생하더라도 **정말** 부득이한 경우가 아닌 이상 자원이 새거나 일관적이지 않은 상태로 남지 않는다.
  - 오류를 보고할 때 부적절한 정보가 외부로 새어 나가는 일이 없도록 하자.
  - 예외는 올바르게 사용하자. 특이한 반환값처럼 드물지만 오류가 아닌 경우에는 예외를 던지지 말자.
  - 일반적인 프로그램 실행 과정에서 결코 일어나서는 안 될 오류, 즉 진짜 프로그래밍 오류를 잡는 중이면 어서션을 고려하자.
  - 컴파일 타임에 할 수 있는 테스트는 모두 컴파일 타임에 끝내자.
  - 오류를 무시할 수 없게끔 하자.
- 일반적인 오류 점검 유형 목록
  - 모든 함수 인자를 확인하자. 인자가 올바르고 일관된 입력을 받게 하자. 이때 계약을 얼마나 엄격하게 했느냐에 따라 어서션 사용도 고려한다.
  - 실행 중 흥미로운 어떤 시점에서 불변을 만족하는지 확인하자.
  - 외부 소스에서 들어온 값은 사용 전에 유효한지 확인하자. 파일 내용과 대화형 입력은 누락된 정보 없이 적절해야 한다.
  - 시스템과 종속 함수 호출의 반환 상태를 전부 확인하자.



### 6.6 오류 처리

- 프로그램 오류의 발생과 감지, 처리를 다루기 위해 일반적으로 고려할 사항
  - 오류를 **야기할 만한** 상황은 피하자.
  - 프로그램이나 루틴이 비정상적 상황에 처했을 때의 예상 동작을 정의하자.
  - 어떤 컴포넌트가 어떤 오류 처리를 담당하는지 분명히 정의하자.
  - 자신의 프로그래밍 관례를 확인하자.
  - 오류를 잡으면서 징후나 원인을 알아챘는가? 바로 지금 고쳐야 할 문제의 원인을 찾은 것인지 혹은 이전 문제의 징후를 발견한 것인지 생각해보자. 후자라면 많은 처리 코드를 여기서 작성할 것이 아니라 (이전의) 보다 적절한 오류 핸들러에 넣자.