# 1. 방어 태세

> 강력한 코드를 만드는 방어적 프로그래밍 기법

- 코드는 층층이 만들어지기에 매 단계를 견고하게 다지는 기법을 사용해야 튼튼히 쌓아 올릴 수 있다.



### 1.1 훌륭한 코드를 향해

- 동작하는 듯 보이는 코드와 올바른 코드, 훌륭한 코드 간에는 엄청난 차이가 있다.
  - 거의 항상 동작하는 코드는 작성하기 쉽다. 일반적인 입력 집합을 넣으면 일반적인 출력 집합을 내놓는다. 하지만 예상 밖의 입력을 넣으면 갑자기 멈출 수 있다.
  - 올바른 코드는 멈추지 않는다. 어떤 입력 집합을 넣어도 출력이 올바르다. 다만 전체 입력 집합이 대개 터무니없이 큰 데다 테스트하기 어렵다.
  - 그렇다고 올바른 코드가 꼭 훌륭한 코드는 아니다. 로직을 이해하기 어렵거나 코드가 부자연스럽거나 현실적으로 유지 보수가 불가능할 수도 있다.
  - :rabbit: 예전에 상무님과 대화하던 중 기업들이 코딩 테스트를 치는 데는 얼마나 꼼꼼하게 예외처리를 하는지, 얼마나 잘 단단한 코드를 짜는지를 보기 위해서라는 말씀을 하셨던 적이 있는데 이 부분을 읽으며 그 생각이 났다. 코딩 테스트로 확인할 수 있는 건 얼마나 올바른 코드를 짜는가가 되겠고, 아마 높은 확률로 훌륭한 코드를 짜는지까지는 확인하기 힘들겠지. (코드를 읽는 사람보다 지원자가 훨씬 많을테니까 현실적으로...)
- 방어적 프로그래밍은 일상적인 기본 지침 모음으로, 산더미 같은 잠재적 코딩 문제를 방지하는 실용적 방법이다.



### 1.2 최악을 가정하라

- 방어적으로 프로그래밍할 때는 **어떤** 가정도 해서는 안 된다. **절대 일어나지 않는다**고 가정해서는 안 된다. 주변 세상이 예상대로 흘러갈 거라 가정해서도 안 된다.



### 1.3 방어적 프로그래밍이란?

- 시스템 내 모든 요소를 최대한 스스로 **보호**할 수 있도록 디자인함으로써 안정적인 소프트웨어를 구성한다.
- 방어적 프로그래밍은 치료 수단이 아니라 예방법이다. 디버깅은 문제가 생긴 **후** 버그를 제거한다.
- 방어적 프로그래밍이 아닌 것
  - **오류 확인**: 코드에서 발생할 수 있는 오류 조건이 있으면 무조건 확인해야 한다. 이는 방어적 코드가 **아니다**. 올바른 코드를 작성하는 데 필요한 일상적인 모범 사례일 뿐이다.
  - **테스트**: 코드 테스트는 방어가 아니다. 개발 과정의 하나다. 테스트 도구는 방어적이 아니라서 코드가 현재 올바른지는 증명해도 향후 수정에도 잘 견뎌낼지는 증명하지 못 한다. 아무리 세상에서 가장 뛰어난 테스트 집합이라 하더라도 누구든 변경하고 테스트하지 않은 채로 슬쩍 넘어갈 수 있다.
  - **디버깅**: 한 차례의 디버깅으로 방어적 코드를 추가하기도 하지만 어쨌든 디버깅은 프로그램이 실패한 후에야 수행한다. 방어적 프로그래밍은 애초에 프로그램이 실패하지 않도록 방지하는 (혹은 밤새 디버깅해야 할만큼 도무지 이해할 수 없는 방식으로 문제가 드러나기 전에 미리 실패를 감지하는) 방법이다.



### 1.4 거대하고 못된 세상

- 방어적 프로그래밍은 의도적 오용에 맞서 프로그램 보안을 지원한다.



### 1.5 방어적 프로그래밍 기법

#### 1. 훌륭한 코딩 스타일과 철저한 디자인을 채택하자

- 컴퓨터 프로그램의 가장 훌륭한 설명서는 명확한 구조다
- 코드로 바로 뛰어 들기에 앞서 대규모 디자인을 고려하라.
- 구현해야 할 명확한 API 집합과 논리적인 시스템 구조, 잘 정의된 구성 요소별 역할, 책임감을 갖고 시작하면 앞으로 다가올 골칫거리를 모면할 수 있다.

#### 2. 급하게 코딩하지 말자

- 어떤 코드 영역에 달려들기 전에 항상 그 코드 영역을 완성하는 데 필요한 작업을 **모두** 수행하자.
- 규율이란 배우고 강화해야 할 일종의 습관이다.
- 나중에 하는 것은 지금 하는 것보다 사실 **더 많은** 규율이 필요하다.

#### 3. 아무도 믿지 말자

- 누구도 믿지 말자. 자신을 포함해 어느 누구든 프로그램 로직에 결함을 집어넣을 수 있다. 유효하다고 증명할 수 있을 때까지 모든 입력과 모든 결과를 의심의 눈초리로 보자.

#### 4. 간결하게가 아니라 명료하게 코드를 작성하자

- 덜 명쾌하더라도 의도한 대로 **읽히는** 코드를 사용하자.
- 유지 보수할 수 없다면 코드는 안전하지 않다.

#### 5. 접근해서는 안 되는 부분이면 누구도 손대지 못하게 하자

- 객체 지향 언어라면 내부 클래스 데이터를 프라이빗으로 만들어 접근하지 못하게 하자.
- 절차적 언어도 모호한 타입으로 프라이빗 데이터를 래핑한 후 잘 정의된 공개 연산을 제공하는 식으로 객체 지향 패키징 개념을 이용할 수 있다.
- 모든 변수 범위(scope)를 최대한 좁게 유지하자.

#### 6. 모든 경고를 활성화해서 컴파일하자

- 반드시 코드가 조용히 컴파일되게 하자.

#### 7. 정적 분석 도구를 사용하자

- 컴파일러 경고는 프로그램을 **실행하기 전에** 수행하는 코드 검사이며, 한정된 **정적 분석**의 결과다.
- 시중에 독립된 정적 분석 도구가 많다. 일상적인 프로그래밍에 이러한 도구를 접목해 코드를 검사해야 컴파일러만으로 잡을 수 없는 더 많은 오류를 잡아낼 수 있다.

#### 8. 안전한 데이터 구조를 사용하자

- 데이터 타입이 안전하지 않으면 안전한 연산을 조직적으로 사용하자

#### 9. 모든 반환값을 확인하자

- 반환값이 오류 코드면 **반드시** 검사하고 어떤 실패든 처리해야 한다.

- 은밀한 버그의 대부분은 프로그램에서 반환값을 확인하지 않을 때 발생한다.

#### 10. 메모리(를 비롯한 그 외 소중한 자원)를 신중하게 다루자

- 실행 중에 획득한 자원은 모두 철저하게 반환하자.

#### 11. 변수는 선언 시점에 초기화하자

- 변수의 의도는 초기화를 해야 명쾌해진다.

#### 12. 변수는 가능한 한 늦게 선언하자

- 변수를 최대한 사용 시점과 가까이 두면 코드 내 다른 부분과 헷갈리지 않는다. 또한, 변수만으로도 코드가 명확해진다.
- 이름이 같은 임시 변수는 사용할 때마다 논리적으로 별개 영역에 있더라도 여러 곳에서 재사용하지 말자. 효율성 이슈는 컴파일러가 어떻게든 해결할 테니 매번 새로운 변수를 생성하자.

#### 13. 표준 언어 기능을 사용하자

- 사용한 언어 버전을 명확하게 정의하자.
- 프로젝트에서 규정한 것이 아닌 한(그리고 마땅한 이유가 있지 않은 한) 컴파일러의 특이성이나 언어의 비표준 확장판을 **사용하지 말자**.

#### 14. 훌륭한 진단 로깅 기능을 활용하자

- 대부분의 로깅 시스템은 꼭 필요하지 않을 때는 진단에 오버헤드가 거의 들지 않는 방식으로 사용할 수 있고, 조건부로 컴파일할 수 있다.

#### 15. 조심해서 캐스팅하자

- 캐스팅: 데이터를 한 타입에서 다른 타입으로 변환하는 것

#### 16. 놓치기 쉬운 세부 사항

**기본 동작 제공하기**

**언어 어법 따르기**

**수 제한 검증하기**

**const로 만들기**



### 1.6 제약

- 각 조건을 검사하는 간단한 코드를 작성하면, 프로그램 기능과 동작에 대한 **제약**(constraint)을 코드화(codifying)할 수 있다.
- 제약을 어디서 사용하는가
  - **전제 조건**(precondition): 코드 영역에 진입하기 **전에** 참을 충족해야 하는 조건. 전제 조건의 실패는 고객 코드의 결함 때문
  - **사후 조건**(postcondition): 코드 블록을 끝낸 **후에** 참이어야 한다. 사후 조건 실패는 공급자 코드의 결함 때문
  - **불변**(invariant): 루프를 순회하는 사이사이나 메서드 호출 전후로 등 프로그램을 실행하다 어떤 지점에 도달했을 때 매번 참이어야 하는 조건이다. 불변의 실패는 로직의 결함 때문
  - **어서션**(assertion): 어떤 시점에서 프로그램의 상태를 보여주는 모든 명령문
  - 처음 두 조건은 언어에서 지원하지 않으면 구현하기 어려운데, 함수에 종료 지점이 여럿이면 사후 조건 삽입이 복잡해지기 때문이다.
- 제약을 통해 코드 영역 간 불변 계약을 맺기에 이 기법을 **계약에 의한 설계**(design by contract)이라고도 부른다.

#### 1. 무엇을 제약할까?

- 배열 접근이 범위를 벗어나지 않는지 검사
- 포인터를 역참조하기 전에 포인터가 0이 아니라고 어서션
- 함수 매개변수가 유효한지 확인
- 함수 결과를 반환하기에 앞서 온전성(sanity) 검사를 수행
- 객체에 연산하기에 앞서 객체의 상태가 일관된지 증명
- 절대 여기에 들어와서는 안 된다고 주석을 작성한 코드 영역을 보호
- 현실적으로 주요 함수마다 전제 조건과 사후 조건을 넣고 주요 루프마다 불변을 넣는 것으로 충분하다.

#### 2. 제약 제거

- 제약을 사용해 프로그램 로직이 올바르다고 스스로 납득하고 나면 불필요한 런타임 오버헤드를 없애기 위해 이사적으로는 제약을 제거할 것이다.
- 어서션은 부수 효과(side effect)를 동반하면 안된다.

