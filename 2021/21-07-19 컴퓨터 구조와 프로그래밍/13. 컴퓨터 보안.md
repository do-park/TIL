# 13. 컴퓨터 보안

> 보안(security)은 정보를 사적으로 유지하는 것으로부터 생겨난다.
>
> "쇠사슬은 가장 약한 고리만큼만 강하다"



### 보안과 프라이버시 개요

#### 위협 모델

- 보안은 **위협 모델**(threat model)에 따라 상대적이다. 위협 모델은 보안이 필요한 대상 목록과 각 보안 대상에 가해질 수 있는 공격을 열거해서, 이런 공격을 방어하는 방법을 설계할 수 있게 한다.
- 위협 모델을 정의하지 않으면 효과적으로 보안을 강화할 수 없다.
- 목표는 공격자가 통과하려면 비싸지만 방어자에게는 비용이 적게 드는 방어
  - 인터넷은 공격 비용은 극적으로 줄여주는데 방어 비용은 줄여주지 못한다.

#### 신뢰

- 위협 모델을 정할 때 가장 어려운 부분은 **신뢰**(trust)할 대상을 정하는 것
- 처음 신뢰를 하는 순간부터 보안은 나빠지고, 신뢰할 대상을 추가하면 할수록 보안은 더 악화된다.
- 컴퓨터에서의 신뢰는 선택할 수는 없지만 의존해야 하는 대상을 가리키는 말
- 신뢰 위반
  1. **의도적**(deliverate)
  2. **무능**(incompetent)
  3. **부정직**(disingenuous)
     - **클렙토그래피**(kleptography): 암호를 써서 안전하다고 생각하고 있는데 사용자도 모르게 암호화되지 않은 정보를 빼낼 수 있게 하는 여러가지 수단
- **투명성**(transparency)이나 **개방성**(openness)에서 더 나은 보안을 얻을 수 있다.

#### 통신 보안

- 통신 보안에서 신경써야 하는 것: **인증**(authentication), **진본성**(authenticity), **중간자 공격**(man-in-the-middle attack)
- **크립토그래피**(cryptography)
  - 송신자와 수신자만 아는 비밀 코드(secret code)를 사용해 **암호화**(encrypt)해서 보내면 수신자는 비밀 코드를 사용해 암호화된 메시지를 **복호화**(decrypt)한다.
  - 제대로 설계된 **암호 시스템**(cryptosystem)은 당사자 사이에 신뢰하는 요소의 수를 감소시킨다.

#### 모던 타임즈

- 공격자 추적을 어렵게 하는 요인 중 하나는 공격자가 **프록시**(proxy)를 사용한다는 점이다.
- 공격의 유형
  - 크립토그래피 시스템
    - 상대적으로 드물고, 잘 설계된 시스템을 공격하기 어렵다.
  - 사회적(social) 공격
    - 트릭을 써서 사용자에게 자신의 컴퓨터에 소프트웨어를 직접 설치하게 만듦

#### 인증과 권한부여

- **인증**(authentication): 어떤 사람이나 대상이 실제로 그 사람이나 대상임을 증명하는 과정
- **권한부여**(authorization): 제대로 된 '자격증명(credential)'을 제공하지 않는 사람에게 접근을 제한



### 크립토그래피

#### 스테가노그래피

- **스테가노그래피**(steganography)
- 어떤 내용을 다른 내용 속에 감추는 방ㅇ식
- 송신자와 수신자 사이에 연결의 자취가 남지 않아 비밀리에 통신하기 좋음

#### 치환 암호

- 각 문자를 다른 문자로 변환하는 표를 만들고, 표를 보고 메시지에서 원래의 문자를 그에 대응하는 다른 문자로 바꿔치기 하면서 메시지를 **암호화**(encrypt), 암호화된 메시지를 표를 참조해 역방향으로 치환하면서 **복호화**(decrypt)

- 통계를 사용해 쉽게 깰 수 있다.

#### 전치 암호

- **스키테일**(scytale)
- 둥근 막대기에 양피지 리본을 감고 메시지를 가로로 한 줄 적는다. 다른 줄에는 아무 메시지나 적는다. 결과적으로 양피지 리본을 풀면 뜻을 알 수 없는 문자들만 보이고, 이를 해독하기 위해 지름이 똑같은 막대기에 리본을 감아야 한다.

#### 일회용 패드

- **일회용 패드**(one-time pad)
- 가장 안전한 암호화 방식
- 중복되지 않은 유일한 치환 암호들의 모음으로 각 치환 암호 코드를 단 한번만 사용한다.

#### 키 교환 문제

- 대칭 암호 시스템에는 통신의 양 당사자가 같은 열쇠(키)를 사용해야 한다는 문제가 있다.
- 대칭 암호 시스템은 중간자 공격에 취약하다.

#### 공개키 암호

- **공개키 암호**(public key cryptography)
- 대칭키 암호에서는 암호화와 복호화에 같은 암호를 사용했지만, 공개키 암호에서는 누구에게나 알려져 있는 키를 **공개키**(public key)라고 부르고, 개인만 알고 있어야 하는 키를 **비밀키**(secret key)라고 부른다. 누군가 공개키로 암호화한 암호문은 비밀키로만 복호화할 수 있다.
- **비대칭**(asymmetric) 시스템
- 키 교환 문제를 해겨: 공개키를 알아도 그 키로는 암호문을 복호화할 수 없다.
- **트랩도어 함수**(trapdoor function)에 의존
  - 한 방향으로는 계산하기가 쉽지만 비밀 정보를 알지 못하면 반대쪽 방향으로는 계산이 어려운 함수
- 비대칭 암호화는 계산 비용이 많이 들기 때문에, 메시지 내용을 암호화할 때 사용할 대칭 **세션 키**(session key)를 만들기 위해 비대칭 암호화를 사용하는 경우도 자주 있다. (ex. **디피-헬먼 키 교환**(DHKE, Diffie-Hellman Key Exchange))

#### 전방향 안전성

- **전방향 안전성**(forward secret)
- 각 메시지마다 세션 키를 새로 만들어, 키를 알아내도 메시지를 단 하나만 풀 수 있게 한다.

#### 암호학적 해시 함수

- 암호학적 해시 함수의 핵심 특성은 **단방향**(one-way) 함수
  - 입력에서 해시값을 만들어내기는 쉬워도 해시에서 입력을 만들어낼 수는 없거나 만들어내려면 비용이나 시간이 많이 들어서 비실용적
- 도용하기가 어려워야 한다. 즉, 해시를 만들어내는 입력 데이터를 알아내기가 아주 어려워야 한다. 다시 말해, 해시 충돌을 만들어내기가 아주 어려워야 한다.
- 현재 SHA 알고리즘을 변형한 다른 해시 알고리즘이 사용

#### 디지털 서명

- **디지털 서명**(digital signature)
- 서명의 경우 공개키와 비밀키의 역할이 반대
- 정합성, 부인방지, 인증을 제공
  - **정합성**(integrity): 메시지가 변조됐는지 검증할 수 있다.
    - 데이터의 암호학적 해시값을 계산해 데이터 뒤에 추가함
  - **부인방지**(nonrepudiation): 메시지를 보낸 사람이 자기가 그런 메시지를 보낸 적이 없다고 주장할 수 없다.
    - 비밀키로 메시지에 서명을 하기 때문에 보낸 사람이 자신이 서명했음을 부인하기가 어렵다.
  - **인증**(authentication): 수신자는 공개키와 서명한 사람의 비밀키가 서로 연관되어 있음을 알고 있기 때문에 메시지에 서명한 사람을 확신할 수 있고, 변조가 되지 않았음은 해시값으로부터 확인할 수 있기 때문에, 수신자가 받은 메시지가 원본과 같은 메시지라는 사실을 확인할 수 있다.

#### 공개키 인프라

- **공개키 인프라스트럭처**(PKI, public key infrastructure)
  - 신뢰할 수 있는 제3자인 **인증기관**(CA, certificate authority)이 있어서 키가 어떤 당사자의 것임을 인증해준다.

#### 블록체인

- **블록체인**(blockchain)
- 크립토그래피 응용
- 각 블록은 이전 블록에 대한 디지털 서명을 포함하고 있는 것 같은 효과
- 블록체인을 공격하는 유일한 효율적인 방법은 블록체인을 다루는 소프트웨어를 변경하는 방법

#### 패스워드 관리

- **패스워드 관리**(password management)
- 크립토그래피 응용
- 예전에는 컴퓨터 안에 있는 패스워드 파일에 패스워드가 **평문**으로 저장됐다.
  - 암호학적 해시와 같은 암호화된 형태로 저장



### 보안을 위한 소프트웨어 예방 조치

- C 프로그래머 십계명, 헨리 스펜서

#### 올바른 대상을 보호하라

- 모든 대상을 안전하게 하는 것은 좋은 생각이 아니다.

#### 로직은 세 번 체크하라

- 다른 사람과 크게 코드를 읽으면 눈으로 읽을 때보다 코드를 천천히 보게 된다.

#### 오류를 검사하라

- 시스템 콜이나 라이브러리 함수를 호출할 때, 이런 호출이 잘못되면 대부분의 경우 오류 코드를 반환받는다. 이를 무시하지 마라.

#### 공격 표면을 최소화하라

- 코드를 가능한 한 간단하게 유지해서 공격 표면을 줄여라

#### 경계 내부에 머물러라

- 수의 범위나 바이트 내의 비트 수 등 수치를 가정하지 마라
- 동적으로 할당된 메모리를 사용하면서 n바이트를 할당했다면, 코드는 이 메모리의 0부터 n-1의 범위에만 접근해야 한다.

#### 좋은 난수를 생성하기는 힘들다

- 보안이 좋은 난수에 의존해야 한다면, 난수를 생성하는 시스템을 반드시 이해해야만 한다.

#### 네 코드를 알라

- **서드파티 코드**(third-party code)
- 오픈소스 코드가 더 나을 수 있다.
- 서드파티 패키지에서 실제로 사용하는 코드의 크기와 전체 패키지 크기 사이의 비율을 주시하라.
- 출시 전에 디버깅 코드를 꼭 제거
  - 디폴트 패스워드 등

#### 극단적인 영리함은 여러분의 적이다

- 서드파티 코드를 이용할 경우 이상하고 영리한 기능은 피하라. 많은 고객이 쓰지 않는 기능은 벤더가 더 이상 지원하지 않을 수도 있다.

#### 눈에 보이는 것을 이해하라

- **사이드 채널 공격**(side-channel attack)

#### 과다수집하지 마라

- 사물을 안전하게 유지하는 가장 좋은 방법은 안전하게 유지해야 할 대상을 아예 만들지 않는 것이다.

#### 모아두지 마라

- 민감한 데이터를 깨끗이 제거하라

#### 동적 메모리 할당은 여러분의 친구가 아니다

- 보안이 필요한 경우 realloc을 사용하지 마라. malloc으로 새 메모리를 할당하고 이전 데이터를 새 블록에 복사한 다음, 민감한 데이터를 덮어써 지우고 free로 해제하라. 효율적이지는 않지만 훨씬 더 안전하다.

#### 가비지 컬렉션도 여러분의 친구가 아니다

#### 코드 역할을 하는 데이터

- '코드'는 단지 컴퓨터가 이해할 수 있는 특정한 형태의 데이터



