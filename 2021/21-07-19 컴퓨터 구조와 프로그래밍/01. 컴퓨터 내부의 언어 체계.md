# 1. 컴퓨터 내부의 언어 체계

### 비트

- 2진법을 사용한다는 뜻의 바이너리(binary) + ㅅ수자를 뜻하는 디지트(digit)
- 적은 비용으로 편리하게 기호를 담을 수 있다.
- 2진법을 사용



### 논리 연산

- 비트 사용법 중 하나: 예/아니요 질문에 대한 답을 표현하는 것
- 논리 연산: 다른 비트들이 표현하려는 내용으로부터 새로운 비트를 만들어내는 동작

#### 불리언 대수

- 불리언 대수: 비트에 대해 사용할 수 있는 연산 규칙의 집합
- 기본적인 불리언 연산자: NOT, AND, OR
  - NOT: 논리적 반대
  - AND: 둘 이상의 비트에 작용. 모든 비트가 참이면 AND 연산의 결과도 참
  - OR: 둘 이상의 비트에 작용. 어느 한 비트라도 참이면 OR 연산의 결과도 참
  - XOR: 배타적(exclusive) OR. 첫 번째 비트와 두 번째 비트가 다른 값인 경우에만 참.

#### 드모르간의 법칙

- 긍정적인 논리(positive logic)에 더해 부정적인 논리(negative logic)를 기술하는 명제를 사용할 때 드모르간의 법칙을 활용할 수 있다.

  - 긍정적인 논리: 정논리, 부정적인 논리: 부논리

- | a    | b    | a AND b | NOT a | NOT b | NOt a OR NOT b | NOT (NOT a OR NOT b) |
  | ---- | ---- | ------- | ----- | ----- | -------------- | -------------------- |
  | F    | F    | F       | T     | T     | T              | F                    |
  | F    | T    | F       | T     | F     | T              | F                    |
  | T    | F    | F       | F     | T     | T              | F                    |
  | T    | T    | T       | F     | F     | F              | T                    |

- 연산을 최소로 사용하면 비용을 최소화할 수 있다.



### 정수를 비트로 표현하는 방법

#### 양의 정수 표현

- 2진수 체계는 **2를 밑으로** 하는 수 체계
- **가장 작은 유효 비트**(least significant bit, LSB): 2진수에서 가장 오른쪽의 비트
- **가장 큰 유효 비트**(most significant bit, MSB): 2진수에서 가장 왼쪽의 비트

#### 2진수 덧셈

- 각 비트를 LSB에서 MSB 쪽으로 더하며 결과가 1보다 크면 1을 다음 자리(왼쪽)로 올린다.
- **오버플로**(overflow)
  - 덧셈 결과가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어난 경우
  - MSB에서 올림이 발생
  - 조건 코드(상태 코드) 레지스터(condition code register)에서 몇 가지 이상한 정보를 담아두는데 이 중 **오버플로 비트**(overflow bit)에서 MSB에서 발생한 올림값을 저장, 이 비트값을 통해 오버플로가 발생했는지 알 수 있다.
  - **언더플로**(underflow): MSB 위쪽에서 1을 빌려오는 경우

#### 음수 표현

- 부호와 크기
  - 음수와 양수를 구분하기 위해 흔히 **부호**(sign)를 사용한다. 우리는 가장 왼쪽 비트(MSB)를 부호에 사용하기로 결정했다.
  - 부호 비트가 0이면 이 2진수를 양수로 취급하고 부호 비트가 1이면 이 2진수를 음수로 취급한다.
  - 양수 0과 음수 0은 같은 0이기 때문에 표현할 수 있는 수의 가짓수는 2^n - 1가지가 된다.
  - **부호와 크기**(sign and magnitude) 표현법: 한 비트를 부호에 사용하고 나머지 비트를 수의 크기, 즉 0부터의 거리(절댓값)를 표현하기 위해 사용하는 방법
  - 널리 쓰이지 못하고 있는 이유
    - 비트들을 구성하려면 비용이 드는데 0을 표현하는 방법이 두 가지라서 비용이 낭비된다.
    - 부호와 크기 표현법을 사용하면 XOR과 AND를 통한 덧셈 계산을 사용할 수가 없다.
- 1의 보수(one's complement)
  - 음수를 표현하기 위해 양수의 모든 비트를 뒤집는 방법
  - NOT 연산을 통해 보수를 얻는다.
  - 문제점
    - 0을 두 가지 방식으로 표현한다.
    - 덧셈을 쉽게 할 수 없다. → **순환 올림**(end-around carry)을 통해 문제 해결이 가능하지만 순환 올림을 처리하기 위한 하드웨어를 추가해야 함.
      - 순환 올림: MSB 쪽에서 올림이 발생한 경우 LSB로 올림을 전달
- 2의 보수(two's complement)
  - 어떤 수의 비트를 뒤집고(즉 각 비트의 NOT을 취하고) 1을 추가해 음수를 얻는다. 이때 MSB에서 올림이 발생하면 이 값은 버린다.
  - 2의 보수 표현법에는 0을 표현하는 방법이 하나뿐이다.
- 같은 숫자로 이뤄진 수를 보더라도 문맥에 따라 표현하는 값이 달라질 수 있다.



### 실수를 표현하는 방법

- 밑이 10인 실수에는 10진 소수점(decimal point)이 포함된다. 따라서 밑이 2인 경우, 실수를 표기하기 위해 2진 소수점을 표현할 방법이 필요하다.

- #### 고정소수점 표현법

  - fixed-point
  - 2진수를 사용해 소수를 표현하기 위해 2진 소수점의 위치를 임의로 정함
  - 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많기 때문에 범용 컴퓨터에서 이런 방식을 사용하는 경우는 드물다.

- #### 부동소수점 표현법

  - floating-point
  - 과학적 표기법에서 10진 소수점 왼쪽이 한 자리뿐인 소수(가수, mantissa)에 10을 몇 번(지수, exponent) 거듭제곱한 값을 곱하는 방식으로 소수를 표현한다.
  - 비트 조합 중에 낭비되는 부분이 많다.
  - 비트 패턴이 가능한 모든 수를 표현하지는 못한다.
  
- #### IEEE 부동소수점 수 표준

  - 부동소수점 수 시스템은 컴퓨터에서 계산을 수행할 때 실수를 표현하는 표준 방법
  - 가수와 지수에 대해 각각 부호 비트를 사용하고, 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있다.
  - 낭비되는 비트 조합을 최소화하고 반올림을 쉽게 하기 위한 트릭이 존재
  - 똑같은 비트를 사용해 정밀도(percision)를 가능한 한 높이고 싶다
    - **정규화**(nomalization): 가수를 조정해서 맨 앞(왼쪽)에 0이 없게 만드는 것
    - 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략한다.
  - 기본 정밀도(single precision) 부동소수점 수
    - 32비트, 7비트 정밀도로 대략 +-10^(+-38) 범위를 표현
    - 단정도 실수
  - 2배 정밀도(double precision) 부동소수점 수
    - 64비트, 15비트 정밀도로 대략 +-10^(+-308) 범위를 표현
    - 배정도 실수
  - 편향된(biased) 지숫값을 사용해 지수 비트가 모두 0이거나 1인 경우에 특별한 의미를 갖게 하고, 실제 지숫값은 나머지 비트 패턴에 집어 넣음
  - 0으로 나눴을 때 생길 수 있는 양의 무한대나 음의 무한대를 표현하는 비트 패턴 등 여러 가지 특별한 비트 패턴을 제공



### 2진 코드화한 10진수 시스템

- BCD, binary-coded decimal
- 4비트를 사용해 10진 숫자 하나를 표현한다.
- 디스플레이나 가속도 센서 등이 사용하는 경우가 있다.
- 2진수를 효율적으로 활용하지 못함.



### 2진수를 다루는 쉬운 방법

- #### 8진 표현법

  - Octal representation
  - 비트들을 3개씩 그룹으로 묶어, 각 그룹에 8진 숫자를 부여

- #### 16진 표현법

  - hexadecimal representation
  - 요즘은 컴퓨터 내부가 8비트의 배수를 사용해 만들어지기 때문에 16진 표현법을 주로 사용한다.

- #### 프로그래밍 언어의 진법 표기법

  - 0으로 시작하는 숫자는 8진 숫자
  - 1~9 사이의 숫자로 시작하는 숫자는 10진수
  - 0x가 앞에 붙은(접두사) 숫자는 16진수

  

### 비트 그룹의 이름

- 비트는 너무 작아서 기본 단위로 사용하기에는 유용성이 떨어짐. → 비트를 좀 더 큰 덩어리로 조직화
- **바이트**(byte): 8비트 덩어리



### 텍스트 표현

- #### 아스키 코드

  - 키보드에 있는 모든 기호에 대해 7비트 수 값을 할당
  - **제어 문자**(control character): 글자를 출력하는 데 쓰이지 않고 장치를 제어하기 위해 사용

- #### 다른 표준의 진화

  - **유니코드**(Unicode): 문자에 16비트 코드를 부여

- #### 유니코드 변환 형식 8비트

  - 문자 코드에 따라 각기 다른 인코딩을 사용
    - **인코딩**(encoding): 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴
  - 비트 같은 추상화를 사용해 숫자를 표현하고, 숫자를 사용해 문자를 표현하며, 다시 다른 숫자를 사용해 문자를 표현하는 숫자를 표현한다. → **유니코드 변환 형식 8비트**(UTF-8, Unicode Transformation Format-8 bit)가 하위 호환성과 효율성 때문에 가장 널리 쓰이고 있다.
  - 모든 아스키 문자를 8비트로 표현하기 때문에 아스키 데이터를 인코딩할 때는 추가 공간이 필요하지 않다. 그리고 UTF-8은 아스키가 아닌 문자의 경우 아스키를 받아서 처리하는 프로그램이 깨지지 않는 방법으로 문자를 인코딩한다.
  - 문자를 8비트 덩어리(옥텟, octet)의 시퀀스로 인코딩



### 문자를 사용한 수 표현

 - #### 출력 가능하게 변경한 인코딩

   	- Quoted-Printable encoding
   	- 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법
   	- 1바이트를 표현하기 위해 3바이트를 사용하므로 비효율적

- #### 베이스64 인코딩

  - Base64
  - 3바이트 데이터를 4문자로 표현. 3바이트 데이터의 24비트를 네 가지 6비트 덩어리로 나누고, 각 덩어리의 6비트값에 출력 가능한 문자를 할당해 표현

- #### URL 인코딩

  - **퍼센트 인코딩**(percent-encoding)
  - % 뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩



### 색을 표현하는 방법

- 컴퓨터 그래픽스(graphics)는 전자 모눈종이에 해당하는 것에 색을 표현하는 점을 찍어서 그림을 만드는 과정이다. 이때 모눈의 각 격자에 찍는 점을 **그림 원소**(picture element)라고 부르고, 줄여서 **픽셀**(pixel)이라고 부른다.
- **RGB색 모델**(RGB color model): 빨간색, 녹색, 파란색 광선을 섞어서 색을 만들어내는 색 표현법
- 색은 **컬러 큐브**(color cube)로 표현할 수 있다.
- 색 인코딩
  - 웹에서는 색을 **16진 트리플렛**(hex triplet)으로 표현. 
    - 16진 트리플렛: # 뒤에 여섯 자리 16진 숫자를 추가해 표현하는 방식