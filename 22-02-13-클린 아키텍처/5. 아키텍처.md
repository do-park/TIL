# 5. 아키텍처

### 15. 아키텍처란

- 아키텍처의 주된 목적은 시스템의 생명 주기를 지원하는 것이다. 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 또 쉽게 배포하게 해준다. 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.
- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다. 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다. 좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.



### 16. 독립성

- 좋은 아키텍처는 다음을 지원해야 한다.
  - 시스템의 유스케이스
  - 시스템의 운영
  - 시스템의 개발
  - 시스템의 배포
- 유스케이스
  - 시스템의 아키텍처는 시스템의 의도를 지원해야 한다.
  - 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.
- 운영
  - 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.
- 개발
  - 아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다.
  - 콘웨이의 법칙
    - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
- 배포
  - 아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다. 이때 목표는 '즉각적인 배포(immediate deployment)'다.
- 선택사항 열어놓기
  - 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.
    - 계층 결합 분리
    - 유스케이스 결합 분리
    - 결합 분리 모드
    - 개발 독립성
    - 배포 독립성



### 17. 경계: 선 긋기

- 경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다.

- 경계는 변경의 축(axis of change)이 있는 지점에 그어진다. 경계의 한쪽에 위치한 컴포넌트는 경계 반대쪽의 컴포넌트와는 다른 속도로, 그리고 다른 이유로 변경된다.
- 소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다. 일부 컴포넌트는 핵심 업무 규칙에 해당한다. 나머지 컴포넌트는 플러그인으로, 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다. 그런 다음 컴포넌트 사아의 화살표가 특정 방향, 즉 핵심 업무를 향하도록 이들 컴포넌트의 소스를 배치한다.



### 18. 경계 해부학

#### 경계 횡단하기

- '런타임에 경계를 횡단한다' === 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일
  - 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.

#### 두려운 단일체

- 배포 관점에서 볼 때 단일체는 경계가 드러나지 않는다. 그렇다고 해서 단일체는 경계가 실제로 존재하지 않거나, 경계 자체가 무의미하다는 뜻은 아니다. 최종적으로는 정적으로 링크된 단일 실행 파일을 만들더라도, 그 안에 포함된 다양한 컴포넌트를 개발하고 바이너리로 만드는 과정을 독립적으로 수행할 수 있게 하는 일은 대단히 가치 있는 일이다.
- 단일체에서 컴포넌트 간 통신은 매우 빠르고 값싸다. 통신은 전형적인 함수 호출에 지나지 않기 때문이다. 결과적으로, 소스 수준에서 결합이 분리되면 경계를 가로지르는 통신은 상당히 빈번할 수 있다.
- 단일체를 배포하는 일은 일반적으로 컴파일과 정적 링크 작업을 수반하므로, 대체로 이러한 시스템에서 컴포넌트는 소스 코드 형태로 전달된다.

#### 배포형 컴포넌트

- 아키텍처의 경계가 물리적으로 드러나는 가장 단순한 형태는 동적 링크 라이브러리
- 컴포넌트를 이 형태로 배포하면 따로 컴파일하지 않고 곧바로 사용할 수 있다.
- 배포 과정에서만 차이가 날 뿐, 배포 수준의 컴포넌트는 단일체와 동일하다.
- 배포형 컴포넌트의 경계를 가로지르는 통신은 순전히 함수 호출에 지나지 않으므로 매우 값싸다. 동적 링크와 런타임 로딩으로 인해 최초의 함수 호출은 오래 걸릴 수 있지만, 대체로 이들 경계를 가로지르는 통신은 매우 빈번할 굿이다.

#### 스레드

- 단일체와 배포형 컴포넌트는 모두 스레드를 활용할 수 있다.
- 스레드는 실행 계획과 순서를 체계화하는 방법에 가깝다. 모든 스레드가 단 하나의 컴포넌트에 포함될 수도 있고, 많은 컴포넌트에 걸쳐 분산될 수도 있다.

#### 로컬 프로세스

- 훨씬 강한 물리적 형태를 띠는 아키텍처 경계
- 로컬 프로세스 경계를 지나늩 오신에는 운영체제 호출, 데이터 마샬링 및 언마샬링, 프로레스 간 문맥 교환 등이 있으며, 이들은 제법 비싼 작업에 속한다. 따라서 통신이 너무 빈번하게 이뤄지지 않도록 신중하게 제한해야 한다.

#### 서비스

- 물리적인 형태를 띠는 가장 강력한 경계
- 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다. 따라서 주의를 기울여서 가능하다면 빈번하게 통신하는 일을 피해야 한다. 이 수준의 통신에서는 지연latency에 따른 문제를 고수준에서 처리할 수 있어야 한다.

#### 결론

- 단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.
- 대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있다.



### 19. 정책과 수준

- 컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서다.
- 소프트웨어 아키텍처를 개발하는 기술에는 이러한 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함된다. 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다. 서로 다른 이유로, 혹은 다른 시점에 변경되는 정책은 다른 수준에 위치하며, 반드시 다른 컴포넌트로 분리해야 한다.
- 좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 한다. 즉, 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다.

#### 수준

- 수준(level)
- 입력과 출력까지의 거리
- 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다. 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.
- 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙



### 20. 업무 규칙

- 업무 규칙: 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차
- 핵심 업무 규칙Critical Business Rule
  - 사업 자체에 핵심적이며, 규칙을 자동화하는 시스템이 없더라도 업무 규칙은 그대로 존재
- 핵심 업무 데이터Critical Business Data
  - 핵심 업무 규칙에서 요구하는 데이터

#### 엔티티

- 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.
- 엔티티 객체는 핵심 업무 데이터를 직접 포함하거나 핵심 업무 데이터에 매우 쉽게 접근할 수 있다.
- 엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.

#### 유스케이스

- 자동화된 시스템이 사용되는 방법을 설명
- **애플리케이션에 특화된**application-specific 업무 규칙을 설명한다.
- 유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출할지를 명시하는 규칙을 담는다.
- 인터페이스로 들어오는 데이터와 인터페이스에서 되돌려주는 데이터를 형식 없이 명시한다는 점만 빼면, 유스케이스는 사용자 인터페이스를 기술하지 않는다.

#### 요청 및 응답 모델

- 유스케이스는 입력 데이터를 받아서 출력 데이터를 생성한다. 그런데 제대로 구성된 유스케이스 객체라면 데이터를 사용자나 또 다른 컴포넌트와 주고 받는 방식에 대해서는 전혀 눈치챌 수 없어야 한다.
- 요청 및 응답 모델이 독립적이지 않다면, 그 모델에 의존하는 유스케이스도 결국 해당 모델이 수반하는 의존성에 간접적으로 결합되어 버린다.

#### 결론

- 업무 규칙은 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 되며, 원래 그대로의 모습으로 남아 있어야 한다. 이상적으로는 업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치해야 하며, 덜 중요한 코드는 이 심장부에 플러그인되어야 한다. 업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.



### 21. 소리치는 아키텍처

#### 아키텍처의 테마

- 소프트웨어 애플리케이션의 아키텍처는 애플리케이션의 유스케이스에 대해 소리쳐야 한다.
- 아키텍처를 프레임워크 중심으로 만들어버리면 유스케이스가 중심이 되는 아키텍처는 절대 나올 수 없다.

#### 아키텍처의 목적

- 좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제 없이 기술할 수 있다.
- 좋은 소프트웨어 아키텍처는 프레임워크, 데이터베이스, 웹 서버, 그리고 여타 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있도록 만든다. 뿐만 아니라 이러한 결정을 쉽게 번복할 수 있도록 한다.
- 좋은 아키텍처는 유스케이스에 중점을 두며, 지엽적인 관심사에 대한 결합은 분리시킨다.

#### 하지만 웹은?

- 웹은 아키텍처가 아니다. 웹은 전달 메커니즘(입출력 장치)이며, 애플리케이션 아키텍처에서도 그와 같이 다뤄야 한다. 애플리케이션이 웹을 통해 전달된다는 사실은 세부사항이며, 시스템 구조를 지배해서는 안 된다.

#### 프레임워크는 도구일 뿐, 삶의 방식은 아니다

- 프레임워크가 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발하라.

#### 테스트하기 쉬운 아키텍처

- 아키텍처가 유스케이스를 최우선으로 한다면, 그리고 프레임워크와는 적당한 거리를 둔다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.
- 엔티티 객체는 반드시 오래된 방식의 간단한 객체plain old object여야 하며, 프레임워크나 데이터베이스, 또는 여타 복잡한 것들에 의존해서는 안 된다.



### 22. 클린 아키텍처

- 관심사의 분리separation of concerns
  - 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성
- 시스템의 특징
  - 프레임워크 독립성
  - 테스트 용이성
  - UI 독립성
  - 데이터베이스 독립성
  - 모든 외부 에이전시에 대한 독립성

#### 의존성 규칙

- 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

**엔티티**

- 전사적인 핵심 업무 규칙을 캡슐화
- 단순한 단일 애플리케이션을 작성하고 있다면 엔티티는 해당 애플리케이션의 업무 객체가 된다. 이 경우 엔티티는 가장 일반적이며 고수준인 규칙을 캡슐화한다.
- 운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 된다.

**유스케이스**

- 애플리케이션에 특화된 업무 규칙을 포함
- 유스케이스 계층의 소프트웨어는 시스템의 모든 유스케이스를 캡슐화하고 구현한다.
- 이 계층에서 발생한 변경이 엔티티에 영향을 줘서는 안 된다. 하지만 운영 관점에서 애플리케이션이 변경된다면 유스케이스가 영향을 받으며, 따라서 이 계층의 소프트웨어에도 영향을 줄 것이다.

**인터페이스 어댑터**

- 인터페이스 어댑터interface adapter 계층은 일련의 어댑터들로 구성된다. 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 방식 / 영속성용으로 사용 중인 임의의 프레임워크로 변환한다.

**프레임워크와 드라이버**

- 모든 세부사항이 위치하는 곳

**원은 네 개여야만 하나?**

- 네 개보다 더 많은 원이 필요할 수도 있다. 하지만 어떤 경우에도 의존성 규칙은 적용된다.
- 안쪽으로 이동할수록 추상화와 정책의 수준은 높아진다. 가장 안쪽 원은 가장 범용적이며 높은 수준을 가진다.

**경계 횡단하기**

- 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 대체로 의존성 역전 원칙을 사용하여 해결한다.
- 동적 다형성을 이용해 소스 코드 의존성을 제어흐름과는 반대로 만들 수 있고, 이를 통해 제어흐름이 어느 방향으로 흐르더라도 의존성 규칙을 준수할 수 있다.

**경계를  횡단하는 데이터는 어떤 모습인가**

- 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야만 한다.

  

### 23. 프레젠터와 험블 객체

- 프레젠터는 험블 객체Humble Object 패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는 데 도움이 된다.

#### 험블 객체 패턴

- 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.
- 행위들을 두 개의 모듈 또는 클래스로 나눈다. 이들 모듈 중 하나가 험블humble이다. 가장 기본적인 본질은 남기고, 테스트 하기 어려운 행위를 모두 험블 객체로 옮긴다. 나머지 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다.

#### 프레젠터와 뷰

- 프레젠터는 테스트하기 쉬운 객체다. 프레젠터의 역할은 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것이다.

#### 테스트와 아키텍처

- 행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍처 경계가 정의된다.

#### 데이터베이스 게이트웨이

- 유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이가 존재한다. 유스케이스 계층은 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출한다. 그리고 인터페이스의 구현체는 데이터베이스 계층에 위치한다. 이 구현체는 험블 객체다. 
- 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기 때문에 험블 객체가 아니다.

#### 데이터 매퍼

- 객체는 데이터 구조가 아니기 때문에 객체 관계 매퍼Object Relational Mapper, ORM는 존재하지 않는다. ORM보다는 데이터 매퍼Data Mapper라고 부르는 편이 나아보이는데, 관계형 데이터베이스 테이블로부터 가져온 데이터를 데이터 구조에 맞게 담아주기 때문이다.
- ORM 시스템은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 또 다른 험블 객체 경계를 형성한다.

#### 서비스 리스너

- 애플리케이션이 다른 서비스와 반드시 통신해야 한다면, 또는 애플리케이션에서 일련의 서비스를 제공해야 한다면, 우리는 여기에서 서비스 경계를 생성하는 험블 객체 패턴을 발견할 수 있다.

#### 결론

- 각 아키텍처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있다.
- 이러한 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.



### 24. 부분적 경계

#### 마지막 단계를 건너뛰기

- 부분적 경계를 생성하는 방법 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것이다.
- 별도로 분리한 웹 컴포넌트가 재사용될 가능성이 낮아지고, 컴포넌트 간 구분이 약화되며, 의존성이 잘못된 방향으로 선을 넘을 수 있다.

#### 일차원 경계

- 완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다. 양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.
- 전략Strategy 패턴을 사용해 추후 환벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 대 활용할 수 있는 구조를 만들 수 있다.
- 쌍방향 인터페이스가 없고 개발자와 아키텍트가 근면 성실하고 제대로 훈련되어 있지 않다면, 빠르게 분리될 수 있다.

#### 퍼사드

- 퍼사드Facade 패턴을 이용하면 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다. 클라이언트는 이 서비스 클래스에 직접 접근할 수 없다. 하지만 클라이언트가 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다.
- 쉽게 비밀 통로를 만들 수 있다.



### 25. 계층과 경계

- 아키텍처 경계는 어디에나 존재한다.
- 아키텍트로서 우리는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야 한다. 또한 이러한 경계를 제대로 구현하려면 비용이 많이 든다는 사실도 인지하고 있어야 한다.
- 이러한 경계가 무시되었다면 나중에 다시 추가하는 비용이 크다는 사실도 알아야 한다.
- 추상화가 필요하리라고 미리 예측해서는 안 된다.
  - 오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많다.



### 26. 메인(Main) 컴포넌트

- 모든 시스템에는 최소한 하나의 컴포넌트가 존재하고, 이 컴포넌트가 나머지 컴포넌트를 생성하고, 조정하며, 관리한다. 이 컴포넌트를 메인이라고 부른다.

#### 궁극적인 세부사항

- 메인 컴포넌트는 궁극적인 세부사항으로, 가장 낮은 수준의 정책이다.
- 메인은 모든 팩토리Factory와 전략Strategy, 그리고 시스템 전반을 담당하는 나머지 기반 설비를 생성한 후, 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘기는 역할을 맡는다.
- 의존성 주입 프레임워크를 이용해 의존성을 주입하는 일은 바로 이 메인 컴포넌트에서 이뤄져야 한다. 메인에 의존성이 일단 주입되고 나면, 메인은 의존성 주입 프레임워크를 사용하지 않고도 일반적인 방식으로 의존성을 분배할 수 있어야 한다.



### 27. '크고 작은 모든' 서비스들

#### 서비스 아키텍처?

- 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다. 아키텍처적으로 중요한 서비스도 있지만, 중요하지 않은 서비스도 존재한다.

#### 서비스의 이점?

- 결합분리의 오류
- 개발 및 배포 독립성의 오류
- 야옹이 문제

#### 객체가 구출하다

- SOLID 설계 원칙: 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 한다.

#### 컴포넌트 기반 서비스

- 서비스는 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다. 이를 통해 서비스 내의 기존 컴포넌트들을 변경하지 않고도 새로운 컴포넌트를 추가할 수 있다.

#### 횡단 관심사

- 아키텍처 경계는 서비스 사이에 있지 않다. 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다.



### 28. 테스트 경계

- 테스트는 시스템의 일부이며, 아키텍처에도 관여한다.

#### 시스템 컴포넌트인 테스트

- 아키텍처 관점에서는 모든 테스트가 동일하다.
- 테스트는 태생적으로 의존성 규칙을 따른다. 테스트는 세부적이며 구체적인 것으로, 의존성은 항상 테스트 대상이 되는 코드를 향한다.
- 테스트는 독립적으로 배포 가능하다.
- 테스트는 시스템 컴포넌트 중에서 가장 고립되어 있다. 테스트의 역할은 운영이 아니라 개발을 지원하는 데 있다. 그렇다고 해서 테스트가 시스템 컴포넌트가 아니라는 뜻은 아니다.

#### 테스트를 고려한 설계

- 테스트가 시스템의 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고, 시스템은 뻣뻣해져서 변경하기가 어려워진다.
- 이 문제를 해결하려면 테스트를 고려해서 설계해야 한다.
  - 변동성이 있는 것에 의존하지 말라.

#### 테스트 API

- 테스트가 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 API를 만들면 된다.

- 테스트 구조를 애플리케이션 구조로부터 결합을 분리하는 게 목표



### 29. 클린 임베디드 아키텍처

- 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.

#### 앱-티튜드 테스트

- 소프트웨어를 구축하는 세 가지 활동, 켄트 벡
  - 먼저 동작하게 만들어라 → 개발자용 앱-티튜드 테스트
  - 그리고 올바르게 만들어라
  - 그리고 빠르게 만들어라

#### 타깃-하드웨어 병목현상

- 클임베디드 코드가 클린 아키텍처 원칙과 실천법을 따르지 않고 작성된다면, 대개의 경우 코드를 테스트할 수 있는 환경이 해당 특정 타깃으로 국한될 것이다. 그리고 그 타깃이 테스트가 가능한 유일한 장소라면 타깃-하드웨어 병목현상이 발생하여 진척이 느려질 것이다.

**클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다**

**하드웨어는 세부사항이다**

**HAL 사용자에게 하드웨어 세부사항을 드러내지 말라**

- HAL, Hardware Abstraction Layer: 소프트웨어와 펌웨어 사이의 경계, 하드웨어 추상화 계층

**프로세서는 세부사항이다**

**운영체제는 세부사항이다**

**인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍하라**

**DRY 원칙: 조건부 컴파일 지시자를 반복하지 말라**

