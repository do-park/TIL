# 5. 아키텍처

### 15. 아키텍처란

- 아키텍처의 주된 목적은 시스템의 생명 주기를 지원하는 것이다. 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 또 쉽게 배포하게 해준다. 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.
- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다. 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다. 좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.



### 16. 독립성

- 좋은 아키텍처는 다음을 지원해야 한다.
  - 시스템의 유스케이스
  - 시스템의 운영
  - 시스템의 개발
  - 시스템의 배포
- 유스케이스
  - 시스템의 아키텍처는 시스템의 의도를 지원해야 한다.
  - 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.
- 운영
  - 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.
- 개발
  - 아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다.
  - 콘웨이의 법칙
    - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
- 배포
  - 아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다. 이때 목표는 '즉각적인 배포(immediate deployment)'다.
- 선택사항 열어놓기
  - 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.
    - 계층 결합 분리
    - 유스케이스 결합 분리
    - 결합 분리 모드
    - 개발 독립성
    - 배포 독립성



### 17. 경계: 선 긋기

- 경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다.

- 경계는 변경의 축(axis of change)이 있는 지점에 그어진다. 경계의 한쪽에 위치한 컴포넌트는 경계 반대쪽의 컴포넌트와는 다른 속도로, 그리고 다른 이유로 변경된다.
- 소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다. 일부 컴포넌트는 핵심 업무 규칙에 해당한다. 나머지 컴포넌트는 플러그인으로, 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다. 그런 다음 컴포넌트 사아의 화살표가 특정 방향, 즉 핵심 업무를 향하도록 이들 컴포넌트의 소스를 배치한다.



### 18. 경계 해부학

#### 경계 횡단하기

- '런타임에 경계를 횡단한다' === 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일
  - 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.

#### 두려운 단일체

- 배포 관점에서 볼 때 단일체는 경계가 드러나지 않는다. 그렇다고 해서 단일체는 경계가 실제로 존재하지 않거나, 경계 자체가 무의미하다는 뜻은 아니다. 최종적으로는 정적으로 링크된 단일 실행 파일을 만들더라도, 그 안에 포함된 다양한 컴포넌트를 개발하고 바이너리로 만드는 과정을 독립적으로 수행할 수 있게 하는 일은 대단히 가치 있는 일이다.
- 단일체에서 컴포넌트 간 통신은 매우 빠르고 값싸다. 통신은 전형적인 함수 호출에 지나지 않기 때문이다. 결과적으로, 소스 수준에서 결합이 분리되면 경계를 가로지르는 통신은 상당히 빈번할 수 있다.
- 단일체를 배포하는 일은 일반적으로 컴파일과 정적 링크 작업을 수반하므로, 대체로 이러한 시스템에서 컴포넌트는 소스 코드 형태로 전달된다.

#### 배포형 컴포넌트

- 아키텍처의 경계가 물리적으로 드러나는 가장 단순한 형태는 동적 링크 라이브러리
- 컴포넌트를 이 형태로 배포하면 따로 컴파일하지 않고 곧바로 사용할 수 있다.
- 배포 과정에서만 차이가 날 뿐, 배포 수준의 컴포넌트는 단일체와 동일하다.
- 배포형 컴포넌트의 경계를 가로지르는 통신은 순전히 함수 호출에 지나지 않으므로 매우 값싸다. 동적 링크와 런타임 로딩으로 인해 최초의 함수 호출은 오래 걸릴 수 있지만, 대체로 이들 경계를 가로지르는 통신은 매우 빈번할 굿이다.

#### 스레드

- 단일체와 배포형 컴포넌트는 모두 스레드를 활용할 수 있다.
- 스레드는 실행 계획과 순서를 체계화하는 방법에 가깝다. 모든 스레드가 단 하나의 컴포넌트에 포함될 수도 있고, 많은 컴포넌트에 걸쳐 분산될 수도 있다.

#### 로컬 프로세스

- 훨씬 강한 물리적 형태를 띠는 아키텍처 경계
- 로컬 프로세스 경계를 지나늩 오신에는 운영체제 호출, 데이터 마샬링 및 언마샬링, 프로레스 간 문맥 교환 등이 있으며, 이들은 제법 비싼 작업에 속한다. 따라서 통신이 너무 빈번하게 이뤄지지 않도록 신중하게 제한해야 한다.

#### 서비스

- 물리적인 형태를 띠는 가장 강력한 경계
- 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다. 따라서 주의를 기울여서 가능하다면 빈번하게 통신하는 일을 피해야 한다. 이 수준의 통신에서는 지연latency에 따른 문제를 고수준에서 처리할 수 있어야 한다.

#### 결론

- 단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.
- 대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있다.



### 19. 정책과 수준

- 컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서다.
- 소프트웨어 아키텍처를 개발하는 기술에는 이러한 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함된다. 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다. 서로 다른 이유로, 혹은 다른 시점에 변경되는 정책은 다른 수준에 위치하며, 반드시 다른 컴포넌트로 분리해야 한다.
- 좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 한다. 즉, 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다.

#### 수준

- 수준(level)
- 입력과 출력까지의 거리
- 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다. 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.
- 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙



### 20. 업무 규칙

