# 3. 설계 원칙

### 7. SRP: 단일 책임 원칙

- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
  - 액터actor: 해당 변경을 요청하는 한 명 이상의 사람들
- 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 *응집성cohension*
- 데이터와 메서드를 분리해 '우연한 중복'을 피한다.



### 8. OCP: 개방-폐쇄 원칙

- 소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다. 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.
- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다. 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.



### 9. LSP: 리스코프 치환 원칙

- 여기에서 필요한 것은 다음과 같은 치환(substitution) 원칙이다. S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면,S는 T의 하위 타입이다.
- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 매커니즘을 추가해야 할 수 있기 때문이다.



### 10. ISP: 인터페이스 분리 원칙

- 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.



### 11: DIP: 의존성 역전 원칙

- 유연성이 극대화된 시스템
  - 소스코드 의존성이 추상(abstract)에 의존하며 구체(concretion)에는 의존하지 않는 시스템
- 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰(volatile) 구체적인 요소다. 그리고 이 구체적인 요소는 우리가 열심히 개발하는 중이라 자주 변경될 수밖에 없는 모듈들이다.
- 추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야 한다. 반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 항상, 좀 더 정확히 말하면 대다수의 경우 변경될 필요가 없다. 따라서 인터페이스는 구현체보다 변동성이 낮다.
- 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.
- 코딩 실천법
  - 변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하라.
  - 변동성이 큰 구체 클래스로부터 파생하지 말라.
  - 구체 함수를 오버라이드 하지 말라.
  - 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.
- 제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점에 주목하자. 다시 말해 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다. 이러한 이유로 이 원칙을 의존성 역전(Dependency Inversion)이라고 부른다.

