# 2. 벽돌부터 시작하기: 프로그래밍 패러다임

### 3. 패러다임 개요

**구조적 프로그래밍**

- 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

**객체 지향 프로그래밍**

- 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

**함수형 프로그래밍**

- 할당문에 대해 규칙을 부과한다.



### 4. 구조적 프로그래밍



### 5. 객체 지향 프로그래밍

- 객체 지향(OO, Object-Oriented) 설계 원칙의 세 가지 개념
  - 캡슐화(encapsulation)
  - 상속(inheritance)
  - 다형성(polymorphism)

**캡슐화**

- OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다. 하지만 OO를 제공한다고 주창한 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 악화시켜 온 것은 틀림없다.

**상속**

- 상속이란 단순히 어떤 변수와 함수 하나를 유효 범위로 묶어서 재정의하는 일에 불과하다.
- OO 언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었다. 따라서 OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수는 있다.

**다형성**

- 함수를 가리키는 포인터를 응용한 것이 다형성이다.
- OO 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.
- 포인터 함수는 찾아내고 없애기 힘든 버그를 만들기 쉽고, OO 언어는 실수할 위험이 없다.

**다형성이 가진 힘**

- 플러그인 아키텍처(plugin architecture)는 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.
- OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

**의존성 역전**

- dependency inversion
- OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.
- OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다. 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한하지 않는다. 호출하는 모듈이든 호출 받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.
- 배포 독립성(independent deployability)
- 개발 독립성(independent developability)



### 6. 함수형 프로그래밍

**불변성과 아키텍처**

- 아키텍트는 왜 변수의 가변성을 염려하는가?
  - 경합race 조건, 교착상태deadlock 조건, 동시 업데이트concurrent update 문제는 모두 가변 변수로 인해 발생한다.
- 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다고 전제하다면 불변성은 실현 가능하다. 그렇지 않다면 일종의 타협이 필요하다.

**가변성의 분리**

- 가능한 한 많은 처리를 불변 컴포넌트로 옮기고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

**이벤트 소싱**

- event sourcing
- 상태가 아닌 트랜잭션을 저장하는 것
- 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.

**결론**

- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.

