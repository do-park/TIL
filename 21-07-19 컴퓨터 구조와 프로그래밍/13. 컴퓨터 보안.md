# 13. 컴퓨터 보안

> 보안(security)은 정보를 사적으로 유지하는 것으로부터 생겨난다.
>
> "쇠사슬은 가장 약한 고리만큼만 강하다"



### 보안과 프라이버시 개요

#### 위협 모델

- 보안은 **위협 모델**(threat model)에 따라 상대적이다. 위협 모델은 보안이 필요한 대상 목록과 각 보안 대상에 가해질 수 있는 공격을 열거해서, 이런 공격을 방어하는 방법을 설계할 수 있게 한다.
- 위협 모델을 정의하지 않으면 효과적으로 보안을 강화할 수 없다.
- 목표는 공격자가 통과하려면 비싸지만 방어자에게는 비용이 적게 드는 방어
  - 인터넷은 공격 비용은 극적으로 줄여주는데 방어 비용은 줄여주지 못한다.

#### 신뢰

- 위협 모델을 정할 때 가장 어려운 부분은 **신뢰**(trust)할 대상을 정하는 것
- 처음 신뢰를 하는 순간부터 보안은 나빠지고, 신뢰할 대상을 추가하면 할수록 보안은 더 악화된다.
- 컴퓨터에서의 신뢰는 선택할 수는 없지만 의존해야 하는 대상을 가리키는 말
- 신뢰 위반
  1. **의도적**(deliverate)
  2. **무능**(incompetent)
  3. **부정직**(disingenuous)
     - **클렙토그래피**(kleptography): 암호를 써서 안전하다고 생각하고 있는데 사용자도 모르게 암호화되지 않은 정보를 빼낼 수 있게 하는 여러가지 수단
- **투명성**(transparency)이나 **개방성**(openness)에서 더 나은 보안을 얻을 수 있다.

#### 통신 보안

- 통신 보안에서 신경써야 하는 것: **인증**(authentication), **진본성**(authenticity), **중간자 공격**(man-in-the-middle attack)
- **크립토그래피**(cryptography)
  - 송신자와 수신자만 아는 비밀 코드(secret code)를 사용해 **암호화**(encrypt)해서 보내면 수신자는 비밀 코드를 사용해 암호화된 메시지를 **복호화**(decrypt)한다.
  - 제대로 설계된 **암호 시스템**(cryptosystem)은 당사자 사이에 신뢰하는 요소의 수를 감소시킨다.

#### 모던 타임즈

- 공격자 추적을 어렵게 하는 요인 중 하나는 공격자가 **프록시**(proxy)를 사용한다는 점이다.
- 공격의 유형
  - 크립토그래피 시스템
    - 상대적으로 드물고, 잘 설계된 시스템을 공격하기 어렵다.
  - 사회적(social) 공격
    - 트릭을 써서 사용자에게 자신의 컴퓨터에 소프트웨어를 직접 설치하게 만듦

#### 인증과 권한부여

- **인증**(authentication): 어떤 사람이나 대상이 실제로 그 사람이나 대상임을 증명하는 과정
- **권한부여**(authorization): 제대로 된 '자격증명(credential)'을 제공하지 않는 사람에게 접근을 제한



### 크립토그래피

#### 스테가노그래피

- **스테가노그래피**(steganography)
- 어떤 내용을 다른 내용 속에 감추는 방ㅇ식
- 송신자와 수신자 사이에 연결의 자취가 남지 않아 비밀리에 통신하기 좋음

#### 치환 암호

- 각 문자를 다른 문자로 변환하는 표를 만들고, 표를 보고 메시지에서 원래의 문자를 그에 대응하는 다른 문자로 바꿔치기 하면서 메시지를 **암호화**(encrypt), 암호화된 메시지를 표를 참조해 역방향으로 치환하면서 **복호화**(decrypt)

- 통계를 사용해 쉽게 깰 수 있다.

#### 전치 암호

- **스키테일**(scytale)
- 둥근 막대기에 양피지 리본을 감고 메시지를 가로로 한 줄 적는다. 다른 줄에는 아무 메시지나 적는다. 결과적으로 양피지 리본을 풀면 뜻을 알 수 없는 문자들만 보이고, 이를 해독하기 위해 지름이 똑같은 막대기에 리본을 감아야 한다.

#### 일회용 패드

- **일회용 패드**(one-time pad)
- 가장 안전한 암호화 방식
- 중복되지 않은 유일한 치환 암호들의 모음으로 각 치환 암호 코드를 단 한번만 사용한다.

#### 키 교환 문제

- 대칭 암호 시스템에는 통신의 양 당사자가 같은 열쇠(키)를 사용해야 한다는 문제가 있다.
- 대칭 암호 시스템은 중간자 공격에 취약하다.

#### 공개키 암호

- **공개키 암호**(public key cryptography)
- 대칭키 암호에서는 암호화와 복호화에 같은 암호를 사용했지만, 공개키 암호에서는 누구에게나 알려져 있는 키를 **공개키**(public key)라고 부르고, 개인만 알고 있어야 하는 키를 **비밀키**(secret key)라고 부른다. 누군가 공개키로 암호화한 암호문은 비밀키로만 복호화할 수 있다.
- **비대칭**(asymmetric) 시스템
- 키 교환 문제를 해겨: 공개키를 알아도 그 키로는 암호문을 복호화할 수 없다.
- **트랩도어 함수**(trapdoor function)에 의존
  - 한 방향으로는 계산하기가 쉽지만 비밀 정보를 알지 못하면 반대쪽 방향으로는 계산이 어려운 함수
- 비대칭 암호화는 계산 비용이 많이 들기 때문에, 메시지 내용을 암호화할 때 사용할 대칭 **세션 키**(session key)를 만들기 위해 비대칭 암호화를 사용하는 경우도 자주 있다. (ex. **디피-헬먼 키 교환**(DHKE, Diffie-Hellman Key Exchange))

#### 전방향 안전성

- **전방향 안전성**(forward secret)
- 각 메시지마다 세션 키를 새로 만들어, 키를 알아내도 메시지를 단 하나만 풀 수 있게 한다.

#### 암호학적 해시 함수

- 암호학적 해시 함수의 핵심 특성은 **단방향**(one-way) 함수
  - 입력에서 해시값을 만들어내기는 쉬워도 해시에서 입력을 만들어낼 수는 없거나 만들어내려면 비용이나 시간이 많이 들어서 비실용적
- 도용하기가 어려워야 한다. 즉, 해시를 만들어내는 입력 데이터를 알아내기가 아주 어려워야 한다. 다시 말해, 해시 충돌을 만들어내기가 아주 어려워야 한다.
- 현재 SHA 알고리즘을 변형한 다른 해시 알고리즘이 사용

#### 디지털 서명

- **디지털 서명**(digital signature)
- 서명의 경우 공개키와 비밀키의 역할이 반대
- 정합성, 부인방지, 인증을 제공
  - **정합성**(integrity): 메시지가 변조됐는지 검증할 수 있다.
    - 데이터의 암호학적 해시값을 계산해 데이터 뒤에 추가함
  - **부인방지**(nonrepudiation): 메시지를 보낸 사람이 자기가 그런 메시지를 보낸 적이 없다고 주장할 수 없다.
    - 비밀키로 메시지에 서명을 하기 때문에 보낸 사람이 자신이 서명했음을 부인하기가 어렵다.
  - **인증**(authentication): 수신자는 공개키와 서명한 사람의 비밀키가 서로 연관되어 있음을 알고 있기 때문에 메시지에 서명한 사람을 확신할 수 있고, 변조가 되지 않았음은 해시값으로부터 확인할 수 있기 때문에, 수신자가 받은 메시지가 원본과 같은 메시지라는 사실을 확인할 수 있다.

#### 공개키 인프라

- 



### 보안을 위한 소프트웨어 예방 조치

### 정리

