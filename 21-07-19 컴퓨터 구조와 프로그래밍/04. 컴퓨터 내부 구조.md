# 4. 컴퓨터 내부 구조

> 컴퓨터(computer): 전자 부품을 다양하게 조합해 비트를 조작하는 회로를 만듦
>
> 현대적 컴퓨터는 크게 **메모리**(memory, 기억 장치), **입력과 출력**(I/O, input and output), **CPU**(central processing unit, 중앙 처리 장치)로 나눌 수 있다.



### 메모리

- 메모리: 컴퓨터에서 조작할 비트들을 저장할 장소

- 메모리 위치(memory location): 구체적인 주소에 있는 메모리

- 메모리의 기본 단위가 바이트라는 것이 바이트 단위로만 데이터를 읽어야 한다는 뜻은 아니다.

  - 32비트 컴퓨터는 메모리를 4바이트 덩어리로, 64비트 컴퓨터는 메모리를 8바이트 덩어리로 구성한다.

- **정렬이 맞지 않는 접근**(nonaligned access): 한 번에 두 긴 워드 주소에 걸쳐 있는 데이터를 읽는 경우

- 각 메모리는 서로 **가격/성능 비율**(price/performance rate, 가성비)이 다르다.

- **엔디안**(endian)에 따라 0번 바이트가 정해진다.

  - 한 시스템에서 다른 시스템으로 데이터를 전송할 때는 엔디안을 염두에 둬야 한다.

  

### 입력과 출력

- I/O: **입력**(input)/**출력**(output)
- **I/O 장치**(I/O device): I/O에 연결되는 장치
  - **주변장치**(peripheral device), **퍼리퍼럴**(peripheral)
- 컴퓨터가 물리적으로 큰 과거에는 전기적 연결이 한정적인 작은 패키지에 모든 것을 욱여넣기 힘들었기 때문에 I/O거리를 메모리 거리와 분리하는 것이 타당했다. 그러나 메모리 거리 주소 수가 많아지면서 메모리 거리 중 일부를 I/O 장치에 할당하는 것이 더 타당해졌다. 그리고 더 많은 부분을 연결이 한정적인 패키지에 구겨 넣어야 하기 때문에 I/O와 메모리가 같은 버스를 사용하는 것이 타당하다.
- 설계상 표준 입력/출력 **슬롯**(slot): 일관된 방식으로 I/O 장치를 연결할 수 있다.



### 중앙 처리 장치

- **중앙 처리 장치**(CPU, central processing unit)
  - 실제 계산을 처리하는 컴퓨터 부품
  - 다른 모든 요소는 CPU를 지원하는 역할

#### 산술 논리 장치

- **산술 논리 장치**(ALU, arithmetic logic unit)
- CPU의 핵심 부품. 산술 계산, 불리언 대수 및 기타 연산을 수행
- 구조
  - **피연산자**(operand): 수를 표현하는 비트
  - **명령코드**(opcode): 피연산자에 대해 ALU가 어떤 **연산자**(operator)를 적용할지 지정
  - **결과**(result): 피연산자에 연산자들을 적용한 결과
  - **조건 코드**(condition code): 결과에 대한 추가 정보
    - 보통 **조건 코드 레지스터**(condition code register)라는 레지스터에 조건 코드를 저장
- 실렉터와 논리 게이트의 연결

#### 시프트

- 왼쪽 시프트: 어떤 숫자의 모든 비트를 왼쪽으로 1비트씩 옮기고, 맨 왼쪽 비트는 버리고, 비게 되는 가장 오른쪽 비트에 0을 넣는다.
- 오른쪽 시프트: 어떤 숫자의 모든 비트를 오른쪽으로 1비트씩 옮기고, 맨 오른쪽 비트는 버리고, 비게 되는 가장 왼쪽 비트에 0을 넣는다.
- 왼쪽 시프트를 할 때 사라지는 MSB(가장 왼쪽 비트) 값이나 오른쪽 시프트를 하면 사라지는 LSB(가장 오른쪽 비트) 값이 필요할 때가 종종 있다. 그래서 이 비트를 조건 레지스터에 저장한다.
- 플립플롭을 사용해 클록에 따라 내용을 1비트씩 시프트하는 **시프트 레지스터**(shift register)를 플립플롭을 사용해 만들 수 있다.
- 순차적인 시프트 레지스터는 1비트를 시프트할 때 한 클록이 필요하기 때문에 느리다. → 실렉터와 조합 논리를 사용하는 **배럴 시프터**(barrel shifter)를 사용해 문제 해결 가능
- 시프터는 부동소수점 연산 구현의 핵심 부품이다.

#### 실행 장치

- **실행 장치**(execution unit), **제어 장치**(control unit)
- 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.
- **프로그램 저장 방식 컴퓨터**(stored-program computer)
  - 메모리에서 명령어 목록을 찾아 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.
- **명령어**(instruction)
  - 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴, CPU마다 고유한 설계, 공통 표준이 없음.

- **프로그램 카운터**(PC, program counter)
  - 메모리에서 명령어를 가져와야 하는 위치를 알려줌
  - 순수 레지스터 대신 카운터로 이뤄진다.
    - 카운터: 레지스터에 카운터 기능이 추가
  - 메모리 주소가 들어 있어 메모리의 위치를 가리킨다(또는 **참조**(reference)한다). 실행 장치는 프로그램 카운터가 가리키는 주소에서 명령어를 읽어온다. 프로그램 카운터의 값을 바꾸는 특별한 명령어를 실행하는 경우가 아니라면 명령어를 수행한 뒤에는 다음 명령어를 메모리의 다음 위치에서 가져올 수 있도록 프로그램 카운터가 **증가**(increment)된다.
  - CPU마다 정해진 초기 프로그램 카운터 값이 있으며, CPU 전원이 들어오면 PC는 이 값으로 설정된다.



### 명령어 집합

#### 명령어

- 3주소 명령어(three-address)
  - 명령어를 명령코드, 두 피연산자, 결과라는 네 가지 필드로 나누면 결과와 피연산자 주소에 4비트밖에 쓸 수 없어 쓸모있는 크기의 메모리를 가리킬 수 없다.
  - DRAM 주소 지정 기법
    - **PAE**(physical address extension, 물리 주소 확장)
      - **주소 확장 레지스터**(address estension register)를 두고 별도의 명령어를 사용해 상위 주소(주소에서 MSB에 가까운 비트들)를 지정한다.
      - 시간이 더 들고, 메모리 영역을 모두 지정하려면 여러 번 레지스터를 설정해야 한다.
  - 세 가지 메모리 위치를 한꺼번에 지정하는 메모리 주소 접근을 사용하므로 세 메모리 블록은 각기 다른 장치에 존재하며 주소 버스와 데이터 버스가 3개씩 따로 존재한다. 이 경우 연산 결과를 다른 연산에 활용하려면 결과가 들어 있는 메모리 장치에 있는 데이터를 다른 피연산자 메모리 장치로 보내기 위한 별도의 명령어를 사용해야 한다.
- **누산기**(accumulator)
  - A 레지스터
  - ALU가 계산한 결과를 저장
  - 한 메모리 위치에 있는 값과 누산기에 있는 값에 대한 연산을 수행하고 결과를 누산기에 넣는다. 그 결과 더 많은 주소 비트를 사용할 수 있지만, 간단한 계산의 경우 같은 일을 할 때 더 많은 명령어가 필요하다.



#### 주소 지정 모드

- **직접 주소 지정**(direct addressing): 사용할 주소가 명령어에 직접 들어가 있다.
- **간접 주소 지정**(indirect addressing): CPU는 명령어에 들어 있는 값을 피연산자 주소로 해석하지 않고, 피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소로 사용한다.
- **즉시 주소 지정 모드**(immediate addressing mode): 주소에 해당하는 비트를 그냥 값으로 간주
- 속도: 즉시 > 직접 > 간접 순으로 느려진다.



#### 조건 코드 명령어

	- cca: 조건 코드 레지스터의 값을 누산기로 복사
	- acc: 누산기의 값을 조건 코드 레지스터에 복사



#### 분기 명령어

- **분기**(branch) 명령어: 의사결정을 내리고 코드 중 일부를 선택적으로 실행
- 조건을 저장하기 위한 비트가 필요
- 프로그램 카운터의 내용을 명시적으로 바꾸는 명령어
  - pca: 현재 프로그램 카운터 값을 누산기에 복사
  - apc: 누산기의 값을 프로그램 카운터에 복사



#### 최종 명령어 집합 구성

> 15 ~ 14비트 (2): 모드
>
> 13 ~ 10비트 (4): 명령코드
>
> 9 ~ 0비트 (10): 주소



### 마지막 설계

#### 명령어 레지스터

- 페치(fetch): 메모리에서 명령어를 가져옴
- CPU에 **명령어 레지스터**(instruction register)를 추가해서 현재 실행 중인 명령어를 저장한다.



#### 데이터 경로와 제어 신호

- p.185 그림 4-22 데이터 경로와 제어 신호
- **간접 주소 레지스터**(indirect address register): 간접 주소 지정을 사용할 때 메모리에서 읽어온 주소를 어딘가에 저장한다.



#### 데이터 흐름 제어

- 페치를 하기 위해 필요한 신호

  - address source는 프로그램 카운터를 선택해야 한다.
  - 메모리를 동작시켜야 한다. 그리고 r/w bar는 읽기(1)로 설정해야 한다.
  - 명령어 레지스터를 동작시켜야(enable=1) 한다.

- 페치와 실행에 여러 단계가 필요하므로 각 단계의 추적할 카운터가 필요하다. 이 카운터의 내용과 명령어의 명령코드와 모드 부분이 제어 신호를 결정한다. 가장 복잡한 연산이 3단계가 필요하기 때문에 카운터는 2비트 카운터여야 한다.

- **랜덤 논리**(random logic): 복잡한 구조를 구현하는 경우, 정해진 개수의 입력이 있고 이 입력들을 정해진 개수의 출력에 연관시켜야 하는데 출력에 어떤 규칙성이 없을 때 게이트를 연결해 만든 회로도가 복잡해서 붙은 이름.

- **마이크로코드**(microcode): 적당한 크기의 메모리를 사용해 카운터의 출력과 명령어의 명령코드와 주소 지정 모드 부분을 메모리 주소에 연결. 

  - 이런 식으로 구현하는 방법을 **마이크로코드를 썼다**라고 한다.
  - 마이크로코드 메모리로 ROM을 쓰면 좋다.

  

### RISC와 CISC 명령어 집합

- RISC(reduced instruction set computer): 복잡한 명령어를 단순한 명령어를 조합해 처리
  - **적재-저장 구조**(load-store architecture)를 사용
  - 메모리와 레지스터를 오가는 명령어들과 레지스터 간 명령어로만 이뤄진 구조
- CISC(complicated instruction set computer): 기존 설계 방식으로 처리



### GPU

- **그래픽 처리 장치**(GPU, graphics processing unit)
- 간단한 처리 장치가 아주 많이 들어있다.
- GPU는 CPU보다 메모리 버스의 폭이 넓다. 이로 인해 메모리에 더 빠르게 접근할 수 있다.