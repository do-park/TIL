# 3. 메모리와 디스크의 핵심: 순차 논리

> 조합 논리: 입력에 의해서만 출력이 결정된다.
>
> **순차 논리**: 입력의 현재 상태와 과거 상태를 함께 고려한다.



### 시간 표현과 상태 기억

#### 발진자

- 시간 측정
- **되먹임**(feedback): 인버터의 출력을 입력에 연결
- 인버터 출력이 다시 인버터 입력으로 들어가며, 이 입력은 다시 출력에 반영된다. 이로 인해 출력이 0과 1 사이를 **진동한다**.(oscillate)
- 크리스털을 활용하면 정확한 발진자를 적은 비용으로 효율적으로 만들 수 있다.

#### 클록

- 발진자는 컴퓨터에 클록(clock, 시간을 셀 수 있게 해주는 신호)을 제공한다. 클록은 회로의 페이스를 결정한다.. 회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 속도에 의해 결정된다.
- **비닝**(binning): 부품을 측정해서 그 특성에 따라 여러 다른 빈이나 무더기로 분류. 부품 전체의 편차보다는 더 작은 편차를 갖도록 부품을 빈에 나눠 담는다. 부품의 전파 지연 시간을 표시할 때도 범위를 사용한다.
- **오버클로킹**(overclocking): 통계적으로 빈의 중간 정도에 위치하는 부품을 부품이 고장 나지 않을 범위 안에서 클록을 빠르게 공급함

#### 래치

- OR 게이트의 출력을 입력에 묶는 방식의 되먹임을 사용하면 정보를 기억할 수 있다.
- **S-R 래치**: 1비트 메모리, 액티브 로우 입력을 받아 **보수**(complementary) 출력을 제공한다.

#### 게이트가 있는 래치

- gate bar가 참(로우)인 상태에서는 D의 변화가 그대로 출력에 나타난다는 문제점이 있음

#### 플립플롭

- 데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화하기 위해 일반적으로 사용하는 방법은 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준에서 전이(**에지**, edge)되는 중간에 데이터를 잡아내는 것이다.
- **플립플롭**: 에지에 의해 데이터 변화가 촉발되는 래치(edge-triggered latch)
- **D 플립플롭**: 양의 에치(0에서 1로 바뀌는 순간)에 의해 데이터 변화가 촉발
- 에지에 의해 상태 변화가 촉발되는 장치의 상태 변화 타이밍을 볼 때는 전파 지연 외 요소도 고려해야 한다.
  - **설정 시간**(setup time): 클록 에지가 발생(즉, 클록값이 0에서 1로 전이)하기 전에 얼마나 오랫동안 입력 신호가 안정적으로 유지돼야 하는지
  - **유지 시간**(hold time): 클록 에지가 발생한 이후에 얼마나 오랫동안 입력 신호가 안정적으로 유지돼야 하는지

#### 카운터

- **리플 카운터**(ripple counter): 개수를 센 결과가 왼쪽에서 오른쪽으로 퍼져나감
  - 각 비트의 상태가 다른 비트의 상태 변화에 약간의 시차를 두고 바뀌기 때문에 이 회로를 **비동기 카운터**(asynchronous counter)라고도 부른다. 비동기 시스템은 언제 결과를 살펴봐야 맞는지 알기 어렵다는 단점이 있다.
- **동기적 카운터**(synchronous counter): 모든 플립플롭에 같은 클록을 병렬로 연결

#### 레지스터

- **레지스터**(register): 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것



### 메모리 조직과 주소 지정

- **주소**(address): 각 레지스터에 번호를 부여해 많은 정보를 저장할 수 있다.
  - 디코더의 출력: 레지스터의 입력을 활성화
  - 실렉터: 지정한 주소에 해당하는 레지스터의 출력을 선택
  - **트라이스테이트**(tri-state) 출력: 시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결
  - **버스**(bus): 주소와 데이터 간 연관된 신호
    - 메모리칩에는 주소 버스와 데이터 버스가 있다.
    - 비트를 이동시키는 대량 교통 수단
  - 행과 열 주소를 **멀티플렉싱**(multiplexing)하면 주소 라인의 수를 반으로 줄일 수 있다.

#### 임의 접근 메모리

- **임의 접근 메모리**(RAM, Random Access Memory): 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있다.
- **휘발성**(volatile) 메모리: 전원이 (잠시 또는 완전히) 끊어지면 데이터가 사라진다.
  - **정적 RAM**(SRAM, Static RAM): 비싸지만 빠르다. 각 비트에 6개의 트랜지스터가 들어가 크기가 크다.
  - **동적 RAM**(DRAM, Dynamic RAM): **커패시터**(capacitor)라는 아주 작은 버킷에 전자를 담고, 트랜지스터를 1개만 사용해 뚜껑을 덮는다. 주기적으로 메모리를 **갱신**(refresh)해야 한다.
    - 집적도(밀도, 단위 면적당 비트 개수)가 높아 큰 메모리 칩에 사용
- **비휘발성**(non-volatile) RAM
  - **코어**(core) 메모리: 비트를 토러스 모양 쇳조각에 저장
    - 토러스는 도는 바깥쪽 전자기 간섭에 대한 저항력이 아주 크다.
    - 3차원 메모리

#### 읽기 전용 메모리

- Read-only memory, ROM
- 한 번 쓰고 나면 여러 번 읽을 수 있다.
- **순차적**(sequential) 메모리: 데이터를 일정한 순서로만 읽을 수 있다.
- **마스크 프로그래머블**(mask-programmable) ROM: 임의 접근이 가능하다.
- **프로그래머블 읽기 전용 메모리**(PROM, Programmable ROM): 직접 프로그래밍할 수 있는 ROM이지만 단 한 번만 ROM에 프로그램을 적어 넣을 수 있었다.
- **지울 수 있는 읽기 전용 메모리**(EPROM, Erasable PROM): PROM과 비슷하지만 패키지 위쪽에 수정 창이 있어 특별한 자외선 빛 아래 EPROM을 넣어두면 저장된 내용을 지울 수 있었다.
- **전기로 지울 수 있는 읽기 전용 메모리**(EEPROM, Electrically EPROM): 지우는 과정이 느림. 내부 데이터를 아무 순서로나 쓰고 읽을 수 있어 기술적으로는 RAM. 하지만 데이터를 쓰는 데 오래 걸리고 RAM보다 비싸 ROM을 대신하는 목적으로 사용



### 블록 장치

- **대량 저장장치**(mass storage)
  -  **디스크 드라이브**(disk drive), **하드 드라이브**(hard drive)
  - 많은 데이터의 저장
  - 자화된 판(platter)에 비트를 저장하고 **디스크 헤드**(disk head)로 비트를 읽는다. 
  - 다른 유형의 메모리에 비해 상대적으로 느리고, 기계 부품이 시간이 지나면서 낡는다. 
  - 디스크의 영역을 자화시켜 데이터를 저장, 비휘발성
  - **블록**(block, **섹터**(sector)) 단위로 주소를 지정해 읽는다.
    - 모든 섹터에 같은 수의 비트가 들어있기 때문에 **비트 밀도**(bit density)는 각 원판의 바깥쪽보다 안쪽이 더 높다.
      - 최신 디스크들은 **방사성 영역**(radial zone)으로 구분해 해결. 내부 영역보다 외부 영역에 더 많은 섹터가 들어간다.
  - 디스크 드라이브의 성능을 표현하기 위한 수치
    - **탐색 시간**(seek time): 헤드를 한 트랙에서 다른 트랙으로 옮길 때 걸리는 시간
    - **회전 지연 시간**(rotational latency): 원하는 데이터가 헤드 아래로 올 때까지 디스크가 도는데 걸리는 시간, 밀리초 수준
- **자기 드럼**(magnetic drum)
  - 회전하는 원통에 헤드가 줄지어 있는 기억 장치
- **자기 테이프**(magnetic tape)
  - 자회시킨 테이프를 감은 릴(real)을 사용하는 비휘발성 저장장치
  - 디스크 드라이브보다 더 느리고 원하는 위치까지 테이프를 감는 데 오랜 시간이 걸린다.
- **광학 디스크**(optical disk)
  - 자기 디스크와 비슷하지만 데이터를 읽고 쓰기 위해 자성 대신 빛을 사용
  - 같은 데이터를 포함하는 디스크를 대량으로 찍어낼 수 있음
  - 한 번만 쓸 수 있는 디스크와(CD-R, DVD-R), 지우고 다시 쓸 수 있는 디스크(CD-RW, DVD-RW)가 있다.



### 플래시 메모리와 SSD

- **플래시 메모리**(flash memory)
  - 가장 최근 나타난 EEPROM 유형의 매체
  - DRAM과 마찬가지로 버킷에 전자를 담는 방식이지만 전자가 새지 않는다.
  - EEPROM보다 더 빨리 지울 수 있고 더 저렴하게 만들 수 있다.
  - RAM처럼 원하는 위치를 마음대로 읽을 수 있지만, 빈 플래시 메모리에 데이터를 기록하기 위해서는 먼저 0을 채워 넣어야 한다.
    - 전체를 지우지 않고 원하는 비트만 0으로 되돌릴 수는 없어, 내부를 블록으로 나눠 블록 단위로 값을 지우고 씀
  - 읽을 때는 임의 접근(random access), 쓸 때는 블록 접근(block access)
- **고체 상태 드라이브**(SSD, solid-state drive)
  - 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리
  - 플래시 메모리는 점차 낡기 때문에 SSD에는 여러 블록의 쓴 횟수를 기억해서 모든 블록이 가능하면 똑같은 속도로 낡도록 조정(wear leveling)하는 프로세서가 들어 있다.



### 오류 감지와 정정

- **패리티**(parity)
  - 단 1비트만 데이터가 잘못된 경우를 감지
  - 데이터에서 1로 설정된 비트의 개수를 세고, 그 개수가 짝수인지 홀수인지 나타내는 1비트를 데이터에 덧붙임
    - 모든 비트의 XOR
  - **홀수 패리티**(odd parity): XOR 한 값의 보수
  - 오류가 짝수 번 발생하면 오류가 발생하지 않은 경우와 구분이 불가능
  - 끊임없이 변화하는 데이터 처리에 유용
- 해밍 코드(Hamming code)
  - 더 많은 비트를 사용해 더 많은 오류를 감지, 오류 횟수가 작으면 오류가 일어난 부분을 바로 수정할 수도 있다.
  - 해밍 코드를 내장한 **오류 검사와 정정**(ECC, error checking and correnction) 메모리 칩도 있다.
- **체크섬**(checksum)
  - 정적인(값이 변하지 않는) 데이터 블록을 검증하는 더 값싼 방법
  - 데이터의 각 지점(ex. 바이트)을 n 비트값으로 더하고, n 비트를 넘어가는 값은 무시
  - n이 크면 클수록 위양성(false positive) 결과가 발생하기는 더 어려워진다.
    - 위양성: 어떤 특성이 있는데 어떤 검사 방법으로 판단한 겨과 그 특성이 없다고 판정성을 내리는 경우
- **순환 중복 검사**(CRC, cyclic redundancy check)
  - 데이터의 고유성을 충분히 드러낼 수 있는 방식으로 검증 숫자를 계산해서, 데이터가 약간이라도 바뀌면 검증 숫자가 더 이상 일치하지 않게 만듦



### 하드웨어와 소프트웨어 비교

- 소프트웨어는 설계에 들어가는 시간이라는 비용을 제외한 어떤 추가 비용도 들지 않기 때문에 소프트웨어가 하드웨어보다 더 만들기 쉽다.
- **펌웨어**(firmware)
  - ROM에 담긴 소프트웨어를 뜻하는 용어였으나 플래시 메모리, RAM에도 존재
  - 펌웨어와 펌웨어가 아닌 소프트웨어 사이의 차이가 적어졌다.
- 최근의 칩 설계는 베리로그(Verilog), VHDL, SystemC 등의 특별한 프로그래밍 언어를 사용해 이뤄진다.
- 초반에 모든 칩 설계는 **완전한 커스텀**(full custom, 설계자가 직접 만든) 설계
- 현대적 FPGA(field-programmable gate array, 현장에서 프로그램 가능한 게이트 배열)는 플래시 메모리에 해당하는 논리 칩
  - 소프트웨어 로직을 지우고 다시 프로그래밍할 수 있다.
  - 대부분의 경우 FPGA를 사용하는 편이 다른 요소를 사용하는 것보다 저렴하고 기능이 다양하다.
