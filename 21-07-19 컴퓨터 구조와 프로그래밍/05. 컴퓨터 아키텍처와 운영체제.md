# 5. 컴퓨터 아키텍처와 운영체제

> **컴퓨터 아키텍처**(computer architecture): 컴퓨터의 여러 구성요소를 배치하는 방법



### 기본적인 구조 요소들

- 컴퓨터 구조: 두 구조의 차이는 메모리 배열
  - **폰 노이만**(von Neumann) 구조: 하나의 메모리가 존재
  - **하버드**(Harvard) 구조: 두 개의 메모리(명령어 메모리, 데이터 메모리)가 존재
  - 나머지가 모두 같다면 메모리에서 동시에 명령어와 데이터를 가져올 수 없기 때문에 폰 노이만 구조가 약간 더 느리다.



#### 프로세서 코어

- **멀티프로세서**(multiprocessor) 시스템은 단일 CPU보다 훨씬 더 성능을 얻어내기 위한 방법이지만, 여러 CPU를 활용할 수 있도록 프로그램을 **병렬화**(parallelized)하는 문제는 일반적인 경우에는 풀 수 없는 문제
- 예전의 CPU라고 부르던 것을 요즘은 **프로세서 코어**(processor core)라고 부른다. 이런 코어가 여럿 들어가는 **멀티코어**(multicore) 프로세서가 이제는 일반적으로 쓰인다.



#### 마이크로프로세서와 마이크로컴퓨터

- 물리적 패키징에 따른 구조 구분
  - **마이크로프로세서**(microporcessor): 메모리와 I/O 프로세서 코어와 같은 패키지에 들어 있지 않은 프로세서, 큰 시스템에 들어가는 부품
  - **마이크로컴퓨터**(microcomputer): 모든 요소를 한 칩 안에 패키징, **마이크로컨트롤러**(microcontroller), 식기세척기 등에서 찾을 수 있는 단일 칩으로 된 작은 컴퓨터
  - 칩 안에서 메모리가 차지하는 영역이 크기 때문에 일반적으로 마이크로프로세서보다 마이크로컴퓨터가 덜 강력하다.
  - **단일 칩 시스템**(SoC, System on a Chip): 더 복잡한 마이크로 컴퓨터, WiFi 회로 등 더 복잡한 장치가 들어 있다.



### 프로시저, 서브루틴, 함수

- **함수**(function), **프로시저**(procedure), **서브루틴**(subroutine): 코드를 재사용하는 주요 수단
- 함수를 호출하는 부분에서 함수를 실행하고 다시 원래 자리로 돌아와야 한다. 이를 위해서는 어디서 함수로 들어갔는지를 기억해야 한다. 이 (함수로 들어간) 위치는 바로 프로그램 카운터의 값이다.



### 스택

- 재귀 함수가 제대로 동작하려면 반환 주소를 여럿 저장할 수 있어야 한다. 그리고 함수에서 호출 지점으로 반환할 때 저장된 주소 중 어떤 주소를 사용할지 결정할 수 있어야 한다.
- **깊이 우선 순회**(depth-first traversal): 트리 아래로 내려갈 수 있으면 항상 아래로 내려가고, 더 이상 아래로 내려갈 화살표가 없는 경우에만 옆에 있는 화살표로 넘어간다.
- **너비 우선 순회**(Breadth-first traversal): 옆에 있는 화살표를 먼저 방문하고 그 후 아래쪽으로 가는 화살표를 방문
- 트리에서 한 수준을 내려갈 때마다 돌아올 위치를 기억해야 한다. 일단 원래 위치로 돌아오고 나면 저장했던 위치는 더 이상 필요하지 않다.
- **스택**(stack), **LIFO** 구조(last in first out)
  - 물건을 **푸시**(push)해 넣고, 스택에서 물건을 **팝**(pop)해서 제거한다.
  - 스택에 물건을 푸시하는데 더 이상 들어갈 공간이 없으면 **스택 오버플로**(stack overflow)
  - 빈 스택에서 물건을 가져오려고 하면 **스택 언더플로**(stack underflow)
- **한계 레지스터**(limit register): 소프트웨어로 스택 오버플로를 항상 검사하지 않아도 되도록 돕는다.
- **스택 프레임**(stack frame): 함수가 호출될 때마다 스택에 저장되는 데이터의 모음



### 인터럽트

- **폴링**(polling): 하나의 장치(또는 프로그램)이 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치(또는 프로그램)의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식
- **잠깐 중단, 인터럽트**(interrupt): 적절한 신호가 들어오면 CPU 실행을 잠깐 중단시킬 수 있는 핀이나 전기 연결을 포함
  - CPU가 주의를 기울어야 하는 주변장치는 **인터럽트 요청**(interrupt request)을 생성한다. 프로세서는 현재 실행 중인 명령어를 끝까지 실행한다. 그 후 프로세서는 현재 실행 중인 프로그램을 잠시 중단시키고 **인터럽트 핸들러**(interrupt handler)라는 전혀 다른 프로그램을 실행하기 시작한다. 인터럽트 핸들러가 필요한 작업을 다 마치고 나면 원래 실행 중이던 프로그램이 중단된 위치부터 다시 실행을 계속한다.
- 고려해야 할 것
  - 인터럽트에 대한 **응답 시간**(response time): 인터럽트 처리를 정해진 시간 안에 끝내야 한다.
  - 인터럽트를 **서비스**(service)하고 나중에 다시 원래대로 돌아오기 위해서는 현재 **상태**(state)를 저장할 방법이 필요하다. (→ 스택)
- 인터럽트 핸들러 주소를 저장하기로 약속한 메모리 주소가 있다. 이 주소에는 여러 **인터럽트 벡터**(메모리 위치를 가리키는 포인터)가 들어 있고, 각 인터럽트 벡터는 CPU가 지원하는 각 인터럽트에 대한 핸들러 주소를 지정한다. 인터럽트가 일어나면 컴퓨터는 인터럽트 벡터에 저장된 주소를 살펴보고 제어를 그 주소로 옮긴다. (즉 프로그램 카운터를 인터럽트 벡터에 저장된 값으로 설정한다.)
- 인터럽트 제어
  - 어떤 인터럽트를 켜거나 끌 수 있다.
  - **마스크**(mask): 인터럽트를 중단시킬 수 있다.
  - 인터럽트 간 **우선순위**(priority)가 있어 중요한 인터럽트를 먼저 처리한다.
  - 일정 시간이 지나면(또는 일정 시간 간격으로) 인터럽트를 발생하는 내장 **타이머**(timer)
- 운영체제는 **물리적**(하드웨어) 인터럽트에 접근하거나, 일종의 **가상**(virtual) 인터럽트나 소프트웨어 인터럽트 시스템을 제공하기도 한다. (→ **이벤트**)



### 상대 주소 지정

- **커널**(kernel): 각 프로그램을 서로 전환시켜줄 수 있는 일종의 관리자 프로그램, 운영체제 또는 운영체제 커널

- **시스템** 프로그램: OS

- **사용자**(user) 프로그램, **프로세스**(process): 시스템 프로그램을 제외한 다른 모든 프로그램

- **시분할**(time slicing)

  - 시간을 정해진 간격으로 나누고, 정해진 시간 간격 동안 사용자 프로그램을 실행

  - 사용자 프로그램 **상태**(state) 또는 **문맥**(context)은 레지스터의 상태와 프로그램이 사용 중인 메모리의 상태를 뜻한다.

  - 프로그램을 메모리로 불러들이려면 시간이 걸린다. 프로그램을 메모리로 불러오되 각 프로그램에게 각기 다른 공간을 허용할 수 있으면 훨씬 더 빠르게 시분할 실행이 가능하다.

    - **절대 주소 지정**(absolute addressing): 명령어 주소가 특정 메모리 주소를 가리킨다.
    - **인덱스 레지스터**(index register): 인덱스 레지스터의 값을 명령어에 들어 있는 주소와 더해서 **유효 주소**(effective address)를 계산한다.
    - **상대 주소 지정**(relative addressing): 명령어에 들어 있는 주소를 0부터 시작하는 위치로 해석하지 않고, 명령어의 주소를 기준으로 하는 상대적인 주소로 해석한다. 프로그램을 메모리의 원하는 위치로 자유롭게 **재배치**(relocate)할 수 있다.

    

### 메모리 관리 장치

- **메모리 관리 장치**(MMU, memory management unit)
- MMU가 들어 있는 시스템은 **가상 주소**(virtual address)와 **물리 주소**(physical address)를 구분한다. 프로그램은 가상 주소를 사용해 작성되고, MMU는 가상 주소를 물리 주소로 변환해준다.
- MMU의 가상 주소 범위는 물리적 메모리 주소보다 큰 경우가 많다.
  - MMU는 가상 메모리 주소를 두 부분으로 나눈다. 주소의 하위(LSB) 부분은 물리적 주소 범위와 같다. 상위(MSB) 부분은 **페이지 테이블**(page table)이라는 RAM 영역을 통해 주소를 **변환**(translate)한다.
- 현대적 프로세서의 MMU는 페이지 테이블 크기가 정해져 있다. 전체 **페이지 테이블 항목**(page table entry)은 주 메모리에 저장되거나 주 메모리가 부족한 경우 디스크에 저장된다. MMU는 페이지 테이블 항목 중 일부를 필요할 때만 자신의 페이지 테이블로 읽어들인다.
- 일부 MMU 설계는 페이지 테이블에 제어 비트를 추가 제공한다. 
  - **실행 불가 비트**(no execute bit): CPU가 이 페이지에 있는 명령어를 실행할 수 없다.
  - **읽기 전용**(read only)으로 만드는 비트
- **페이지 폴트**(page fault) 예외: 프로그램이 물리적 메모리에 연관되지 않은 주소에 접근 시 발생
  - 스택 오버플로가 발생하면 페이지 폴트가 발생하고, 이 예외가 발생하면 OS는 실행 중인 프로그램을 중단시키는 대신 MMU가 추가 메모리를 할당하게 해서 스택 공간을 늘리고 사용자 프로그램 실행을 계속 할 수 있다.
- MMU를 사용하면 폰 노이만 구조의 시스템도 명령어 메모리와 데이터 메모리를 분리해 제공할 수 있다.



### 가상 메모리

- OS는 MMU를 사용해 사용자 프로그램에게 **가상 메모리**(virtual memory)를 제공한다.
- 요청받은 메모리가 사용 가능한 (물리적) 메모리의 크기보다 큰 경우: **요구불 페이징**(demand paging)
  - OS는 현재 필요하지 않은 메모리 페이지를 더 느리지만 더 용량이 큰 대용량 저장장치인 디스크로 옮긴다. (**스왑아웃**, swap out)
  - 스왑아웃한 페이지에 프로그램이 접근하면 운영체제는 필요한 메모리 공간을 확보하고 요청받은 페이지를 다시 메모리로 불러들인다. (**스왑인**, swap in)
  - 스와핑(swapping, 스왑인이나 스왑아웃)이 일어나면 시스템 성능이 크게 저하된다. 이를 막기 위해 페이지 접근을 추적해 스왑 아웃할 페이지를 결정하는 **최소 최근 사용**(LRU, least recently used) 알고리즘을 사용한다.
    - 최소 최근 사용: 최근에 가장 자주 사용된 페이지는 물리 메모리에 그대로 남겨두고 최근에 가장 덜 사용한 페이지를 스왑 아웃한다.



### 시스템 공간과 사용자 공간

- CPU에는 컴퓨터가 **시스템**(system) 모드에 있는지 **사용자**(user) 모드에 있는지 결정하는 비트가 어떤 레지스터 안에 들어 있다. I/O를 처리하는 명령어 등 일부 명령어는 **특권**(privileged) 명령어라서 오직 시스템 모드에서만 실행할 수 있다. **트랩**(trap)이나 **시스템 콜**(system call)이라고 부르는 특별한 명령어를 통해 사용자 모드에서 실행 중인 프로그램이 시스템 모드 프로그램(즉 운영체제)에게 요청을 보낼 수 있다.
- 장점
  - 사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프로그램을 다른 사용자 프로그램으로부터 보호한다.
  - 사용자 프로그램이 MMU 등의 몇몇 요소에 손을 댈 수 없기 때문에 운영체제가 프로그램에 대한 자원 할당을 전적으로 제어할 수 있다.



### 메모리 계층과 성능

- 빠른 CPU가 느린 메모리를 기다리느라고 아무 일도 하지 안하는 경우를 줄여야
- **메모리 계층**(memory hierachy): 사용자 프로그램에게는 모든 메모리가 같아 보이지만 메모리 시스템 내부에서 일어나는 일은 시스템 성능에 큰 영향을 끼친다.
- **캐시**(cache)를 CPU에 추가한다.
- CPU **메모리 컨트롤러**(memory controller) 하드웨어: 메모리에서 연속된 열에 있는 데이터를 한꺼번에 가져온다.
  - 메모리에 접근하는 패턴이 순차적이 아니어서 **캐시 실패**(cache miss)가 일어나도 CPU는 고속 메모리 접근 모드가 가능하기 때문에 좀 더 유리하다.
  - 캐시 실패: CPU가 캐시에서 어떤 내용(어떤 주 메모리 주소에 들어 있는 내용)을 찾았는데 캐시에 그 데이터가 없어서 메모리를 읽어야 하는 경우
  - **캐시 적중**(cache hit): CPU가 원하는 내용을 캐시에서 찾은 경우
- 캐시 메모리의 계층: CPU에서 멀어질수록 캐시는 더 느려지고 더 커진다. (L1, L2, L3)
- 디스패처(dispatcher): 메모리에서 데이터를 꺼내거나 데이터를 넣는 논리 회로
- 성능 향상을 위한 회로
  - **분기 예측**(branch prediction) 회로: 올바른 데이터를 메모리에서 **프리 페치**(prefetch, 미리 페치해서 가져옴)해서 캐시를 준비시키기 위해 조건 분기 명령어의 결과를 예측
  - **순서를 벗어나는 실행**(out-of-order execution)을 처리하는 회로
- **캐시 일관성**(cache coherency) 유지
  - **라이트 스루**(write through): 데이터를 캐시에 기록하는 동시에 메모리에도 기록, 캐시를 이용하는 장점의 대부분을 상쇄



### 코프로세서

- 프로세서 코어는 아주 복잡한 회로로 이뤄졌다. 몇 가지 연산을 **코프로세서**(coprocessor)라는 더 단순한 회로에 위임하면 프로세서 코어가 일반적인 연산에 활용할 수 있는 공간을 더 확보할 수 있다.



### 메모리상의 데이터 배치



### 프로그램 실행



### 메모리 전력 소비



