# 12. 병렬과 비동기성

### 경합 조건이란 무엇인가

- 2개(또는 그 이상)의 프로그램이 같은 자원에 동시에 접근하고, 자원 사용 순서에 따라 결과가 달라지는 경우



### 공유 자원

- **공유 자원**(shared resource)
- 거의 대부분이 공유 자원이 될 수 있다.
- 메모리는 항상 공유 문제와 연관이 되는데, 심지어는 공유 대상이 메모리가 아닌 경우에도 메모리가 관련된 경우가 많다. 공유 자원이 사용 중인지를 표현할 방법이 필요하기 때문이다.



### 프로세스와 스레드

- 운영체제는 **프로세스**(process)를 관리한다.
  - 프로세스: **사용자 공간**(user space)에서 실행되는 프로그램
- 멀티코어 시스템에서는 여러 프로그램이 병렬로 실행될 수 있고, 병렬로 실행되는 프로그램이 자원을 공유해야 경합 조건이 발생할 수 있다.
- 해결책
  - 자원을 공유하는 프로세스들은 어떤 방식으로든 서로 통신을 해야 한다
  - 핸들러를 인터럽트할 수 있게 만든다 
- **스레드**(thread): 정적인 데이터화 힙을 공유하지만 자체적으로 스택을 갖는 프로그램의 일부분, **경량 프로세스**(lightweight process)
  - 각 스레드는 자신이 CPU 레지스터를 완ㅇ전히 소유한다고 가정한다. 한 스레드에서 다른 스레드로 실행이 넘아갈 때는 **스레드 스케줄러**(thread scheduler)가 CPU를 저장해야 한다.
  - 스레드를 사용하면 한 프로세스 안에서 경합 조건을 만들 수 있다.
  - 스레드를 남용하면 나쁜 사용자 경험을 유발할 수 있다.
    - 스레드는 데이터를 공유하므로 보안 문제가 생길 수 있다.
    - 한 탭에서 문제가 생기거나 버그가 발생하면 전체 프로세스가 멈춘다.
    - 어떤 스레드가 작업을 완료하는 데 너무 오랜 시간이 걸리면 다른 모든 스레드가 실행되지 못해서 문제가 생길 수 있다.



### 락

- 우리가 처리해야 할 문제는 공유 자원이 아니라, 작은 연산으로 이뤄진 작업을 어떻게 **원자적**(atomic, 나눌 수 없고 인터럽트할 수 없다)으로 만들 수 있을까
- 코드에서 중요한 부분을 **상호 배제**(mutual exclusion) 메커니즘을 통해 원자적으로 처리하게 만들어야 한다.
- **어드바이저리 락**(advisory lock)

#### 트랜잭션과 작업 크기

- 성능 향상을 위해 여러 연산을 한 **트랜잭션**(transaction)에 넣을 수 있다.
  - 트랜잭션에 들어있는 연산은 각 연산을 독립적으로 수행하는 대신 한꺼번에 묶어서 처리한다.
- 어떤 대상을 잠그는 시간을 최소화해야 한다.
  - 락이 걸려 있는 시간이 길면 동시성이 줄어든다.
- 락이 걸린 **작업의 크기**(granularity)를 최소화해야 한다.
  - 시스템에서 아주 작은 부분만 잠그는 락을 **세밀하다**(fine-grained)
  - 더 큰 범위를 잠그는 락을 **성기다**(coars-grained)라고 한다.

#### 락 대기

- **스핀**(spin): 락을 성공적으로 얻을 때까지 락 획득을 반복 시도
- 락을 요청하는 존재가 락 획득 요청을 락을 관리하는 쪽에 **등록**(register)하고, 요청이 받아들여졌을 때 **통지**(notify)를 받는 수도 있다.
  - 규모를 쉽게 키우기 어렵고, 인터넷 아키텍처에서는 직접적으로 지원되지 않는다.
- **블로킹**(blocking): 시스템이 락을 할당할 수 있을 때까지 락을 요청한 프로그램을 일시중단(suspend, 프로그램이 잠시 실행을 멈춤)
- **논블로킹**(non-blocking): 프로그램이 계속 실행되고 나중에 락을 얻었는지 여부를 통지받게 된다.

#### 교착 상태

- **교착 상태**(deadlock)
- 공유 자원과 이 자원을 함께 사용하는 프로세스 | 스레드 등이 여럿 있는데 다음 네 가지 조건을 동시에 만족하는 경우에만 발생
  1. 상호 배제(mutual exclusion): 공유 자원을 함께 쓸 수 없어서 어느 한 프로세스가 독점적으로 사용해야만 한다.
  2. 점유 대기(hold and wait): 프로세스들은 어느 자원을 점유한 상태에서 다른 자원을 요청한다.
  3. 비선점(no preemption): 프로세스가 할당받은 자원을 강제로 빼앗을 수 없다.
  4. 순환 대기(circular wait): 각 프로세스가 서로 순환적으로 다른 프로세스가 갖고 있는 자원을 요구한다.
- 해소법
  1. 자원을 상호 배제하지 않고 언제든 공유할 수 있는 자원으로 만든다.
  2. 어느 자원을 점유한 다음에 다른 자원을 요구하지 않고 한꺼번에 자원을 요구한다.
  3. 선점형으로 바꾼다.
  4. 자원마다 우선순위를 부여해서 모든 프로세스가 다 서로 정해진 순서대로만 자원을 요구한다.

#### 단기 락 구현

- **검사 후 설정**(test and set): 원자적 명령어, 어떤 메모리 위치에 들어 있는 값을 1로 설정하고, 원래 그 위치에 들어 있던 값을 돌려준다.
- **비교 후 바꾸기**(compare and swap): 검사 후 설정과 비슷하지만, 한 값만 설정하는 대신 명령어를 호출하는 쪽에서 예전 값과 새 값을 모두 제공한다. 예전 값이 메모리 위치에 들어 있는 현재 값과 일치하면 메모리의 값을 새로운 값으로 바꾸고 프로세스는 락을 얻는다.
- 이런 명령어들은 시스템 모드에서만 사용하도록 제한된다.

#### 장기 락 구현

- 여러 프로그램이 자원에 접근하면 안 되는 경우
- 메모리보다 좀 더 영구적인 저장소: 파일



### 브라우저 자바스크립트

- 자바스크립트는 단일 스레드로 돌아가지만, 동시성이 문제가 될 수 있다.

- 자바스크립트가 현재 쓰이고 있는 용도를 염두에 두고 만들어진 언어가 아니기 때문

  - 자바스크립트의 목표: 더 빠르게 사용자 피드백을 제공하고 인터넷 트래픽을 줄이는 것

- 자바스크립트 구현은 **이벤트 루프**(event loop) 모델을 사용한다.

  - 실행할 작업을 **이벤트 큐**(event queue)에 추가한 뒤 하나씩 꺼내서 처리

- 처음에는 비동기 통신을 언어 설계에 포함하지 않았지만

  - 문서 객체 모델(DOM, Document Object Model)이 등장하면서 웹 페이지 중 일부만 변경 가능하게 됨
  - XHR(XMLHttpRequest)이 등장하면서 기존의 '페이지 로드(load)' 모델에서 벗어나 백그라운드에서 브라우저와 서버가 통신할 수 있게 됨

  과 같은 변화로 웹 페이지 복잡도가 극적으로 증가했고, 웹 페이지는 서버와의 비동기 통신에 극도로 의존하게 됐다.

- 자바스크립트 인터프리터는 프로그래머에게 단일 스레드 모델을 제공하지만 내부에서는 멀티스레드를 활용한다.



### 비동기 함수와 프로미스

- **프로미스**(promise): 비동기 콜백 메커니즘을 언어 고유 기능으로 넣어 라이브러리가 잘못 비동기 연산을 구현하지 못하게 한다.
- 비동기 연산을 처리하는 라이브러리가 프로미스를 사용하면 제대로 작동할 가능성이 더 커진다.
- 프로그래밍 패러다임(paradigm)의 변화
- **편의 문법**(syntactic sugar): 프로그래밍 언어를 더 복잡하게 만드는 대신 프로그래밍의 유형 중 일부를 편리하게 처리할 수 있게 해준다.



### 정리