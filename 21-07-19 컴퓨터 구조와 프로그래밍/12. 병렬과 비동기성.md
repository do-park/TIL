# 12. 병렬과 비동기성

### 경합 조건이란 무엇인가

- 2개(또는 그 이상)의 프로그램이 같은 자원에 동시에 접근하고, 자원 사용 순서에 따라 결과가 달라지는 경우



### 공유 자원

- **공유 자원**(shared resource)
- 거의 대부분이 공유 자원이 될 수 있다.
- 메모리는 항상 공유 문제와 연관이 되는데, 심지어는 공유 대상이 메모리가 아닌 경우에도 메모리가 관련된 경우가 많다. 공유 자원이 사용 중인지를 표현할 방법이 필요하기 때문이다.



### 프로세스와 스레드

- 운영체제는 **프로세스**(process)를 관리한다.
  - 프로세스: **사용자 공간**(user space)에서 실행되는 프로그램
- 멀티코어 시스템에서는 여러 프로그램이 병렬로 실행될 수 있고, 병렬로 실행되는 프로그램이 자원을 공유해야 경합 조건이 발생할 수 있다.
- 해결책
  - 자원을 공유하는 프로세스들은 어떤 방식으로든 서로 통신을 해야 한다
  - 핸들러를 인터럽트할 수 있게 만든다 
- **스레드**(thread): 정적인 데이터화 힙을 공유하지만 자체적으로 스택을 갖는 프로그램의 일부분, **경량 프로세스**(lightweight process)
  - 각 스레드는 자신이 CPU 레지스터를 완ㅇ전히 소유한다고 가정한다. 한 스레드에서 다른 스레드로 실행이 넘아갈 때는 **스레드 스케줄러**(thread scheduler)가 CPU를 저장해야 한다.
  - 스레드를 사용하면 한 프로세스 안에서 경합 조건을 만들 수 있다.
  - 스레드를 남용하면 나쁜 사용자 경험을 유발할 수 있다.
    - 스레드는 데이터를 공유하므로 보안 문제가 생길 수 있다.
    - 한 탭에서 문제가 생기거나 버그가 발생하면 전체 프로세스가 멈춘다.
    - 어떤 스레드가 작업을 완료하는 데 너무 오랜 시간이 걸리면 다른 모든 스레드가 실행되지 못해서 문제가 생길 수 있다.



### 락

- 우리가 처리해야 할 문제는 공유 자원이 아니라, 작은 연산으로 이뤄진 작업을 어떻게 **원자적**(atomic, 나눌 수 없고 인터럽트할 수 없다)으로 만들 수 있을까
- 코드에서 중요한 부분을 **상호 배제**(mutual exclusion) 메커니즘을 통해 원자적으로 처리하게 만들어야 한다.
- **어드바이저리 락**(advisory lock)

#### 트랜잭션과 작업 크기

- 성능 향상을 위해 여러 연산을 한 **트랜잭션**(transaction)에 넣을 수 있다.
  - 트랜잭션에 들어있는 연산은 각 연산을 독립적으로 수행하는 대신 한꺼번에 묶어서 처리한다.
- 어떤 대상을 잠그는 시간을 최소화해야 한다.
  - 락이 걸려 있는 시간이 길면 동시성이 줄어든다.
- 락이 걸린 **작업의 크기**(granularity)를 최소화해야 한다.
  - 시스템에서 아주 작은 부분만 잠그는 락을 **세밀하다**(fine-grained)
  - 더 큰 범위를 잠그는 락을 **성기다**(coars-grained)라고 한다.

#### 락 대기

- **스핀**(spin): 락을 성공적으로 얻을 때까지 락 획득을 반복 시도
- 락을 요청하는 존재가 락 획득 요청을 락을 관리하는 쪽에 **등록**(register)하고, 요청이 받아들여졌을 때 **통지**(notify)를 받는 수도 있다.
  - 규모를 쉽게 키우기 어렵고, 인터넷 아키텍처에서는 직접적으로 지원되지 않는다.
- **블로킹**(blocking): 시스템이 락을 할당할 수 있을 때까지 락을 요청한 프로그램을 일시중단(suspend, 프로그램이 잠시 실행을 멈춤)
- **논블로킹**(non-blocking): 프로그램이 계속 실행되고 나중에 락을 얻었는지 여부를 통지받게 된다.

#### 교착 상태

- **교착 상태**(deadlock)
- 공유 자원과 이 자원을 함께 사용하는 프로세스 | 스레드 등이 여럿 있는데 다음 네 가지 조건을 동시에 만족하는 경우에만 발생
  1. 상호 배제(mutual exclusion): 공유 자원을 함께 쓸 수 없어서 어느 한 프로세스가 독점적으로 사용해야만 한다.
  2. 점유 대기(hold and wait): 프로세스들은 어느 자원을 점유한 상태에서 다른 자원을 요청한다.
  3. 비선점(no preemption): 프로세스가 할당받은 자원을 강제로 빼앗을 수 없다.
  4. 순환 대기(circular wait): 각 프로세스가 서로 순환적으로 다른 프로세스가 갖고 있는 자원을 요구한다.
- 해소법
  1. 자원을 상호 배제하지 않고 언제든 공유할 수 있는 자원으로 만든다.
  2. 어느 자원을 점유한 다음에 다른 자원을 요구하지 않고 한꺼번에 자원을 요구한다.
  3. 선점형으로 바꾼다.
  4. 자원마다 우선순위를 부여해서 모든 프로세스가 다 서로 정해진 순서대로만 자원을 요구한다.

#### 단기 락 구현



### 브라우저 자바스크립트

### 비동기 함수와 프로미스

### 정리