# 1. 컴퓨터 내부의 언어 체계

### 비트

- 2진법을 사용한다는 뜻의 바이너리(binary) + ㅅ수자를 뜻하는 디지트(digit)
- 적은 비용으로 편리하게 기호를 담을 수 있다.
- 2진법을 사용



### 논리 연산

- 비트 사용법 중 하나: 예/아니요 질문에 대한 답을 표현하는 것
- 논리 연산: 다른 비트들이 표현하려는 내용으로부터 새로운 비트를 만들어내는 동작

#### 불리언 대수

- 불리언 대수: 비트에 대해 사용할 수 있는 연산 규칙의 집합
- 기본적인 불리언 연산자: NOT, AND, OR
  - NOT: 논리적 반대
  - AND: 둘 이상의 비트에 작용. 모든 비트가 참이면 AND 연산의 결과도 참
  - OR: 둘 이상의 비트에 작용. 어느 한 비트라도 참이면 OR 연산의 결과도 참
  - XOR: 배타적(exclusive) OR. 첫 번째 비트와 두 번째 비트가 다른 값인 경우에만 참.

#### 드모르간의 법칙

- 긍정적인 논리(positive logic)에 더해 부정적인 논리(negative logic)를 기술하는 명제를 사용할 때 드모르간의 법칙을 활용할 수 있다.

  - 긍정적인 논리: 정논리, 부정적인 논리: 부논리

- | a    | b    | a AND b | NOT a | NOT b | NOt a OR NOT b | NOT (NOT a OR NOT b) |
  | ---- | ---- | ------- | ----- | ----- | -------------- | -------------------- |
  | F    | F    | F       | T     | T     | T              | F                    |
  | F    | T    | F       | T     | F     | T              | F                    |
  | T    | F    | F       | F     | T     | T              | F                    |
  | T    | T    | T       | F     | F     | F              | T                    |

- 연산을 최소로 사용하면 비용을 최소화할 수 있다.



### 정수를 비트로 표현하는 방법

#### 양의 정수 표현

- 2진수 체계는 **2를 밑으로** 하는 수 체계
- **가장 작은 유효 비트**(least significant bit, LSB): 2진수에서 가장 오른쪽의 비트
- **가장 큰 유효 비트**(most significant bit, MSB): 2진수에서 가장 왼쪽의 비트

#### 2진수 덧셈

- 각 비트를 LSB에서 MSB 쪽으로 더하며 결과가 1보다 크면 1을 다음 자리(왼쪽)로 올린다.
- **오버플로**(overflow)
  - 덧셈 결과가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어난 경우
  - MSB에서 올림이 발생
  - 조건 코드(상태 코드) 레지스터(condition code register)에서 몇 가지 이상한 정보를 담아두는데 이 중 **오버플로 비트**(overflow bit)에서 MSB에서 발생한 올림값을 저장, 이 비트값을 통해 오버플로가 발생했는지 알 수 있다.
  - **언더플로**(underflow): MSB 위쪽에서 1을 빌려오는 경우

#### 음수 표현

- 부호와 크기
  - 음수와 양수를 구분하기 위해 흔히 **부호**(sign)를 사용한다. 우리는 가장 왼쪽 비트(MSB)를 부호에 사용하기로 결정했다.
  - 부호 비트가 0이면 이 2진수를 양수로 취급하고 부호 비트가 1이면 이 2진수를 음수로 취급한다.
  - 양수 0과 음수 0은 같은 0이기 때문에 표현할 수 있는 수의 가짓수는 2^n - 1가지가 된다.
  - **부호와 크기**(sign and magnitude) 표현법: 한 비트를 부호에 사용하고 나머지 비트를 수의 크기, 즉 0부터의 거리(절댓값)를 표현하기 위해 사용하는 방법
  - 널리 쓰이지 못하고 있는 이유
    - 비트들을 구성하려면 비용이 드는데 0을 표현하는 방법이 두 가지라서 비용이 낭비된다.
    - 부호와 크기 표현법을 사용하면 XOR과 AND를 통한 덧셈 계산을 사용할 수가 없다.
- 1의 보수(one's complement)
  - 음수를 표현하기 위해 양수의 모든 비트를 뒤집는 방법
  - NOT 연산을 통해 보수를 얻는다.
  - 문제점
    - 0을 두 가지 방식으로 표현한다.
    - 덧셈을 쉽게 할 수 없다. → **순환 올림**(end-around carry)을 통해 문제 해결이 가능하지만 순환 올림을 처리하기 위한 하드웨어를 추가해야 함.
      - 순환 올림: MSB 쪽에서 올림이 발생한 경우 LSB로 올림을 전달
- 2의 보수(two's complement)
  - 어떤 수의 비트를 뒤집고(즉 각 비트의 NOT을 취하고) 1을 추가해 음수를 얻는다. 이때 MSB에서 올림이 발생하면 이 값은 버린다.
  - 2의 보수 표현법에는 0을 표현하는 방법이 하나뿐이다.
- 같은 숫자로 이뤄진 수를 보더라도 문맥에 따라 표현하는 값이 달라질 수 있다.



### 실수를 표현하는 방법

- 밑이 10인 실수에는 10진 소수점(decimal point)이 포함된다. 따라서 밑이 2인 경우, 실수를 표기하기 위해 2진 소수점을 표현할 방법이 필요하다.

- #### 고정소수점 표현법

  - fixed-point
  - 2진수를 사용해 소수를 표현하기 위해 2진 소수점의 위치를 임의로 정함
  - 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많기 때문에 범용 컴퓨터에서 이런 방식을 사용하는 경우는 드물다.

- #### 부동소수점 표현법

  - floating-point
  - 과학적 표기법에서 10진 소수점 왼쪽이 한 자리뿐인 소수(가수, mantissa)에 10을 몇 번(지수, exponent) 거듭제곱한 값을 곱하는 방식으로 소수를 표현한다.
  - 비트 조합 중에 낭비되는 부분이 많다.
  - 비트 패턴이 가능한 모든 수를 표현하지는 못한다.
  
- #### IEEE 부동소수점 수 표준

  - 부동소수점 수 시스템은 컴퓨터에서 계산을 수행할 때 실수를 표현하는 표준 방법
  - 가수와 지수에 대해 각각 부호 비트를 사용하고, 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있다.
  - 낭비되는 비트 조합을 최소화하고 반올림을 쉽게 하기 위한 트릭이 존재
  - 똑같은 비트를 사용해 정밀도(percision)를 가능한 한 높이고 싶다
    - **정규화**(nomalization): 가수를 조정해서 맨 앞(왼쪽)에 0이 없게 만드는 것
    - 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략한다.
  - 기본 정밀도(single precision) 부동소수점 수
    - 32비트, 7비트 정밀도로 대략 +-10^(+-38) 범위를 표현
    - 단정도 실수
  - 2배 정밀도(double precision) 부동소수점 수
    - 64비트, 15비트 정밀도로 대략 +-10^(+-308) 범위를 표현
    - 배정도 실수
  - 편향된(biased) 지숫값을 사용해 지수 비트가 모두 0이거나 1인 경우에 특별한 의미를 갖게 하고, 실제 지숫값은 나머지 비트 패턴에 집어 넣음
  - 0으로 나눴을 때 생길 수 있는 양의 무한대나 음의 무한대를 표현하는 비트 패턴 등 여러 가지 특별한 비트 패턴을 제공

- #### 2진 코드화한 10진수 시스템

  - 